

===== browse.dart =====

import 'package:flutter/material.dart';
import 'quote.dart';

class BrowsePage extends StatefulWidget {
  final List<Quote> allQuotes;
  final Set<String> initialSelectedTags;

  const BrowsePage({
    super.key,
    required this.allQuotes,
    required this.initialSelectedTags,
  });

  @override
  BrowsePageState createState() => BrowsePageState();
}

class BrowsePageState extends State<BrowsePage> {
  late Set<String> _selectedTags;
  List<String> _allTags = [];

  @override
  void initState() {
    super.initState();
    _selectedTags = Set.from(widget.initialSelectedTags);
    _extractAllTags();
  }

  void _extractAllTags() {
    final Set<String> uniqueTags = {};
    for (final quote in widget.allQuotes) {
      uniqueTags.addAll(quote.tags);
    }
    _allTags = uniqueTags.toList()..sort();
  }

  void _toggleTag(String tag) {
    setState(() {
      if (_selectedTags.contains(tag)) {
        _selectedTags.remove(tag);
      } else {
        _selectedTags.add(tag);
      }
    });
  }

  void _clearAllTags() {
    setState(() {
      _selectedTags.clear();
    });
  }

  void _findQuotes() {
    Navigator.pop(context, _selectedTags);
  }

  Widget _buildTagItem(String tag) {
    final bool isSelected = _selectedTags.contains(tag);
    final isDark = Theme.of(context).brightness == Brightness.dark;

    return Card(
      elevation: isSelected ? 4 : 1,
      color: isSelected
          ? (isDark
                ? Colors.white.withOpacity(0.15)
                : Colors.black.withOpacity(0.1))
          : (isDark ? Colors.grey[800] : Colors.white),
      child: ListTile(
        leading: IconButton(
          icon: Icon(
            isSelected ? Icons.remove_circle : Icons.add_circle_outline,
            color: isSelected
                ? (isDark ? Colors.white : Colors.black)
                : (isDark ? Colors.white70 : Colors.grey[600]),
          ),
          onPressed: () => _toggleTag(tag),
        ),
        title: Text(
          tag,
          style: TextStyle(
            fontFamily: 'Georgia',
            fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
            color: isDark ? Colors.white : Colors.black,
          ),
        ),
        onTap: () => _toggleTag(tag),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final filteredQuotesCount = _getFilteredQuotesCount();
    final findButtonDisabled =
        _selectedTags.isNotEmpty && filteredQuotesCount == 0;

    return Scaffold(
      backgroundColor: isDark
          ? Colors.black
          : const Color.fromARGB(255, 240, 234, 225),
      appBar: AppBar(
        title: Text(
          'Browse Tags',
          style: TextStyle(
            color: isDark ? Colors.white : Colors.black,
            fontFamily: 'Georgia',
          ),
        ),
        backgroundColor: isDark
            ? Colors.black
            : const Color.fromARGB(255, 240, 234, 225),
        elevation: 0,
        iconTheme: IconThemeData(color: isDark ? Colors.white : Colors.black),
        actions: [
          if (_selectedTags.isNotEmpty)
            TextButton(
              onPressed: _clearAllTags,
              child: Text(
                'Clear All',
                style: TextStyle(
                  color: isDark ? Colors.white70 : Colors.black87,
                  fontFamily: 'Georgia',
                ),
              ),
            ),
        ],
      ),
      body: Column(
        children: [
          // Header section with selected tags count
          if (_selectedTags.isNotEmpty)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16.0),
              margin: const EdgeInsets.all(16.0),
              decoration: BoxDecoration(
                color: isDark
                    ? Colors.white.withOpacity(0.1)
                    : Colors.black.withOpacity(0.05),
                borderRadius: BorderRadius.circular(12.0),
                border: Border.all(
                  color: isDark
                      ? Colors.white.withOpacity(0.3)
                      : Colors.black.withOpacity(0.1),
                ),
              ),
              child: Column(
                children: [
                  Text(
                    '${_selectedTags.length} tag${_selectedTags.length == 1 ? '' : 's'} selected',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      color: isDark ? Colors.white : Colors.black,
                      fontFamily: 'Georgia',
                    ),
                  ),
                  const SizedBox(height: 8),
                  Wrap(
                    spacing: 8.0,
                    runSpacing: 4.0,
                    children: _selectedTags.map((tag) {
                      return Chip(
                        label: Text(
                          tag,
                          style: TextStyle(
                            fontSize: 12,
                            color: isDark ? Colors.black : Colors.black,
                            fontFamily: 'Georgia',
                          ),
                        ),
                        backgroundColor: isDark
                            ? Colors.white.withOpacity(0.7)
                            : Colors.black.withOpacity(0.1),
                        deleteIcon: Icon(
                          Icons.close,
                          size: 16,
                          color: isDark ? Colors.black : Colors.black,
                        ),
                        onDeleted: () => _toggleTag(tag),
                      );
                    }).toList(),
                  ),
                ],
              ),
            ),

          // Description
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text(
              'Select tags to filter quotes. You can choose multiple tags to find quotes that contain all selected tags.',
              style: TextStyle(
                fontSize: 14,
                color: isDark ? Colors.white70 : Colors.black87,
                fontFamily: 'Georgia',
              ),
              textAlign: TextAlign.center,
            ),
          ),
          const SizedBox(height: 16),

          // Tags list
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              itemCount: _allTags.length,
              itemBuilder: (context, index) {
                return Padding(
                  padding: const EdgeInsets.only(bottom: 8.0),
                  child: _buildTagItem(_allTags[index]),
                );
              },
            ),
          ),

          // Find button
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              onPressed: findButtonDisabled ? null : _findQuotes,
              style: ElevatedButton.styleFrom(
                backgroundColor: isDark
                    ? Colors.white.withOpacity(0.9)
                    : Colors.black.withOpacity(0.9),
                foregroundColor: isDark ? Colors.black : Colors.white,
                disabledBackgroundColor: isDark
                    ? Colors.white.withOpacity(0.1)
                    : Colors.black.withOpacity(0.05),
                padding: const EdgeInsets.symmetric(vertical: 16.0),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12.0),
                ),
              ),
              child: Text(
                findButtonDisabled
                    ? 'Find Quotes (0)'
                    : (_selectedTags.isEmpty
                          ? 'Show All Quotes'
                          : 'Find Quotes ($filteredQuotesCount)'),
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  fontFamily: 'Georgia',
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  int _getFilteredQuotesCount() {
    if (_selectedTags.isEmpty) return widget.allQuotes.length;

    return widget.allQuotes.where((quote) {
      return _selectedTags.every(
        (selectedTag) => quote.tags.contains(selectedTag),
      );
    }).length;
  }
}


===== about.dart =====

import 'package:flutter/material.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:flutter/foundation.dart';
import 'dev_panel.dart';

class AboutPage extends StatefulWidget {
  const AboutPage({super.key});

  @override
  State<AboutPage> createState() => _AboutPageState();
}

class _AboutPageState extends State<AboutPage> {
  PackageInfo _packageInfo = PackageInfo(
    appName: '',
    packageName: '',
    version: '',
    buildNumber: '',
    buildSignature: '',
  );

  @override
  void initState() {
    super.initState();
    _initPackageInfo();
  }

  Future<void> _initPackageInfo() async {
    final info = await PackageInfo.fromPlatform();
    setState(() {
      _packageInfo = info;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text(
          'About Literature Bites',
          style: TextStyle(
            color: Theme.of(context).primaryColor,
            fontFamily: 'Georgia',
          ),
        ),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "The act of reading is unreasonably profound. When we read, all we're doing is sitting still and moving our eyes around  - and yet, somehow, we can almost also feel our minds expanding. Reading is about more than information-gathering; it is about developing wisdom. \"When we read\", writes Mortimer Adler, \"we become enlightened\".",
              style: TextStyle(
                fontFamily: 'Georgia',
                fontSize: 16,
                height: 1.5,
                color: Theme.of(context).primaryColor.withOpacity(0.9),
              ),
            ),
            const SizedBox(height: 20),
            Text(
              "Literature is an expression of truth; it seeks to articulate that which we seek to understand. And yet, much of it can often feel abstruse and entirely unapproachable. For many of us without a degree in literature, a whole world of knowledge lies undiscovered. In a world that often values speed and efficiency over depth and complexity, it can be difficult to find the time and space to engage with literature in a meaningful way.",
              style: TextStyle(
                fontFamily: 'Georgia',
                fontSize: 16,
                height: 1.5,
                color: Theme.of(context).primaryColor.withOpacity(0.9),
              ),
            ),
            const SizedBox(height: 20),
            Text(
              "And it is for this reason that Literature Bites exists.",
              style: TextStyle(
                fontFamily: 'Georgia',
                fontSize: 16,
                fontWeight: FontWeight.bold,
                height: 1.5,
                color: Theme.of(context).primaryColor,
              ),
            ),
            // if (kDebugMode)
            //   ListTile(
            //     leading: const Icon(Icons.developer_mode),
            //     title: const Text('Developer Panel'),
            //     onTap: () {
            //       Navigator.push(
            //         context,
            //         MaterialPageRoute(
            //           builder: (context) => const DevPanelPage(),
            //         ),
            //       );
            //     },
            //   ),
            // const SizedBox(height: 24),
            // Text(
            //   'Version: ${_packageInfo.version}+${_packageInfo.buildNumber}',
            //   textAlign: TextAlign.center,
            //   style: Theme.of(context).textTheme.bodyLarge,
            // ),
          ],
        ),
      ),
    );
  }
}


===== quote_service.dart =====

import 'dart:convert';
import 'package:flutter/services.dart';
import 'quote.dart';

class QuoteService {
  static List<Quote>? _cachedQuotes;

  static Future<List<Quote>> loadQuotes() async {
    if (_cachedQuotes != null) {
      return _cachedQuotes!;
    }

    try {
      final String jsonString = await rootBundle.loadString(
        'assets/data/quotes.json',
      );
      final dynamic decoded = json.decode(jsonString);

      if (decoded is! List) {
        throw FormatException(
          'Top-level JSON must be a List, got ${decoded.runtimeType}',
        );
      }

      final List<dynamic> parsed = decoded;
      final List<Quote> result = [];

      for (var i = 0; i < parsed.length; i++) {
        final entry = parsed[i];
        try {
          if (entry is Map<String, dynamic>) {
            result.add(Quote.fromJson(entry));
          } else if (entry is Map) {
            // Handle Map<dynamic, dynamic> by creating a typed map
            result.add(Quote.fromJson(Map<String, dynamic>.from(entry)));
          } else {
            // Non-object element — warn and skip
            print(
              'Skipping element at index $i: expected object, got ${entry.runtimeType}',
            );
          }
        } catch (e, st) {
          final id = (entry is Map) ? entry['id'] : null;
          print(
            'Failed to parse quote at index $i${id != null ? " (id: $id)" : ""}: $e',
          );
          // Uncomment to see stack trace if needed
          // print(st);
          continue; // keep current behavior: bail out so you notice the bad item
        }
      }

      _cachedQuotes = result;
      return _cachedQuotes!;
    } catch (e) {
      print('Error loading quotes: $e');
      return [];
    }
  }

  static List<Quote> searchQuotes(List<Quote> quotes, String query) {
    if (query.isEmpty) return quotes;

    final lowercaseQuery = query.toLowerCase();
    return quotes.where((quote) {
      return quote.text.toLowerCase().contains(lowercaseQuery) ||
          quote.authorName.toLowerCase().contains(lowercaseQuery) ||
          quote.themes.any(
            (theme) => theme.toLowerCase().contains(lowercaseQuery),
          ) ||
          quote.tags.any((tag) => tag.toLowerCase().contains(lowercaseQuery));
    }).toList();
  }

  static List<Quote> filterByAuthor(List<Quote> quotes, String author) {
    return quotes
        .where(
          (quote) => quote.authorName.toLowerCase() == author.toLowerCase(),
        )
        .toList();
  }

  static List<Quote> filterByTheme(List<Quote> quotes, String theme) {
    return quotes
        .where(
          (quote) =>
              quote.themes.any((t) => t.toLowerCase() == theme.toLowerCase()),
        )
        .toList();
  }

  static List<Quote> filterByTag(List<Quote> quotes, String tag) {
    return quotes
        .where(
          (quote) =>
              quote.tags.any((t) => t.toLowerCase() == tag.toLowerCase()),
        )
        .toList();
  }
}


===== onboarding_page.dart =====

import 'package:flutter/material.dart';
import 'quote.dart';

class _Author implements Comparable<_Author> {
  final String name;
  final int score;

  const _Author({required this.name, required this.score});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _Author &&
          runtimeType == other.runtimeType &&
          name == other.name;

  @override
  int get hashCode => name.hashCode;

  @override
  int compareTo(_Author other) {
    if (other.score == score) {
      return name.compareTo(other.name);
    }
    return other.score.compareTo(score);
  }
}

class OnboardingPage extends StatefulWidget {
  final List<Quote> allQuotes;
  const OnboardingPage({super.key, required this.allQuotes});

  @override
  State<OnboardingPage> createState() => _OnboardingPageState();
}

const List<String> _curatedAuthors = [
  'Albert Camus',
  'Oscar Wilde',
  'Bertrand Russell',
  'Friedrich Nietzsche',
  'Jean-Paul Sartre',
  'Fyodor Dostoevsky',
  'Leo Tolstoy',
  'George Orwell',
  'Aldous Huxley',
  'Virginia Woolf',
  'James Joyce',
  'Ernest Hemingway',
  'Jane Austen',
  'Charles Dickens',
  'Kurt Vonnegut',
  'Philip K. Dick',
  'Franz Kafka',
  'Simone de Beauvoir',
  'Hermann Hesse',
];

class _OnboardingPageState extends State<OnboardingPage> {
  final PageController _pageController = PageController();
  int _currentPage = 0;
  String? _selectedFrequency;
  List<String> _allTags = [];
  final Set<String> _selectedTags = {};
  List<_Author> _allAuthors = [];
  List<_Author> _recommendedAuthors = [];
  List<_Author> _otherAuthors = [];
  List<_Author> _filteredAuthors = [];
  final Set<_Author> _selectedAuthors = {};
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _allTags = widget.allQuotes.expand((quote) => quote.tags).toSet().toList()
      ..sort();

    final Map<String, int> authorScores = {};
    for (var quote in widget.allQuotes) {
      final authorName = quote.authorName;
      final authorScore = quote.author_score ?? 0;
      if (!authorScores.containsKey(authorName) ||
          authorScores[authorName]! < authorScore) {
        authorScores[authorName] = authorScore;
      }
    }
    _allAuthors =
        authorScores.entries
            .map((entry) => _Author(name: entry.key, score: entry.value))
            .toList()
          ..sort();

    _recommendedAuthors = _allAuthors
        .where((author) => _curatedAuthors.contains(author.name))
        .toList();
    _otherAuthors = _allAuthors
        .where((author) => !_curatedAuthors.contains(author.name))
        .toList();

    _recommendedAuthors.sort();
    _otherAuthors.sort();

    _filteredAuthors = _allAuthors;

    _searchController.addListener(() {
      _filterAuthors();
    });
  }

  @override
  void dispose() {
    _pageController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  void _filterAuthors() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredAuthors = _allAuthors
          .where((author) => author.name.toLowerCase().contains(query))
          .toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 240, 234, 225),
      body: PageView(
        controller: _pageController,
        onPageChanged: (int page) {
          setState(() {
            _currentPage = page;
          });
        },
        children: [_buildWelcomePage(), _buildTagsPage(), _buildAuthorsPage()],
      ),
      bottomNavigationBar: _buildBottomNavBar(),
    );
  }

  Widget _buildWelcomePage() {
    return Padding(
      padding: const EdgeInsets.all(32.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Spacer(flex: 2),
          Text(
            'Welcome to',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 24,
              fontFamily: 'EBGaramond',
              color: Colors.grey[600],
            ),
          ),
          const Text(
            'Literature Bites',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 40,
              fontFamily: 'EBGaramond',
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 24),
          const Text(
            'Discover timeless wisdom from the world\'s greatest minds. Let\'s personalize your experience.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 18,
              fontFamily: 'EBGaramond',
              height: 1.5,
            ),
          ),
          const Spacer(flex: 1),
          Text(
            'How often do you read?',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 20,
              fontFamily: 'EBGaramond',
              fontWeight: FontWeight.w600,
              color: Colors.grey[800],
            ),
          ),
          const SizedBox(height: 16),
          _buildChoiceChip("Just starting"),
          const SizedBox(height: 12),
          _buildChoiceChip("Casually"),
          const SizedBox(height: 12),
          _buildChoiceChip("I'm an avid reader!"),
          const Spacer(flex: 3),
        ],
      ),
    );
  }

  Widget _buildChoiceChip(String label) {
    final bool isSelected = _selectedFrequency == label;
    return OutlinedButton(
      onPressed: () {
        setState(() {
          _selectedFrequency = label;
        });
      },
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(vertical: 16),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
        side: BorderSide(
          color: isSelected ? Colors.black : Colors.grey[300]!,
          width: isSelected ? 1.5 : 1,
        ),
        backgroundColor: isSelected ? Colors.black.withOpacity(0.05) : null,
      ),
      child: Text(
        label,
        style: const TextStyle(
          fontFamily: 'EBGaramond',
          fontSize: 16,
          fontWeight: FontWeight.w500,
          color: Colors.black,
        ),
      ),
    );
  }

  Widget _buildTagsPage() {
    return Padding(
      padding: const EdgeInsets.all(32.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Spacer(flex: 1),
          const Text(
            'What do you like to read?',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 28,
              fontFamily: 'EBGaramond',
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          Text(
            'Select a few genres to help us recommend quotes you\'ll love. You can change this any time.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 18,
              fontFamily: 'EBGaramond',
              color: Colors.grey[600],
              height: 1.5,
            ),
          ),
          const SizedBox(height: 32),
          Expanded(
            flex: 5,
            child: SingleChildScrollView(
              child: Wrap(
                spacing: 12.0,
                runSpacing: 12.0,
                alignment: WrapAlignment.center,
                children: _allTags.map((tag) => _buildTagChip(tag)).toList(),
              ),
            ),
          ),
          const Spacer(flex: 1),
        ],
      ),
    );
  }

  Widget _buildAuthorsPage() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Spacer(flex: 1),
          const Text(
            'Any favorite authors?',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 28,
              fontFamily: 'EBGaramond',
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          Text(
            'This helps us find quotes from writers you already enjoy.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 18,
              fontFamily: 'EBGaramond',
              color: Colors.grey[600],
              height: 1.5,
            ),
          ),
          const SizedBox(height: 24),
          TextField(
            controller: _searchController,
            decoration: InputDecoration(
              hintText: 'Search for an author...',
              prefixIcon: const Icon(Icons.search),
              filled: true,
              fillColor: Colors.black.withOpacity(0.05),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(30),
                borderSide: BorderSide.none,
              ),
            ),
          ),
          const SizedBox(height: 24),
          Expanded(
            flex: 5,
            child: _searchController.text.isNotEmpty
                ? _buildFilteredAuthorList()
                : _buildCategorizedAuthorList(),
          ),
          const Spacer(flex: 1),
        ],
      ),
    );
  }

  Widget _buildFilteredAuthorList() {
    return ListView.builder(
      itemCount: _filteredAuthors.length,
      itemBuilder: (context, index) {
        return _buildAuthorTile(_filteredAuthors[index]);
      },
    );
  }

  Widget _buildCategorizedAuthorList() {
    final itemCount =
        _recommendedAuthors.length +
        _otherAuthors.length +
        (_otherAuthors.isNotEmpty ? 2 : 1);

    return ListView.builder(
      itemCount: itemCount,
      itemBuilder: (context, index) {
        // Recommended Header
        if (index == 0) {
          return _buildSectionHeader('Recommended Authors');
        }
        // Recommended List
        if (index <= _recommendedAuthors.length) {
          final author = _recommendedAuthors[index - 1];
          return _buildAuthorTile(author);
        }
        // All Authors Header
        if (_otherAuthors.isNotEmpty &&
            index == _recommendedAuthors.length + 1) {
          return _buildSectionHeader('All Authors');
        }
        // All Authors List
        final author = _otherAuthors[index - _recommendedAuthors.length - 2];
        return _buildAuthorTile(author);
      },
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title,
        style: const TextStyle(
          fontFamily: 'EBGaramond',
          fontSize: 18,
          fontWeight: FontWeight.bold,
          color: Colors.black54,
        ),
      ),
    );
  }

  Widget _buildAuthorTile(_Author author) {
    final isSelected = _selectedAuthors.contains(author);
    return ListTile(
      title: Text(
        author.name,
        style: const TextStyle(fontFamily: 'EBGaramond'),
      ),
      trailing: Checkbox(
        value: isSelected,
        onChanged: (bool? value) {
          setState(() {
            if (value == true) {
              _selectedAuthors.add(author);
            } else {
              _selectedAuthors.remove(author);
            }
          });
        },
        activeColor: Colors.black,
      ),
      onTap: () {
        setState(() {
          if (isSelected) {
            _selectedAuthors.remove(author);
          } else {
            _selectedAuthors.add(author);
          }
        });
      },
    );
  }

  Widget _buildTagChip(String tag) {
    final bool isSelected = _selectedTags.contains(tag);
    return GestureDetector(
      onTap: () {
        setState(() {
          if (isSelected) {
            _selectedTags.remove(tag);
          } else {
            _selectedTags.add(tag);
          }
        });
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 10.0),
        decoration: BoxDecoration(
          color: isSelected ? Colors.black : Colors.black.withOpacity(0.1),
          borderRadius: BorderRadius.circular(30.0),
        ),
        child: Text(
          tag,
          style: TextStyle(
            color: isSelected ? Colors.white : Colors.black,
            fontSize: 14.0,
            fontWeight: FontWeight.w500,
            fontFamily: 'EBGaramond',
          ),
        ),
      ),
    );
  }

  Widget _buildBottomNavBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 20),
      height: 100,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          TextButton(
            onPressed: () {
              // Skip onboarding
              Navigator.of(context).pop();
            },
            child: const Text(
              'Skip',
              style: TextStyle(
                color: Colors.grey,
                fontFamily: 'EBGaramond',
                fontSize: 16,
              ),
            ),
          ),
          ElevatedButton(
            onPressed: () {
              if (_currentPage < 2) {
                _pageController.nextPage(
                  duration: const Duration(milliseconds: 400),
                  curve: Curves.easeInOut,
                );
              } else {
                // Finish onboarding
                final OnboardingResult result = OnboardingResult(
                  selectedTags: _selectedTags,
                  selectedAuthors: _selectedAuthors.map((a) => a.name).toSet(),
                );
                Navigator.of(context).pop(result);
              }
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.black,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(30),
              ),
              padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 15),
            ),
            child: Text(
              _currentPage == 2 ? 'Finish' : 'Next',
              style: const TextStyle(
                fontFamily: 'EBGaramond',
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class OnboardingResult {
  final Set<String> selectedTags;
  final Set<String> selectedAuthors;

  OnboardingResult({required this.selectedTags, required this.selectedAuthors});
}


===== quote_quiz_page.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quiz_models.dart';
import 'package:quotes_app/quiz_service.dart';
import 'package:quotes_app/srs_service.dart';
import 'quote.dart';

class QuoteQuizPage extends StatefulWidget {
  final List<Quote> favoriteQuotes;
  final List<Quote> allQuotes;

  const QuoteQuizPage({
    super.key,
    required this.favoriteQuotes,
    required this.allQuotes,
  });

  @override
  State<QuoteQuizPage> createState() => _QuoteQuizPageState();
}

class _QuoteQuizPageState extends State<QuoteQuizPage> {
  final QuizService _quizService = QuizService();
  final SRSService _srsService = SRSService();

  QuizQuestion? _currentQuestion;
  bool _answered = false;
  String? _selectedAnswer;

  @override
  void initState() {
    super.initState();
    _generateQuestion();
  }

  Future<void> _generateQuestion() async {
    final dueQuoteIds = await _srsService.loadDue(DateTime.now());
    final dueQuotes = widget.favoriteQuotes
        .where((quote) => dueQuoteIds.contains(quote.id))
        .toList();

    setState(() {
      _currentQuestion = _quizService.generateSingleQuestion(
        fromQuotes: dueQuotes.isNotEmpty ? dueQuotes : widget.favoriteQuotes,
        allQuotes: widget.allQuotes,
        allowedTypes: [QuizType.whoSaidThis, QuizType.whatSource],
      );
      _answered = false;
      _selectedAnswer = null;
    });
  }

  void _handleAnswer(String answer) {
    if (_answered) return;
    final isCorrect = answer == _currentQuestion!.correctAnswer;
    setState(() {
      _selectedAnswer = answer;
      _answered = true;
      _srsService.grade(
        _currentQuestion!.quote.id,
        correct: isCorrect,
        today: DateTime.now(),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final backgroundColor = Theme.of(context).scaffoldBackgroundColor;
    final textColor = Theme.of(context).primaryColor;

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        title: Text(
          'Quote Quizzes',
          style: TextStyle(fontFamily: 'Georgia', color: textColor),
        ),
        backgroundColor: backgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: textColor),
        actions: [
          TextButton(
            onPressed: _generateQuestion,
            child: Text(
              'Skip',
              style: TextStyle(color: textColor.withOpacity(0.7)),
            ),
          ),
        ],
      ),
      body: _currentQuestion == null
          ? _buildEmptyState(textColor)
          : _buildMultipleChoiceUI(textColor),
    );
  }

  Widget _buildEmptyState(Color textColor) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32.0),
        child: Text(
          widget.favoriteQuotes.isEmpty
              ? 'Add quotes to your favorites to start a quiz.'
              : 'Could not generate a question. Try adding more diverse quotes to your favorites!',
          textAlign: TextAlign.center,
          style: TextStyle(
            fontFamily: 'Georgia',
            fontSize: 18,
            color: textColor,
          ),
        ),
      ),
    );
  }

  Widget _buildMultipleChoiceUI(Color textColor) {
    final question = _currentQuestion!;
    final isCorrect = _selectedAnswer == question.correctAnswer;

    return Column(
      children: [
        if (question.quoteText != null)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(20),
            margin: const EdgeInsets.all(24.0),
            decoration: BoxDecoration(
              color: Theme.of(context).brightness == Brightness.dark
                  ? Colors.white.withOpacity(0.1)
                  : Colors.black.withOpacity(0.05),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              '"${question.quoteText!}"',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 20,
                fontFamily: 'Georgia',
                fontStyle: FontStyle.italic,
                color: textColor,
              ),
            ),
          ),
        Padding(
          padding: EdgeInsets.symmetric(
            horizontal: 24.0,
            vertical: question.quoteText == null ? 24.0 : 16.0,
          ),
          child: Text(
            question.questionText,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 18,
              fontFamily: 'Georgia',
              fontWeight: FontWeight.bold,
              color: textColor.withOpacity(0.9),
            ),
          ),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: question.options.length,
            itemBuilder: (context, index) {
              final option = question.options[index];
              Color? tileColor;
              IconData? icon;

              if (_answered) {
                if (option == question.correctAnswer) {
                  tileColor = Colors.green.withOpacity(0.2);
                  icon = Icons.check_circle;
                } else if (option == _selectedAnswer) {
                  tileColor = Colors.red.withOpacity(0.2);
                  icon = Icons.cancel;
                }
              }

              return Card(
                elevation: _answered ? 0 : 1,
                margin: const EdgeInsets.symmetric(
                  vertical: 6.0,
                  horizontal: 16.0,
                ),
                color:
                    tileColor ??
                    (Theme.of(context).brightness == Brightness.dark
                        ? Colors.grey[850]
                        : Colors.white),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                  side: BorderSide(
                    color: _answered && option == question.correctAnswer
                        ? Colors.green
                        : Colors.transparent,
                    width: 1,
                  ),
                ),
                child: ListTile(
                  title: Text(
                    option,
                    style: TextStyle(fontFamily: 'Georgia', color: textColor),
                  ),
                  trailing: icon != null
                      ? Icon(
                          icon,
                          color: option == question.correctAnswer
                              ? Colors.green
                              : Colors.red,
                        )
                      : null,
                  onTap: () => _handleAnswer(option),
                ),
              );
            },
          ),
        ),
        if (_answered)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Theme.of(context).primaryColor,
                foregroundColor: Theme.of(context).scaffoldBackgroundColor,
                minimumSize: const Size(double.infinity, 50),
              ),
              onPressed: _generateQuestion,
              child: Text(
                isCorrect ? 'Next' : 'Continue',
                style: const TextStyle(fontSize: 16, fontFamily: 'Georgia'),
              ),
            ),
          ),
      ],
    );
  }
}


===== quiz_models.dart =====

import 'package:quotes_app/quote.dart';

enum QuizType { whoSaidThis, whatSource, authorPeriod }

class QuizQuestion {
  final Quote quote;
  final QuizType quizType;
  final String questionText;
  final List<String> options;
  final String correctAnswer;
  final String? quoteText;

  QuizQuestion({
    required this.quote,
    required this.quizType,
    required this.questionText,
    required this.options,
    required this.correctAnswer,
    this.quoteText,
  });
}


===== flashcards_page.dart =====

import 'package:flutter/material.dart';
import 'quote.dart';

class FlashcardsPage extends StatefulWidget {
  final List<Quote> favoriteQuotes;

  const FlashcardsPage({super.key, required this.favoriteQuotes});

  @override
  State<FlashcardsPage> createState() => _FlashcardsPageState();
}

class _FlashcardsPageState extends State<FlashcardsPage> {
  int _currentIndex = 0;
  bool _isFlipped = false;

  void _flipCard() {
    setState(() {
      _isFlipped = !_isFlipped;
    });
  }

  void _nextCard() {
    if (widget.favoriteQuotes.length > 1) {
      setState(() {
        _currentIndex = (_currentIndex + 1) % widget.favoriteQuotes.length;
        _isFlipped = false;
      });
    }
  }

  void _previousCard() {
    if (widget.favoriteQuotes.length > 1) {
      setState(() {
        _currentIndex =
            (_currentIndex - 1 + widget.favoriteQuotes.length) %
            widget.favoriteQuotes.length;
        _isFlipped = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final backgroundColor = Theme.of(context).scaffoldBackgroundColor;
    final textColor = Theme.of(context).primaryColor;

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        title: Text(
          'Flashcards',
          style: TextStyle(fontFamily: 'Georgia', color: textColor),
        ),
        backgroundColor: backgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: textColor),
      ),
      body: widget.favoriteQuotes.isEmpty
          ? Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 32.0),
                child: Text(
                  'Add quotes to your favorites to use flashcards.',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    fontFamily: 'Georgia',
                    fontSize: 18,
                    color: textColor,
                  ),
                ),
              ),
            )
          : Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                GestureDetector(
                  onTap: _flipCard,
                  child: Card(
                    margin: const EdgeInsets.all(24.0),
                    elevation: 8,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Container(
                      width: double.infinity,
                      height: MediaQuery.of(context).size.height * 0.5,
                      padding: const EdgeInsets.all(24.0),
                      child: Center(
                        child: AnimatedCrossFade(
                          duration: const Duration(milliseconds: 300),
                          firstChild: _buildCardFront(
                            widget.favoriteQuotes[_currentIndex],
                          ),
                          secondChild: _buildCardBack(
                            widget.favoriteQuotes[_currentIndex],
                          ),
                          crossFadeState: _isFlipped
                              ? CrossFadeState.showSecond
                              : CrossFadeState.showFirst,
                        ),
                      ),
                    ),
                  ),
                ),
                Text(
                  'Tap card to flip',
                  style: TextStyle(
                    color: textColor.withOpacity(0.7),
                    fontFamily: 'Georgia',
                  ),
                ),
                const SizedBox(height: 32),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    IconButton(
                      icon: const Icon(Icons.arrow_back_ios),
                      onPressed: _previousCard,
                      iconSize: 32,
                      color: textColor,
                    ),
                    Text(
                      '${_currentIndex + 1} / ${widget.favoriteQuotes.length}',
                      style: TextStyle(
                        fontSize: 18,
                        fontFamily: 'Georgia',
                        color: textColor,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.arrow_forward_ios),
                      onPressed: _nextCard,
                      iconSize: 32,
                      color: textColor,
                    ),
                  ],
                ),
              ],
            ),
    );
  }

  Widget _buildCardFront(Quote quote) {
    return SingleChildScrollView(
      child: Text(
        quote.text,
        textAlign: TextAlign.center,
        style: const TextStyle(
          fontSize: 22,
          fontFamily: 'Georgia',
          fontStyle: FontStyle.italic,
          height: 1.5,
        ),
      ),
    );
  }

  Widget _buildCardBack(Quote quote) {
    return SingleChildScrollView(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            '— ${quote.authorInfo}',
            textAlign: TextAlign.center,
            style: const TextStyle(
              fontSize: 20,
              fontFamily: 'Georgia',
              fontWeight: FontWeight.bold,
            ),
          ),
          if (quote.displaySource.isNotEmpty) ...[
            const SizedBox(height: 16),
            Text(
              quote.displaySource,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                fontFamily: 'Georgia',
                fontStyle: FontStyle.italic,
                color: Theme.of(context).brightness == Brightness.dark
                    ? Colors.grey[400]
                    : Colors.grey[600],
              ),
            ),
          ],
        ],
      ),
    );
  }
}


===== quote.dart =====

class Quote {
  final String id;
  final String text;
  final String authorName;
  final int? authorBirth;
  final int? authorDeath;
  final String? source;
  final String? work;
  final int? year;
  final List<String> themes;
  final List<String> tags;
  final String? context;
  final String? notes;
  final String status;
  final String? interpretation;
  final String? sourceBlurb;
  final String? tone;
  final String? period;
  final double? sentimentScore;
  final int? intensity;
  final int? author_score;

  Quote({
    required this.id,
    required this.text,
    required this.authorName,
    this.authorBirth,
    this.authorDeath,
    this.source,
    this.work,
    this.year,
    required this.themes,
    required this.tags,
    this.context,
    this.notes,
    required this.status,
    this.interpretation,
    this.sourceBlurb,
    this.tone,
    this.period,
    this.sentimentScore,
    this.intensity,
    this.author_score,
  });

  factory Quote.fromJson(Map<String, dynamic> json) {
    final gptData = json['gpt'] as Map<String, dynamic>?;

    return Quote(
      id: json['id'],
      text: json['text'],
      authorName: json['author']['name'],
      authorBirth: json['author']['birth'],
      authorDeath: json['author']['death'],
      source: json['source'],
      work: json['work'],
      year: json['year'],
      themes: List<String>.from(json['themes'] ?? []),
      tags: List<String>.from(gptData?['tags'] ?? json['tags'] ?? []),
      context: json['context'],
      notes: json['notes'],
      status: json['status'],
      interpretation: gptData?['interpretation'],
      sourceBlurb: gptData?['source_blurb'],
      tone: gptData?['tone']?['label'],
      period: gptData?['period'],
      sentimentScore: (gptData?['sentiment_score'] as num?)?.toDouble(),
      intensity: (gptData?['tone']?['intensity'] as num?)?.toInt(),
      author_score: json['author_score'],
    );
  }

  // Helper method to get formatted author info
  String get authorInfo {
    String result = authorName;
    if (authorBirth != null) {
      result += ' (';
      result += authorBirth.toString();
      if (authorDeath != null) {
        result += '–${authorDeath}';
      } else {
        result += '–';
      }
      result += ')';
    }
    return result;
  }

  // Helper method to get source info for display
  String get displaySource {
    if (source != null && source!.isNotEmpty) {
      return source!;
    } else if (work != null && work!.isNotEmpty) {
      if (year != null) {
        return '$work ($year)';
      } else {
        return work!;
      }
    } else if (year != null) {
      return year.toString();
    }
    return '';
  }
}


===== post_onboarding_sequence.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/widgets/paywall.dart';
import 'package:quotes_app/utils/feature_gate.dart';
import 'dart:async';

class PostOnboardingSequence extends StatefulWidget {
  final VoidCallback onFinished;

  const PostOnboardingSequence({super.key, required this.onFinished});

  @override
  _PostOnboardingSequenceState createState() => _PostOnboardingSequenceState();
}

class _PostOnboardingSequenceState extends State<PostOnboardingSequence> {
  bool _isProcessing = true;
  int _currentStep =
      0; // 0: processing, 1: features, 2: paywall, 3: drawer guide

  @override
  void initState() {
    super.initState();
    _startProcessing();
  }

  void _startProcessing() {
    Timer(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          _isProcessing = false;
          _currentStep = 1;
        });
      }
    });
  }

  void _nextStep() {
    setState(() {
      _currentStep++;
    });
  }

  void _finish() {
    widget.onFinished();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 240, 234, 225),
      body: AnimatedSwitcher(
        duration: const Duration(milliseconds: 500),
        child: _buildCurrentStep(),
      ),
    );
  }

  Widget _buildCurrentStep() {
    if (_isProcessing) {
      return const ProcessingScreen();
    }

    switch (_currentStep) {
      case 1:
        return FeatureOverviewScreen(onFinished: _nextStep);
      case 2:
        return PaywallIntroScreen(onFinished: _nextStep);
      case 3:
        return DrawerGuideScreen(onFinished: _finish);
      default:
        return FeatureOverviewScreen(onFinished: _finish);
    }
  }
}

class ProcessingScreen extends StatefulWidget {
  const ProcessingScreen({super.key});

  @override
  _ProcessingScreenState createState() => _ProcessingScreenState();
}

class _ProcessingScreenState extends State<ProcessingScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 3),
    );
    _animation = CurvedAnimation(parent: _controller, curve: Curves.easeOut);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text(
            'Synthesizing your results...',
            style: TextStyle(
              fontSize: 22,
              fontFamily: 'EBGaramond',
              color: Colors.black87,
            ),
          ),
          const SizedBox(height: 24),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 48.0),
            child: AnimatedBuilder(
              animation: _animation,
              builder: (context, child) {
                return LinearProgressIndicator(
                  value: _animation.value,
                  backgroundColor: Colors.black.withOpacity(0.1),
                  valueColor: const AlwaysStoppedAnimation<Color>(Colors.black),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

class FeatureOverviewScreen extends StatelessWidget {
  final VoidCallback onFinished;

  const FeatureOverviewScreen({super.key, required this.onFinished});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(32.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Spacer(flex: 2),
          const Text(
            'You\'re all set!',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 32,
              fontFamily: 'EBGaramond',
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 24),
          _buildFeatureDescription(
            Icons.favorite_border,
            'Favorite quotes to build your collection and improve recommendations.',
          ),
          const SizedBox(height: 16),
          _buildFeatureDescription(
            Icons.explore_outlined,
            'Browse quotes by author, tags, or historical periods.',
          ),
          const SizedBox(height: 16),
          _buildFeatureDescription(
            Icons.school_outlined,
            'Learn your favorite quotes with our smart flashcard system.',
          ),
          const Spacer(flex: 3),
          ElevatedButton(
            onPressed: onFinished,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.black,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(30),
              ),
              padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 15),
            ),
            child: const Text(
              'Start Exploring',
              style: TextStyle(
                fontFamily: 'EBGaramond',
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFeatureDescription(IconData icon, String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Icon(icon, size: 28, color: Colors.black54),
          const SizedBox(width: 20),
          Expanded(
            child: Text(
              text,
              style: const TextStyle(
                fontSize: 18,
                fontFamily: 'EBGaramond',
                height: 1.5,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class PaywallIntroScreen extends StatelessWidget {
  final VoidCallback onFinished;

  const PaywallIntroScreen({super.key, required this.onFinished});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(32.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text(
            'Literature Bites is Free',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 28,
              fontFamily: 'EBGaramond',
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          const Text(
            'But it can be so much better.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 20,
              fontFamily: 'EBGaramond',
              color: Colors.black54,
            ),
          ),
          const SizedBox(height: 32),
          _buildProFeature(Icons.explore, 'Browse by Author & Period'),
          const SizedBox(height: 16),
          _buildProFeature(Icons.school, 'Unlimited Learn Sessions'),
          const SizedBox(height: 16),
          _buildProFeature(Icons.palette, 'Premium Themes & Fonts'),
          const SizedBox(height: 16),
          _buildProFeature(Icons.notifications, 'Custom Notifications'),
          const SizedBox(height: 48),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: onFinished,
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 15),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30),
                    ),
                  ),
                  child: const Text(
                    'Continue Free',
                    style: TextStyle(fontFamily: 'EBGaramond', fontSize: 16),
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  onPressed: () async {
                    // Show the full paywall
                    await openPaywall(
                      context: context,
                      contextKey: 'profile_upgrade',
                    );
                    // Continue regardless of paywall result
                    onFinished();
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.black,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(vertical: 15),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(30),
                    ),
                  ),
                  child: const Text(
                    'Upgrade Now',
                    style: TextStyle(
                      fontFamily: 'EBGaramond',
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildProFeature(IconData icon, String text) {
    return Row(
      children: [
        Icon(icon, size: 24, color: Colors.black54),
        const SizedBox(width: 16),
        Expanded(
          child: Text(
            text,
            style: const TextStyle(fontSize: 16, fontFamily: 'EBGaramond'),
          ),
        ),
      ],
    );
  }
}

class DrawerGuideScreen extends StatelessWidget {
  final VoidCallback onFinished;

  const DrawerGuideScreen({super.key, required this.onFinished});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black.withOpacity(0.8),
      body: Stack(
        children: [
          // Highlight the drawer area
          Positioned(
            top: 0,
            left: 0,
            bottom: 0,
            width: 80,
            child: Container(
              decoration: BoxDecoration(
                color: Colors.white,
                boxShadow: [
                  BoxShadow(
                    color: Colors.blue.withOpacity(0.5),
                    blurRadius: 20,
                    spreadRadius: 5,
                  ),
                ],
              ),
              child: const Center(
                child: Icon(Icons.menu, size: 32, color: Colors.black),
              ),
            ),
          ),

          // Guide text
          Positioned(
            top: MediaQuery.of(context).size.height * 0.2,
            left: 100,
            right: 32,
            child: Container(
              padding: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(16),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.2),
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text(
                    'Access Your Dashboard',
                    style: TextStyle(
                      fontSize: 20,
                      fontFamily: 'EBGaramond',
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 12),
                  const Text(
                    'Tap the menu button to access Browse, Learn, Favorites, and other useful features.',
                    style: TextStyle(
                      fontSize: 16,
                      fontFamily: 'EBGaramond',
                      height: 1.4,
                    ),
                  ),
                  const SizedBox(height: 20),
                  Align(
                    alignment: Alignment.centerRight,
                    child: ElevatedButton(
                      onPressed: onFinished,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.black,
                        foregroundColor: Colors.white,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(30),
                        ),
                      ),
                      child: const Text(
                        'Got it!',
                        style: TextStyle(
                          fontFamily: 'EBGaramond',
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== quiz_page.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quiz_models.dart';
import 'package:quotes_app/quiz_service.dart';
import 'package:quotes_app/quote.dart';
import 'srs_service.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:lottie/lottie.dart';

class QuizPage extends StatefulWidget {
  final List<Quote> favoriteQuotes;
  final List<Quote> allQuotes;
  final Map<String, int> viewCounts;

  const QuizPage({
    super.key,
    required this.favoriteQuotes,
    required this.allQuotes,
    required this.viewCounts,
  });

  @override
  State<QuizPage> createState() => _QuizPageState();
}

class _QuizPageState extends State<QuizPage> {
  late final QuizService _quizService;
  final SRSService _srsService = SRSService();

  List<QuizQuestion> _questions = [];
  int _currentQuestionIndex = 0;
  int _score = 0;
  bool _answered = false;
  String? _selectedAnswer;

  @override
  void initState() {
    super.initState();
    final sessionSeed = DateTime.now().millisecondsSinceEpoch;
    _quizService = QuizService(sessionSeed: sessionSeed);
    _startQuiz();
  }

  void _startQuiz() {
    setState(() {
      _questions = _quizService.generateQuiz(
        favoriteQuotes: widget.favoriteQuotes,
        allQuotes: widget.allQuotes,
        viewCounts: widget.viewCounts,
      );
      _currentQuestionIndex = 0;
      _score = 0;
      _answered = false;
      _selectedAnswer = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    bool isFinished = _currentQuestionIndex >= _questions.length;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Comprehensive Quiz',
          style: TextStyle(
            fontFamily: 'Georgia',
            color: Theme.of(context).primaryColor,
          ),
        ),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: _questions.isEmpty
          ? Center(
              child: Padding(
                padding: const EdgeInsets.all(32.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.favorite_border,
                      size: 64,
                      color: Theme.of(context).primaryColor.withOpacity(0.5),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'You need to favorite some quotes to start a quiz!',
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        fontFamily: 'Georgia',
                        fontSize: 18,
                        color: Theme.of(context).primaryColor.withOpacity(0.8),
                      ),
                    ),
                  ],
                ),
              ),
            )
          : (isFinished ? _buildResultsUI() : _buildQuizUI()),
    );
  }

  Widget _buildResultsUI() {
    final double percentage = _questions.isNotEmpty
        ? (_score / _questions.length) * 100
        : 0;
    return Center(
      child: Stack(
        children: [
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Quiz Complete!',
                style: TextStyle(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  fontFamily: 'Georgia',
                  color: Theme.of(context).primaryColor,
                ),
              ),
              const SizedBox(height: 24),
              Text(
                'Your Score',
                style: TextStyle(
                  fontSize: 20,
                  fontFamily: 'Georgia',
                  color: Theme.of(context).primaryColor.withOpacity(0.7),
                ),
              ),
              Text(
                '$_score / ${_questions.length}',
                style: TextStyle(
                  fontSize: 48,
                  fontWeight: FontWeight.bold,
                  fontFamily: 'Georgia',
                  color: Theme.of(context).primaryColor,
                ),
              ),
              Text(
                '${percentage.toStringAsFixed(1)}%',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.w600,
                  fontFamily: 'Georgia',
                  color: Theme.of(context).colorScheme.primary,
                ),
              ),
              const SizedBox(height: 48),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Theme.of(context).primaryColor,
                  foregroundColor: Theme.of(context).scaffoldBackgroundColor,
                  minimumSize: const Size(200, 50),
                  textStyle: const TextStyle(
                    fontSize: 16,
                    fontFamily: 'Georgia',
                  ),
                ),
                onPressed: _startQuiz,
                child: const Text('Retake Quiz'),
              ),
              const SizedBox(height: 16),
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: Text(
                  'Back to Learn Hub',
                  style: TextStyle(
                    color: Theme.of(context).primaryColor.withOpacity(0.7),
                    fontFamily: 'Georgia',
                  ),
                ),
              ),
            ],
          ),
          if (percentage > 80)
            Align(
              alignment: Alignment.center,
              child: Lottie.asset('assets/confetti.json', repeat: false),
            ),
        ],
      ),
    );
  }

  Widget _buildQuizUI() {
    final question = _questions[_currentQuestionIndex];
    final isDark = Theme.of(context).brightness == Brightness.dark;

    return Column(
      children: [
        // Progress Bar
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              LinearProgressIndicator(
                value: (_currentQuestionIndex + 1) / _questions.length,
                backgroundColor: Theme.of(
                  context,
                ).colorScheme.surface.withOpacity(0.5),
                valueColor: AlwaysStoppedAnimation<Color>(
                  Theme.of(context).colorScheme.primary,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Question ${_currentQuestionIndex + 1} of ${_questions.length}  |  Score: $_score',
                style: TextStyle(
                  fontFamily: 'Georgia',
                  color: Theme.of(context).primaryColor.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Quote Text
        if (question.quoteText != null)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(20),
            margin: const EdgeInsets.all(24.0),
            decoration: BoxDecoration(
              color: isDark
                  ? Colors.white.withOpacity(0.1)
                  : Colors.black.withOpacity(0.05),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              '"${question.quoteText}"',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 20,
                fontFamily: 'Georgia',
                fontStyle: FontStyle.italic,
                color: Theme.of(context).primaryColor,
              ),
            ),
          ),

        // Question
        Padding(
          padding: EdgeInsets.symmetric(
            horizontal: 24.0,
            vertical: question.quoteText == null ? 24.0 : 16.0,
          ),
          child: Text(
            question.questionText,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 18,
              fontFamily: 'Georgia',
              fontWeight: FontWeight.bold,
              color: Theme.of(context).primaryColor.withOpacity(0.9),
            ),
          ),
        ),

        // Options
        Expanded(
          child: ListView.builder(
            itemCount: question.options.length,
            itemBuilder: (context, index) {
              final option = question.options[index];
              Color? tileColor;
              IconData? icon;
              if (_answered) {
                if (option == question.correctAnswer) {
                  tileColor = Theme.of(
                    context,
                  ).colorScheme.primary.withOpacity(0.2);
                  icon = Icons.check_circle;
                } else if (option == _selectedAnswer) {
                  tileColor = Theme.of(
                    context,
                  ).colorScheme.error.withOpacity(0.2);
                  icon = Icons.cancel;
                }
              }
              return Card(
                elevation: _answered ? 0 : 1,
                margin: const EdgeInsets.symmetric(
                  vertical: 6.0,
                  horizontal: 16.0,
                ),
                color: tileColor ?? (isDark ? Colors.grey[850] : Colors.white),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                  side: BorderSide(
                    color: _answered && option == question.correctAnswer
                        ? Theme.of(context).colorScheme.primary
                        : Colors.transparent,
                    width: 1,
                  ),
                ),
                child: ListTile(
                  title: Text(
                    option,
                    style: TextStyle(
                      fontFamily: 'Georgia',
                      color: Theme.of(context).primaryColor,
                    ),
                  ),
                  trailing: icon != null
                      ? Icon(
                          icon,
                          color: option == question.correctAnswer
                              ? Theme.of(context).colorScheme.primary
                              : Theme.of(context).colorScheme.error,
                        )
                      : null,
                  onTap: () => _handleAnswer(option),
                ),
              );
            },
          ),
        ),
        if (_answered)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Theme.of(context).colorScheme.onBackground,
                foregroundColor: Theme.of(context).colorScheme.background,
                minimumSize: const Size(double.infinity, 50),
              ),
              onPressed: _nextQuestion,
              child: Text(
                _currentQuestionIndex < _questions.length - 1
                    ? 'Next Question'
                    : 'Finish Quiz',
                style: const TextStyle(fontSize: 16, fontFamily: 'Georgia'),
              ),
            ),
          ),
      ],
    );
  }

  void _handleAnswer(String answer) {
    if (_answered) return;

    final question = _questions[_currentQuestionIndex];
    final isCorrect = answer == question.correctAnswer;

    setState(() {
      _selectedAnswer = answer;
      _answered = true;
      if (isCorrect) {
        _score++;
      }
      _srsService.grade(
        question.quote.id,
        correct: isCorrect,
        today: DateTime.now(),
      );
    });
  }

  void _nextQuestion() {
    setState(() {
      if (_currentQuestionIndex < _questions.length - 1) {
        _currentQuestionIndex++;
        _answered = false;
        _selectedAnswer = null;
      } else {
        // Show results page
        setState(() {
          // A bit of a hack to signal the UI to switch
          _currentQuestionIndex++;
          if (_currentQuestionIndex >= _questions.length) {
            _saveQuizResult();
          }
        });
      }
    });
  }

  Future<void> _saveQuizResult() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(
      'quizzesCompleted',
      (prefs.getInt('quizzesCompleted') ?? 0) + 1,
    );
    await prefs.setInt(
      'totalCorrectAnswers',
      (prefs.getInt('totalCorrectAnswers') ?? 0) + _score,
    );
    await prefs.setInt(
      'totalQuestionsAnswered',
      (prefs.getInt('totalQuestionsAnswered') ?? 0) + _questions.length,
    );
  }
}


===== quiz_service.dart =====

import 'dart:math';
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/quiz_models.dart';

class QuizService {
  late final Random _random;

  QuizService({int? sessionSeed}) {
    _random = Random(sessionSeed);
  }

  List<QuizQuestion> generateQuiz({
    required List<Quote> favoriteQuotes,
    required List<Quote> allQuotes,
    int numberOfQuestions = 20,
    Map<String, int> viewCounts = const {},
  }) {
    if (favoriteQuotes.isEmpty) return [];

    // Prioritize quotes that have been seen but not excessively
    final scoredQuotes = favoriteQuotes.map((quote) {
      final views = viewCounts[quote.id] ?? 0;
      // Simple scoring: higher score for fewer views (inverted)
      // Add a small constant to avoid division by zero and handle un-viewed quotes
      final score = 1.0 / (1.0 + views);
      return MapEntry(quote, score);
    }).toList();

    // Sort by score descending to prioritize less-viewed quotes
    scoredQuotes.sort((a, b) => b.value.compareTo(a.value));

    final List<QuizQuestion> questions = [];
    final List<Quote> potentialQuotes = scoredQuotes.map((e) => e.key).toList();

    while (questions.length < numberOfQuestions && potentialQuotes.isNotEmpty) {
      // Take from the top of the prioritized list
      final quote = potentialQuotes.removeAt(0);

      final quizType = _determineQuizType(quote);
      final question = _prepareQuizData(
        quizType,
        quote,
        allQuotes,
        favoriteQuotes,
      );
      if (question != null) {
        questions.add(question);
      }
      if (potentialQuotes.isEmpty && questions.length < numberOfQuestions) {
        // If we run out of unique quotes, allow repeats by reshuffling the original scored list
        final a = List<Quote>.from(favoriteQuotes)..shuffle(_random);
        potentialQuotes.addAll(a);
      }
    }
    return questions;
  }

  QuizType _determineQuizType(Quote quote) {
    final availableTypes = _getAvailableQuizTypesForQuote(quote);
    return availableTypes[_random.nextInt(availableTypes.length)];
  }

  List<QuizType> _getAvailableQuizTypesForQuote(Quote quote) {
    final availableTypes = [QuizType.whoSaidThis];
    if (quote.displaySource.isNotEmpty) {
      availableTypes.add(QuizType.whatSource);
    }
    if (quote.authorBirth != null) {
      availableTypes.add(QuizType.authorPeriod);
    }
    return availableTypes;
  }

  QuizQuestion? generateSingleQuestion({
    required List<Quote> fromQuotes,
    required List<Quote> allQuotes,
    required List<QuizType> allowedTypes,
  }) {
    if (fromQuotes.isEmpty) return null;

    final shuffledQuotes = List<Quote>.from(fromQuotes)..shuffle(_random);

    for (final quote in shuffledQuotes) {
      final availableTypes = _getAvailableQuizTypesForQuote(quote);
      final possibleTypes = availableTypes
          .where((t) => allowedTypes.contains(t))
          .toList();

      if (possibleTypes.isNotEmpty) {
        final quizType = possibleTypes[_random.nextInt(possibleTypes.length)];
        final question = _prepareQuizData(
          quizType,
          quote,
          allQuotes,
          fromQuotes,
        );
        if (question != null && question.options.length > 1) {
          return question;
        }
      }
    }
    return null; // No suitable question found
  }

  QuizQuestion? _prepareQuizData(
    QuizType quizType,
    Quote quote,
    List<Quote> allQuotes,
    List<Quote> favoriteQuotes,
  ) {
    String questionText;
    String correctAnswer;
    List<String> options;
    String? quoteText;

    switch (quizType) {
      case QuizType.whoSaidThis:
        quoteText = quote.text;
        questionText = 'Who said this?';
        correctAnswer = quote.authorInfo;
        final allAuthors = allQuotes.map((q) => q.authorInfo).toSet().toList();
        options = _generateOptions(correctAnswer, allAuthors);
        break;
      case QuizType.whatSource:
        quoteText = quote.text;
        questionText = 'What is the source of this quote?';
        correctAnswer = quote.displaySource;
        final allSources = allQuotes
            .map((q) => q.displaySource)
            .where((s) => s.isNotEmpty)
            .toSet()
            .toList();
        options = _generateOptions(correctAnswer, allSources);
        break;
      case QuizType.authorPeriod:
        questionText = 'In what period did ${quote.authorName} live?';
        correctAnswer = '${quote.authorBirth}–${quote.authorDeath}';
        options = _generateAuthorPeriodOptions(correctAnswer);
        break;
      default:
        return null;
    }
    if (options.length < 2) return null; // Not enough options to make a quiz

    return QuizQuestion(
      quote: quote,
      quizType: quizType,
      questionText: questionText,
      options: options,
      correctAnswer: correctAnswer,
      quoteText: quoteText,
    );
  }

  List<String> _generateOptions(String correctAnswer, List<String> allItems) {
    final options = <String>{correctAnswer};
    allItems.shuffle(_random);
    for (final item in allItems) {
      if (item != correctAnswer) {
        options.add(item);
        if (options.length >= 4) break;
      }
    }
    return options.toList()..shuffle(_random);
  }

  List<String> _generateAuthorPeriodOptions(String correctPeriod) {
    final options = <String>{correctPeriod};
    final correctYear = int.parse(correctPeriod.split('–')[0]);
    while (options.length < 4) {
      final randomOffset = _random.nextInt(100) - 50;
      final startYear = correctYear + randomOffset;
      final endYear = startYear + (_random.nextInt(40) + 40);
      final period = '$startYear–$endYear';
      if (period != correctPeriod) options.add(period);
    }
    return options.toList()..shuffle(_random);
  }
}


===== quote_app.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:quotes_app/recommendation_service.dart';
import 'package:flutter/rendering.dart';
import 'onboarding_page.dart';
import 'post_onboarding_sequence.dart';
import 'info_card.dart';
import 'services/notification_service.dart';
import 'services/streak_service.dart';
import 'widgets/streak_island.dart';
import 'widgets/milestone_celebration.dart';
import 'widgets/quote_card.dart';
import 'widgets/details_card.dart';
import 'widgets/bottom_action_bar.dart';
import 'widgets/details_popup.dart';
import 'widgets/tag_chip.dart';
import 'widgets/author_chip.dart';
import 'utils/share_quote.dart';
import 'models/period_catalog.dart';
import 'utils/system_ui.dart';
import 'widgets/active_filters_bar.dart';
import 'widgets/settings_sheet.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/widgets/reward_island.dart';
import 'package:quotes_app/widgets/tip_island.dart';
import 'quote.dart';
import 'quote_service.dart';
import 'browse_hub.dart';
import 'utils/feature_gate.dart';
import 'about.dart';
import 'learn_hub.dart';
import 'profile_rewards_page.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'srs_service.dart';
import 'package:quotes_app/services/purchase_service.dart';
import 'package:quotes_app/services/revenuecat_keys.dart';

class _InfoCardModel {
  final String id;
  const _InfoCardModel({required this.id});
}

class QuoteApp extends StatefulWidget {
  final String? quoteId;
  const QuoteApp({super.key, this.quoteId});

  @override
  QuoteAppState createState() => QuoteAppState();
}

class QuoteAppState extends State<QuoteApp>
    with TickerProviderStateMixin, WidgetsBindingObserver {
  int _currentIndex = 0;
  late PageController _pageController;
  final SRSService _srsService = SRSService();
  late ScrollController _detailsScrollController;
  late AnimationController _heartAnimationController;
  late Animation<double> _heartAnimation;

  Map<String, dynamic>? _streakIslandData;
  String? _celebrationType; // 'confetti' or 'fireworks'
  String? _awardedFeatureKey;
  String? _activeTip;

  List<Quote> _quotes = [];
  List<Quote> _allQuotes = [];
  final List<Quote> _favoriteQuotes = [];
  final Set<String> _selectedTags = <String>{};
  final Set<String> _seenQuoteIds = <String>{};
  final Map<String, int> _likeCounts = <String, int>{};
  final Map<String, int> _viewCounts = <String, int>{};
  final Set<String> _preferredAuthors = <String>{};
  final Set<String> _preferredTags = <String>{};
  final Set<String> _selectedAuthors = <String>{};
  Map<String, dynamic>? _periodFilter;
  bool _isFavoritesMode = false;
  bool _isPersonalizedMode = true;
  bool _isLoading = true;
  bool _isSecondPageVisible = false;
  final Set<String> _infoCardIds = <String>{};

  List<dynamic> _pageViewItems = [];
  bool _showDetailsIsland = false;

  bool _hasExploredLearn = false;
  bool _hasExploredBrowse = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _pageController = PageController();
    _detailsScrollController = ScrollController();
    _heartAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _heartAnimation = CurvedAnimation(
      parent: _heartAnimationController,
      curve: Curves.elasticOut,
    );

    _heartAnimationController.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        Future.delayed(const Duration(milliseconds: 500), () {
          if (mounted) {
            _heartAnimationController.reverse();
          }
        });
      }
    });
    _loadQuotes();
    _handleAppLaunch();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      EntitlementsService.instance.clearExpiredPasses().then((_) {
        // A simple way to refresh any UI that depends on entitlements
        setState(() {});
      });

      // Sync notifications with current preferences
      _syncNotifications();
      // Sync entitlements from RevenueCat whenever app resumes
      PurchaseService.instance.syncEntitlementFromRC().then((_) {
        if (mounted) {
          setState(() {});
        }
      });
    }
  }

  Future<void> _syncNotifications() async {
    final prefs = await NotificationService.loadNotificationPrefs();
    await NotificationService.syncWithPrefs(
      prefs,
      DateTime.now(),
      feed: _allQuotes,
      favoriteQuotes: _favoriteQuotes,
    );
  }

  Future<void> _handleAppLaunch() async {
    final result = await StreakService.instance.recordAppLaunch();
    final isNewEngagement = result['isNewEngagement'] as bool;

    if (isNewEngagement) {
      final streakCount = result['streakCount'] as int;
      final celebrationType = result['celebrationType'] as String?;
      final awardedFeatureKeys = (result['awardedFeatureKeys'] as List)
          .cast<String>();
      final weeklyView =
          (result['weeklyView'] as List?)?.cast<Map<String, dynamic>>() ?? [];

      setState(() {
        _streakIslandData = {
          'message': '$streakCount Day Streak!',
          'weeklyView': weeklyView,
        };
        _celebrationType = celebrationType;
      });

      // Show celebration overlay if applicable
      if (celebrationType != null) {
        Future.delayed(const Duration(milliseconds: 1000), () {
          if (mounted) {
            _showCelebrationOverlay(awardedFeatureKeys);
          }
        });
      }
    } else {
      // For existing engagements, we don't need to show the island,
      // but you might want to update the view if the app has been open overnight.
      // This part of the logic can be decided based on desired app behavior.
    }
  }

  void _showCelebrationOverlay(List<String> awardedFeatureKeys) {
    if (_celebrationType == null) return;

    setState(() {
      // The overlay will be shown in the UI build method
    });

    // Auto-hide after 3 seconds
    Future.delayed(const Duration(milliseconds: 3000), () {
      if (mounted) {
        setState(() {
          _celebrationType = null;
        });
        // After celebration, if there are awards, show the award sheet.
        if (awardedFeatureKeys.isNotEmpty) {
          setState(() {
            _awardedFeatureKey = awardedFeatureKeys.first;
          });
        }
      }
    });
  }

  // Removed unused _showAwardSheet; reward surfaces via RewardIsland

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _pageController.dispose();
    _detailsScrollController.dispose();
    _heartAnimationController.dispose();
    super.dispose();
  }

  Future<void> _loadQuotes() async {
    try {
      final quotes = await QuoteService.loadQuotes();
      final prefs = await SharedPreferences.getInstance();
      final favoriteIds = prefs.getStringList('favoriteQuoteIds') ?? [];
      final likeCountsJson = prefs.getString('likeCounts');
      if (likeCountsJson != null) {
        final decodedMap = json.decode(likeCountsJson) as Map<String, dynamic>;
        _likeCounts.addAll(
          decodedMap.map((key, value) => MapEntry(key, value as int)),
        );
      }
      final viewCountsJson = prefs.getString('viewCounts');
      if (viewCountsJson != null) {
        final decodedMap = json.decode(viewCountsJson) as Map<String, dynamic>;
        _viewCounts.addAll(
          decodedMap.map((key, value) => MapEntry(key, value as int)),
        );
      }

      _isPersonalizedMode = prefs.getBool('personalizedSuggestions') ?? true;
      final seenInfoCardIds = prefs.getStringList('infoCardIds') ?? [];
      _infoCardIds.addAll(seenInfoCardIds);
      final seenQuoteIds = prefs.getStringList('seenQuoteIds') ?? [];
      _seenQuoteIds.addAll(seenQuoteIds);

      // RevenueCat already configured in main.dart, just sync in background
      Future(() async {
        await PurchaseService.instance.syncEntitlementFromRC();
        if (mounted) {
          setState(() {});
        }
      });

      setState(() {
        _allQuotes = quotes;
        _quotes = List.from(quotes)..shuffle();
        _favoriteQuotes.addAll(
          _allQuotes.where((q) => favoriteIds.contains(q.id)),
        );
        _isLoading = false;
      });
      _applyFilters();
      if (widget.quoteId != null) {
        final index = _quotes.indexWhere((q) => q.id == widget.quoteId);
        if (index != -1) {
          // Use a post-frame callback to ensure the PageView is built
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (_pageController.hasClients) {
              _pageController.jumpToPage(index);
              _showSecondPage();
            }
          });
        }
      }
      NotificationService.scheduleForToday(
        feed: _quotes,
        favoriteQuotes: _favoriteQuotes,
        now: DateTime.now(),
      );
      await _showOnboardingIfNeeded();
    } catch (e) {
      setState(() {
        _isLoading = false;
      });
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Error loading quotes: $e')));
      }
    }
  }

  Future<void> _showOnboardingIfNeeded() async {
    final prefs = await SharedPreferences.getInstance();
    final bool hasOnboarded = prefs.getBool('hasOnboarded') ?? false;

    if (!hasOnboarded && mounted) {
      final result = await Navigator.of(context).push<OnboardingResult>(
        MaterialPageRoute(
          builder: (context) => OnboardingPage(allQuotes: _allQuotes),
          fullscreenDialog: true,
        ),
      );

      if (result != null) {
        // Show the post-onboarding sequence
        await Navigator.of(context).push(
          MaterialPageRoute(
            builder: (context) => PostOnboardingSequence(
              onFinished: () {
                Navigator.of(context).pop();
              },
            ),
            fullscreenDialog: true,
          ),
        );

        setState(() {
          if (result.selectedTags.isNotEmpty) {
            _preferredTags.addAll(result.selectedTags);
          }
          if (result.selectedAuthors.isNotEmpty) {
            _preferredAuthors.addAll(result.selectedAuthors);
          }
        });
        // Re-apply filters to kick-start recommendations with new preferences
        _applyFilters();
      }

      // After onboarding is complete, set the flag
      await prefs.setBool('hasOnboarded', true);
    }
  }

  void _showSecondPage() {
    if (_detailsScrollController.hasClients) {
      _detailsScrollController.jumpTo(0);
    }
    setState(() {
      _isSecondPageVisible = true;
    });
  }

  void _hideSecondPage() {
    setState(() {
      _isSecondPageVisible = false;
    });
  }

  void _nextQuote() {
    if (_quotes.isNotEmpty) {
      _pageController.nextPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  void _previousQuote() {
    if (_quotes.isNotEmpty) {
      _pageController.previousPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  void _toggleFavorite() {
    if (_quotes.isEmpty) return;
    HapticFeedback.lightImpact();
    final currentQuote = _quotes[_currentIndex];

    _heartAnimationController.forward(from: 0.0);

    setState(() {
      if (!_favoriteQuotes.contains(currentQuote)) {
        _favoriteQuotes.add(currentQuote);
        _srsService.addQuote(currentQuote.id);
      }
      _likeCounts.update(
        currentQuote.id,
        (value) => value + 1,
        ifAbsent: () => 1,
      );
      _saveFavorites();
    });
  }

  Future<void> _saveFavorites() async {
    final prefs = await SharedPreferences.getInstance();
    final favoriteIds = _favoriteQuotes.map((q) => q.id).toList();
    await prefs.setStringList('favoriteQuoteIds', favoriteIds);
    await prefs.setString('likeCounts', json.encode(_likeCounts));
    await prefs.setStringList('seenQuoteIds', _seenQuoteIds.toList());
  }

  Future<void> _saveViewCounts() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('viewCounts', json.encode(_viewCounts));
  }

  void _toggleFavoriteFromBar() {
    if (_quotes.isEmpty) return;
    HapticFeedback.lightImpact();
    final currentQuote = _quotes[_currentIndex];

    setState(() {
      if (_favoriteQuotes.contains(currentQuote)) {
        _favoriteQuotes.remove(currentQuote);
        _srsService.removeQuote(currentQuote.id);
        _heartAnimationController.reset();
      } else {
        _favoriteQuotes.add(currentQuote);
        _likeCounts[currentQuote.id] = (_likeCounts[currentQuote.id] ?? 0) + 1;
        _srsService.addQuote(currentQuote.id);
        _heartAnimationController.forward(from: 0.0);
      }
      _saveFavorites();
    });
  }

  Widget _buildQuoteCard(Quote quote) {
    return QuoteCard(
      quote: quote,
      onDoubleTap: _toggleFavorite,
      onReadMore: _showSecondPage,
      heartAnimation: _heartAnimation,
    );
  }

  Widget _buildTagChip(String tag, {void Function(String)? onTap}) {
    final bool isSelected = _selectedTags.contains(tag);

    return TagChip(
      tag: tag,
      isSelected: isSelected,
      onTap: (selectedTag) {
        if (onTap != null) {
          onTap(tag);
        } else {
          _toggleTagFilter(tag);
        }
      },
    );
  }

  void _toggleTagFilter(String tag) {
    setState(() {
      if (_selectedTags.contains(tag)) {
        _selectedTags.remove(tag);
      } else {
        _selectedTags.add(tag);
      }
      _isFavoritesMode = false;
    });
    _applyFilters();
  }

  void _toggleAuthorFilter(String authorName) {
    setState(() {
      if (_selectedAuthors.contains(authorName)) {
        _selectedAuthors.remove(authorName);
      } else {
        _selectedAuthors.add(authorName);
      }
      _isFavoritesMode = false;
    });
    _applyFilters();
  }

  void _clearFilter() {
    setState(() {
      _selectedTags.clear();
      _selectedAuthors.clear();
      _periodFilter = null;
      _isFavoritesMode = false;
    });
    _applyFilters();
  }

  void _applyTagFilter(Set<String> selectedTags) {
    setState(() {
      _selectedTags.clear();
      _selectedTags.addAll(selectedTags);
      _isFavoritesMode = false;
    });
    _applyFilters();
  }

  void _applyAuthorFilter(Set<String> selectedAuthors) {
    setState(() {
      _selectedAuthors.clear();
      _selectedAuthors.addAll(selectedAuthors);
      _isFavoritesMode = false;
    });
    _applyFilters();
  }

  void _applyPeriodFilter(Map<String, dynamic> periodFilter) {
    setState(() {
      _periodFilter = periodFilter;
      _selectedAuthors.clear();
      // Don't add selected authors to _selectedAuthors to avoid showing them in active filters
      // The period filter logic will handle author filtering internally
      _isFavoritesMode = false;
    });
    _applyFilters();
  }

  void _toggleFavoritesFilter() {
    setState(() {
      _isFavoritesMode = !_isFavoritesMode;
      if (_isFavoritesMode) {
        _selectedTags.clear();
        _selectedAuthors.clear();
      }
    });
    _applyFilters();
  }

  void _applyFilters() {
    setState(() {
      final sessionSeed = DateTime.now().millisecondsSinceEpoch;
      List<Quote> baseQuotes;
      if (_isFavoritesMode) {
        baseQuotes = _favoriteQuotes;
      } else {
        baseQuotes = _allQuotes;
      }

      final totalViews = _viewCounts.values.fold(
        0,
        (sum, count) => sum + count,
      );

      List<Quote> filteredQuotes;
      if (_isPersonalizedMode && _selectedTags.isEmpty && !_isFavoritesMode) {
        final recommendationService = RecommendationService(
          allQuotes: _allQuotes,
          favoriteQuotes: _favoriteQuotes,
          likeCounts: _likeCounts,
          viewCounts: _viewCounts,
          totalViews: totalViews,
          preferredAuthors: _preferredAuthors,
          preferredTags: _preferredTags,
          sessionSeed: sessionSeed,
        );
        filteredQuotes = recommendationService.getRecommendations();
      } else if (_selectedTags.isEmpty) {
        filteredQuotes = List.from(baseQuotes);
        // Reverse favorites to show most recently favorited first
        if (_isFavoritesMode) {
          filteredQuotes = filteredQuotes.reversed.toList();
        }
      } else {
        filteredQuotes = baseQuotes.where((quote) {
          return _selectedTags.every(
            (selectedTag) => quote.tags.contains(selectedTag),
          );
        }).toList();
        // Reverse favorites to show most recently favorited first
        if (_isFavoritesMode) {
          filteredQuotes = filteredQuotes.reversed.toList();
        }
      }

      if (_selectedAuthors.isNotEmpty) {
        filteredQuotes = filteredQuotes
            .where((quote) => _selectedAuthors.contains(quote.authorName))
            .toList();
        // Reverse favorites to show most recently favorited first
        if (_isFavoritesMode) {
          filteredQuotes = filteredQuotes.reversed.toList();
        }
      }

      // Apply period filter if set
      if (_periodFilter != null) {
        final startYear = _periodFilter!['start_year'] as int;
        final endYear = _periodFilter!['end_year'] as int;
        filteredQuotes = PeriodCatalog.getQuotesForRange(
          filteredQuotes,
          startYear,
          endYear,
        );

        // Apply selected authors from period filter
        final selectedAuthors = _periodFilter!['selected_authors'];
        if (selectedAuthors is Set<String> && selectedAuthors.isNotEmpty) {
          filteredQuotes = filteredQuotes
              .where((quote) => selectedAuthors.contains(quote.authorName))
              .toList();
        } else if (selectedAuthors is Iterable && selectedAuthors.isNotEmpty) {
          final authorSet = selectedAuthors.cast<String>().toSet();
          filteredQuotes = filteredQuotes
              .where((quote) => authorSet.contains(quote.authorName))
              .toList();
        }
      }

      if (!_isFavoritesMode && !_isPersonalizedMode) {
        filteredQuotes.shuffle();
      }

      _quotes = filteredQuotes;
      _pageViewItems = List.from(_quotes);
      _currentIndex = 0;
      _isSecondPageVisible = false;
    });

    if (_pageController.hasClients) {
      _pageController.jumpToPage(0);
    }
  }

  Future<void> _shareQuoteAsImage() async {
    await shareQuoteAsImage(
      context,
      _quotes[_currentIndex],
      Theme.of(context).brightness == Brightness.dark,
    );
  }

  void _navigateToProfile() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const ProfileRewardsPage()),
    );
  }

  void _navigateToLearn() {
    if (_favoriteQuotes.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('You have no favorites to learn from yet!'),
          duration: Duration(seconds: 2),
          backgroundColor: Colors.redAccent,
        ),
      );
    } else {
      setState(() {
        _hasExploredLearn = true;
      });
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => LearnHubPage(
            allQuotes: _allQuotes,
            favoriteQuotes: _favoriteQuotes,
            viewCounts: _viewCounts,
            likeCounts: _likeCounts,
          ),
        ),
      );
    }
  }

  void _navigateToBrowse() async {
    setState(() {
      _hasExploredBrowse = true;
    });
    final result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => BrowseHubPage(
          allQuotes: _allQuotes,
          favoriteQuotes: _favoriteQuotes,
          viewCounts: _viewCounts,
          initialSelectedTags: _selectedTags,
          initialSelectedAuthors: _selectedAuthors,
        ),
      ),
    );
    if (!mounted) return;
    if (result is Map) {
      // Handle different filter types returned from BrowseHubPage
      if (result.containsKey('tags')) {
        final tags = result['tags'];
        if (tags is Set<String>) _applyTagFilter(tags);
      } else if (result.containsKey('authors')) {
        final authors = result['authors'];
        if (authors is Set<String>) _applyAuthorFilter(authors);
      } else if (result.containsKey('period_filter') &&
          result['period_filter'] != null) {
        final pf = result['period_filter'];
        if (pf is Map) {
          _applyPeriodFilter(pf.cast<String, dynamic>());
        }
      } else if (result.containsKey('favorites')) {
        _toggleFavoritesFilter();
      }
    }
  }

  void _navigateToAbout() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => AboutPage()),
    );
  }

  void _showDetailsPopup(BuildContext anchorContext) {
    setState(() {
      _showDetailsIsland = true;
    });
  }

  Widget _buildAuthorChip(String authorName, {void Function(String)? onTap}) {
    final bool isSelected = _selectedAuthors.contains(authorName);

    return AuthorChip(
      authorName: authorName,
      isSelected: isSelected,
      onTap: (selectedAuthor) {
        if (onTap != null) {
          onTap(authorName);
        } else {
          // Gate author filtering for non-Pro users
          requireFeature(
            context,
            EntitlementsService.browseAuthor,
            onAllowed: () {
              _toggleAuthorFilter(authorName);
            },
            onBlocked: () {
              openPaywall(context: context, contextKey: 'browse_author');
            },
          );
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    // Sync the system status bar with our app bar background to avoid the lavender tint on iOS
    setSystemUIOverlayStyle(Theme.of(context).brightness == Brightness.dark);

    if (_isLoading) {
      return Scaffold(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    if (_quotes.isEmpty) {
      final message = _isFavoritesMode
          ? 'You have no favorites yet.\nTap the heart on a quote to add it.'
          : (_allQuotes.isEmpty
                ? 'No quotes available.'
                : 'No quotes found for the selected filters.');

      return Scaffold(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        appBar: AppBar(
          title: Text(
            '',
            style: Theme.of(context).textTheme.titleLarge?.copyWith(
              color: Theme.of(context).primaryColor,
            ),
          ),
          backgroundColor: Theme.of(context).scaffoldBackgroundColor,
          elevation: 0,
          scrolledUnderElevation: 0.0,
          iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
        ),
        drawer: _buildDrawer(context),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 32.0),
            child: Text(
              message,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                fontSize: 18,
                color: Theme.of(context).primaryColor,
              ),
            ),
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: Stack(
        children: [
          // Main content area
          Column(
            children: [
              // Main content area
              Expanded(
                child: IndexedStack(
                  index: _isSecondPageVisible ? 1 : 0,
                  children: <Widget>[
                    PageView.builder(
                      controller: _pageController,
                      scrollDirection: Axis.vertical,
                      onPageChanged: (index) {
                        if (_quotes.isNotEmpty) {
                          final item = _pageViewItems[index];
                          if (item is Quote) {
                            final quoteId = item.id;
                            _viewCounts.update(
                              quoteId,
                              (value) => value + 1,
                              ifAbsent: () => 1,
                            );
                            _saveViewCounts();
                            setState(() {
                              _currentIndex = _quotes.indexOf(item);
                              if (!_seenQuoteIds.contains(quoteId)) {
                                _seenQuoteIds.add(quoteId);
                                _updatePageViewItems();
                                _checkForTips();
                              }
                            });
                          }
                        }
                      },
                      itemBuilder: (context, index) {
                        // Safety check to prevent empty cards
                        if (index >= _pageViewItems.length ||
                            _pageViewItems.isEmpty) {
                          // If we have quotes but pageViewItems is misaligned, rebuild it
                          if (_quotes.isNotEmpty && _pageViewItems.isEmpty) {
                            WidgetsBinding.instance.addPostFrameCallback((_) {
                              if (mounted) {
                                setState(() {
                                  _pageViewItems = List.from(_quotes);
                                });
                              }
                            });
                          }
                          return const SizedBox.shrink(); // Better than empty Container
                        }

                        final item = _pageViewItems[index];
                        if (item is Quote) {
                          return _buildQuoteCard(item);
                        } else if (item is _InfoCardModel) {
                          return _buildInfoCard();
                        }

                        // Log unexpected items to help debug
                        debugPrint(
                          'Warning: Unexpected item type in _pageViewItems: ${item.runtimeType}',
                        );
                        return const SizedBox.shrink();
                      },
                      itemCount: _pageViewItems.length,
                    ),
                    GestureDetector(
                      onDoubleTap: () {
                        HapticFeedback.lightImpact();
                        _toggleFavorite();
                      },
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          DetailsCard(
                            quote:
                                _quotes.isNotEmpty &&
                                    _currentIndex < _quotes.length
                                ? _quotes[_currentIndex]
                                : Quote(
                                    id: 'loading',
                                    text: 'Loading...',
                                    authorName: '',
                                    themes: [],
                                    tags: [],
                                    status: 'loading',
                                  ),
                            onHide: _hideSecondPage,
                            buildTagChip: _buildTagChip,
                            controller: _detailsScrollController,
                          ),
                          FadeTransition(
                            opacity: _heartAnimation,
                            child: ScaleTransition(
                              scale: _heartAnimation,
                              child: Icon(
                                Icons.favorite,
                                size: 120,
                                color: Colors.red.withOpacity(0.8),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),

              // Active Filters Bar
              ActiveFiltersBar(
                selectedTags: _selectedTags,
                selectedAuthors: _selectedAuthors,
                periodFilter: _periodFilter,
                isFavoritesMode: _isFavoritesMode,
                onClear: _clearFilter,
              ),

              // Bottom navigation bar
              if (_quotes.isNotEmpty && _currentIndex < _quotes.length)
                BottomActionBar(
                  currentQuote: _quotes[_currentIndex],
                  favoriteQuotes: _favoriteQuotes,
                  likeCounts: _likeCounts,
                  onShare: _shareQuoteAsImage,
                  onNext: () {
                    _hideSecondPage();
                    _nextQuote();
                  },
                  onPrevious: () {
                    _hideSecondPage();
                    _previousQuote();
                  },
                  onToggleFavorite: _toggleFavoriteFromBar,
                  onShowDetails: _showDetailsPopup,
                ),
            ],
          ),

          // Tag/Author details island overlay above the bottom action bar
          if (_showDetailsIsland)
            Positioned.fill(
              child: Stack(
                children: [
                  // Dismiss barrier
                  Positioned.fill(
                    child: GestureDetector(
                      onTap: () => setState(() => _showDetailsIsland = false),
                      behavior: HitTestBehavior.opaque,
                      child: Container(color: Colors.transparent),
                    ),
                  ),
                  // Island positioned just above the bottom bar
                  Align(
                    alignment: Alignment.bottomCenter,
                    child: Padding(
                      padding: EdgeInsets.only(
                        bottom: 80 + MediaQuery.of(context).padding.bottom + 6,
                      ),
                      child:
                          _quotes.isNotEmpty && _currentIndex < _quotes.length
                          ? DetailsPopupContent(
                              quote: _quotes[_currentIndex],
                              buildTagChip: _buildTagChip,
                              buildAuthorChip: _buildAuthorChip,
                              onTagToggled: _toggleTagFilter,
                              onAuthorToggled: _toggleAuthorFilter,
                              onRequestClose: () =>
                                  setState(() => _showDetailsIsland = false),
                            )
                          : const SizedBox.shrink(),
                    ),
                  ),
                ],
              ),
            ),

          // Streak Island Overlay
          if (_streakIslandData != null)
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: SafeArea(
                bottom: false, // Don't apply SafeArea to bottom
                child: Column(
                  children: [
                    if (_streakIslandData != null)
                      StreakIsland(
                        streakMessage: _streakIslandData!['message'] as String,
                        weeklyView:
                            _streakIslandData!['weeklyView']
                                as List<Map<String, dynamic>>,
                        onTap: () {
                          // Optional: Show streak history or details
                        },
                        onDismiss: () {
                          setState(() {
                            _streakIslandData = null;
                          });
                        },
                      ),
                    if (_awardedFeatureKey != null)
                      RewardIsland(
                        featureKey: _awardedFeatureKey!,
                        onDismiss: () {
                          setState(() {
                            _awardedFeatureKey = null;
                          });
                        },
                      ),
                    if (_activeTip != null)
                      TipIsland(
                        message: _getTipMessage(_activeTip!),
                        icon: _getTipIcon(_activeTip!),
                        onDismiss: () {
                          setState(() {
                            _activeTip = null;
                          });
                        },
                      ),
                  ],
                ),
              ),
            ),

          // Celebration Overlay
          if (_celebrationType != null)
            Positioned.fill(
              child: SimpleCelebrationOverlay(
                animationType: _celebrationType!,
                onComplete: () {
                  setState(() {
                    _celebrationType = null;
                  });
                },
              ),
            ),
        ],
      ),
      appBar: AppBar(
        title: Text(
          'Literature Bites',
          style: Theme.of(context).textTheme.titleLarge?.copyWith(
            color: Theme.of(context).primaryColor,
          ),
        ),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0.0,
        shadowColor: Colors.transparent,
        surfaceTintColor: Colors.transparent,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              showModalBottomSheet(
                context: context,
                isScrollControlled: true,
                backgroundColor: Colors.transparent,
                builder: (context) {
                  return FractionallySizedBox(
                    heightFactor: 0.75,
                    child: SettingsSheet(
                      allQuotes: _allQuotes,
                      favoriteQuotes: _favoriteQuotes,
                      viewCounts: _viewCounts,
                    ),
                  );
                },
              );
            },
          ),
        ],
      ),
      drawer: _buildDrawer(context),
    );
  }

  void _updatePageViewItems() {
    setState(() {
      final views = _seenQuoteIds.length;
      if ([10, 30, 60].contains(views)) {
        final cardId = 'info_$views';
        if (!_infoCardIds.contains(cardId)) {
          final nextQuoteIndex =
              _pageViewItems.indexWhere(
                (item) => item is Quote && item.id == _quotes[_currentIndex].id,
              ) +
              1;
          if (nextQuoteIndex < _pageViewItems.length) {
            _pageViewItems.insert(nextQuoteIndex, _InfoCardModel(id: cardId));
            _infoCardIds.add(cardId);
            _saveInfoCardIds();
          }
        }
      }
    });
  }

  Future<void> _saveInfoCardIds() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList('infoCardIds', _infoCardIds.toList());
  }

  void _checkForTips() async {
    final prefs = await SharedPreferences.getInstance();
    final shownTips = prefs.getStringList('shownTips') ?? [];

    if (_favoriteQuotes.isNotEmpty) {
      return;
    }

    final milestones = [5, 15, 30];
    for (var milestone in milestones) {
      if (_seenQuoteIds.length == milestone &&
          !shownTips.contains('double_tap_$milestone')) {
        setState(() {
          _activeTip = 'double_tap';
        });

        shownTips.add('double_tap_$milestone');
        await prefs.setStringList('shownTips', shownTips);
        break;
      }
    }
  }

  String _getTipMessage(String tipKey) {
    switch (tipKey) {
      case 'double_tap':
        return 'Double-tap any quote to add it to your favorites!';
      default:
        return 'Tip: Explore the app to discover more features!';
    }
  }

  IconData _getTipIcon(String tipKey) {
    switch (tipKey) {
      case 'double_tap':
        return Icons.favorite_border;
      default:
        return Icons.lightbulb_outline;
    }
  }

  Widget _buildInfoCard() {
    String title = 'Did You Know?';
    String message;
    List<Widget> actions = [];

    final bool shouldShowLearnCard = !_hasExploredLearn;
    final bool shouldShowBrowseCard = !_hasExploredBrowse;

    if (shouldShowLearnCard && shouldShowBrowseCard) {
      message =
          'You can expand the drawer to browse quotes by author or tag, or to start a personalized quiz in the Learn section.';
      actions = [
        GradientOutlinedButton(
          onPressed: () => _handleInfoCardNavigation(_navigateToBrowse),
          child: const Text('Browse'),
        ),
        GradientOutlinedButton(
          onPressed: () => _handleInfoCardNavigation(_navigateToLearn),
          child: const Text('Learn'),
        ),
      ];
    } else if (shouldShowLearnCard) {
      message =
          'You can expand the drawer to start a personalized quiz in the Learn section.';
      actions = [
        GradientOutlinedButton(
          onPressed: () => _handleInfoCardNavigation(_navigateToLearn),
          child: const Text('Learn Now'),
        ),
      ];
    } else if (shouldShowBrowseCard) {
      message =
          'You can expand the drawer to browse quotes by author, tag, or historical period.';
      actions = [
        GradientOutlinedButton(
          onPressed: () => _handleInfoCardNavigation(_navigateToBrowse),
          child: const Text('Browse Now'),
        ),
      ];
    } else {
      // This case should ideally not be hit if logic is correct
      return Container();
    }
    return Center(
      child: InfoCard(title: title, message: message, actions: actions),
    );
  }

  void _handleInfoCardNavigation(VoidCallback navigationAction) {
    // Remove the info card before navigating
    setState(() {
      _pageViewItems.removeWhere((item) => item is _InfoCardModel);
    });
    navigationAction();
  }

  Drawer _buildDrawer(BuildContext context) {
    return Drawer(
      child: ListView(
        children: [
          const DrawerHeader(
            child: Center(
              child: Text(
                "Literature Bites",
                style: TextStyle(fontSize: 32, fontFamily: 'EBGaramond'),
              ),
            ),
          ),
          ListTile(
            leading: const Icon(Icons.person_outline),
            title: const Text("Your Profile"),
            onTap: () {
              Navigator.pop(context);
              _navigateToProfile();
            },
          ),

          const Divider(),
          ListTile(
            leading: const Icon(Icons.explore),
            title: const Text("Browse"),
            onTap: () {
              Navigator.pop(context);
              _navigateToBrowse();
            },
          ),
          ListTile(
            leading: Icon(
              Icons.favorite_rounded,
              color: _isFavoritesMode ? Colors.redAccent : null,
            ),
            title: Text("Your Favorites (${_favoriteQuotes.length})"),
            selectedTileColor: Theme.of(context).brightness == Brightness.dark
                ? Colors.grey.withOpacity(0.3)
                : Colors.black.withOpacity(0.08),
            selected: _isFavoritesMode,
            onTap: () {
              Navigator.pop(context);
              _toggleFavoritesFilter();
            },
          ),
          ListTile(
            leading: const Icon(Icons.school),
            title: const Text("Learn"),
            onTap: () {
              Navigator.pop(context);
              _navigateToLearn();
            },
          ),
          if (_selectedTags.isNotEmpty ||
              _selectedAuthors.isNotEmpty ||
              _periodFilter != null ||
              _isFavoritesMode)
            ListTile(
              leading: const Icon(Icons.clear),
              title: Text("Clear Filters"),
              onTap: () {
                Navigator.pop(context);
                _clearFilter();
              },
            ),

          const Divider(),
          ListTile(
            leading: const Icon(Icons.info_outline),
            title: const Text("About this App"),
            onTap: () {
              Navigator.pop(context);
              _navigateToAbout();
            },
          ),
        ],
      ),
    );
  }
}


===== srs_service.dart =====

import 'dart:convert';
import 'dart:math';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:quotes_app/services/entitlements_service.dart';

class SrsItem {
  final String quoteId;
  int reps;
  int lapses;
  double ease;
  int interval;
  DateTime due;
  String lastResult;

  SrsItem({
    required this.quoteId,
    this.reps = 0,
    this.lapses = 0,
    this.ease = 2.5,
    this.interval = 0,
    required this.due,
    this.lastResult = 'new',
  });

  Map<String, dynamic> toJson() => {
    'quoteId': quoteId,
    'reps': reps,
    'lapses': lapses,
    'ease': ease,
    'interval': interval,
    'due': due.toIso8601String(),
    'lastResult': lastResult,
  };

  factory SrsItem.fromJson(Map<String, dynamic> json) => SrsItem(
    quoteId: json['quoteId'],
    reps: json['reps'] ?? 0,
    lapses: json['lapses'] ?? 0,
    ease: json['ease'] ?? 2.5,
    interval: json['interval'] ?? 0,
    due: DateTime.parse(json['due']),
    lastResult: json['lastResult'] ?? 'new',
  );
}

class SRSService {
  static const _srsKey = 'srs_data';
  Map<String, SrsItem> _srsItems = {};

  Future<void> _load() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_srsKey);
    if (jsonString != null) {
      final decoded = json.decode(jsonString) as Map<String, dynamic>;
      if (decoded['version'] == 1) {
        final items = decoded['items'] as Map<String, dynamic>;
        _srsItems = items.map(
          (key, value) => MapEntry(key, SrsItem.fromJson(value)),
        );
      }
    }
  }

  Future<void> _save() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = json.encode({
      'version': 1,
      'items': _srsItems.map((key, value) => MapEntry(key, value.toJson())),
    });
    await prefs.setString(_srsKey, jsonString);
  }

  Future<int> dueCount(DateTime today) async {
    await _load();
    return _srsItems.values.where((item) => !item.due.isAfter(today)).length;
  }

  Future<List<String>> loadDue(DateTime today) async {
    await _load();
    final items = _srsItems.values
        .where((item) => !item.due.isAfter(today))
        .toList();
    items.sort((a, b) => a.due.compareTo(b.due));
    return items.map((item) => item.quoteId).toList();
  }

  Future<List<String>> getStruggledQuotes() async {
    await _load();
    return _srsItems.values
        .where((item) => item.lastResult == 'incorrect')
        .map((item) => item.quoteId)
        .toList();
  }

  Future<int> getLearnedQuotesCount() async {
    await _load();
    return _srsItems.values
        .where((item) => item.reps >= 3 && item.lapses == 0)
        .length;
  }

  Future<void> grade(
    String quoteId, {
    required bool correct,
    required DateTime today,
  }) async {
    await _load();
    final item = _srsItems[quoteId] ?? SrsItem(quoteId: quoteId, due: today);

    if (correct) {
      item.reps++;
      if (item.reps == 1) {
        item.interval = 1;
      } else if (item.reps == 2) {
        item.interval = 6;
      } else {
        item.interval = (item.interval * item.ease).round();
      }
      item.lastResult = 'correct';
    } else {
      item.lapses++;
      item.interval = 0;
      item.reps = 0;
      item.lastResult = 'incorrect';
    }

    item.ease = max(
      1.3,
      item.ease +
          0.1 -
          (5 - (correct ? 5 : 1)) * (0.08 + (5 - (correct ? 5 : 1)) * 0.02),
    );
    item.due = today.add(Duration(days: item.interval));
    _srsItems[quoteId] = item;
    await _save();
  }

  Future<void> addQuote(String quoteId) async {
    await _load();
    _srsItems[quoteId] = SrsItem(quoteId: quoteId, due: DateTime.now());
    await _save();
  }

  Future<void> addMany(Set<String> quoteIds) async {
    await _load();
    for (final quoteId in quoteIds) {
      _srsItems[quoteId] = SrsItem(quoteId: quoteId, due: DateTime.now());
    }
    await _save();
  }

  Future<void> removeQuote(String quoteId) async {
    await _load();
    _srsItems.remove(quoteId);
    await _save();
  }

  Future<int> dailyCap() async {
    final isPro = await EntitlementsService.instance.isPro();
    final hasSrsPass = await EntitlementsService.instance.isFeatureActive(
      'srs_unlimited',
    );
    return (isPro || hasSrsPass) ? 10000 : 20;
  }

  Future<bool> canReviewMore(DateTime today) async {
    // This is a placeholder. A real implementation would track daily reviews.
    return true;
  }
}


===== author_quiz_page.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quiz_models.dart';
import 'package:quotes_app/quiz_service.dart';
import 'package:quotes_app/srs_service.dart';
import 'quote.dart';

class AuthorQuizPage extends StatefulWidget {
  final List<Quote> favoriteQuotes;
  final List<Quote> allQuotes;

  const AuthorQuizPage({
    super.key,
    required this.favoriteQuotes,
    required this.allQuotes,
  });

  @override
  State<AuthorQuizPage> createState() => _AuthorQuizPageState();
}

class _AuthorQuizPageState extends State<AuthorQuizPage> {
  final QuizService _quizService = QuizService();
  final SRSService _srsService = SRSService();

  QuizQuestion? _currentQuestion;
  bool _answered = false;
  String? _selectedAnswer;

  @override
  void initState() {
    super.initState();
    _generateQuestion();
  }

  Future<void> _generateQuestion() async {
    final dueQuoteIds = await _srsService.loadDue(DateTime.now());
    final dueQuotes = widget.favoriteQuotes
        .where((quote) => dueQuoteIds.contains(quote.id))
        .toList();

    final quotesForQuestions = dueQuotes.isNotEmpty
        ? dueQuotes
        : widget.favoriteQuotes;

    setState(() {
      _currentQuestion = _quizService.generateSingleQuestion(
        fromQuotes: quotesForQuestions
            .where((q) => q.authorBirth != null)
            .toList(),
        allQuotes: widget.allQuotes,
        allowedTypes: [QuizType.authorPeriod],
      );
      _answered = false;
      _selectedAnswer = null;
    });
  }

  void _handleAnswer(String answer) {
    if (_answered) return;
    final isCorrect = answer == _currentQuestion!.correctAnswer;
    setState(() {
      _selectedAnswer = answer;
      _answered = true;
      _srsService.grade(
        _currentQuestion!.quote.id,
        correct: isCorrect,
        today: DateTime.now(),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final backgroundColor = Theme.of(context).scaffoldBackgroundColor;
    final textColor = Theme.of(context).primaryColor;

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        title: Text(
          'Author Quizzes',
          style: TextStyle(fontFamily: 'Georgia', color: textColor),
        ),
        backgroundColor: backgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: textColor),
        actions: [
          TextButton(
            onPressed: _generateQuestion,
            child: Text(
              'Skip',
              style: TextStyle(color: textColor.withOpacity(0.7)),
            ),
          ),
        ],
      ),
      body: _currentQuestion == null
          ? _buildEmptyState(textColor)
          : _buildMultipleChoiceUI(textColor),
    );
  }

  Widget _buildEmptyState(Color textColor) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32.0),
        child: Text(
          widget.favoriteQuotes.where((q) => q.authorBirth != null).isEmpty
              ? 'Add quotes from authors with known birth years to start this quiz.'
              : 'Could not generate a question. Try adding more authors to your favorites!',
          textAlign: TextAlign.center,
          style: TextStyle(
            fontFamily: 'Georgia',
            fontSize: 18,
            color: textColor,
          ),
        ),
      ),
    );
  }

  Widget _buildMultipleChoiceUI(Color textColor) {
    final question = _currentQuestion!;
    final isCorrect = _selectedAnswer == question.correctAnswer;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 24.0),
          child: Text(
            question.questionText,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 22,
              fontFamily: 'Georgia',
              fontWeight: FontWeight.bold,
              color: textColor.withOpacity(0.9),
            ),
          ),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: question.options.length,
            itemBuilder: (context, index) {
              final option = question.options[index];
              Color? tileColor;
              IconData? icon;

              if (_answered) {
                if (option == question.correctAnswer) {
                  tileColor = Colors.green.withOpacity(0.2);
                  icon = Icons.check_circle;
                } else if (option == _selectedAnswer) {
                  tileColor = Colors.red.withOpacity(0.2);
                  icon = Icons.cancel;
                }
              }

              return Card(
                elevation: _answered ? 0 : 1,
                margin: const EdgeInsets.symmetric(
                  vertical: 6.0,
                  horizontal: 16.0,
                ),
                color:
                    tileColor ??
                    (Theme.of(context).brightness == Brightness.dark
                        ? Colors.grey[850]
                        : Colors.white),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                  side: BorderSide(
                    color: _answered && option == question.correctAnswer
                        ? Colors.green
                        : Colors.transparent,
                    width: 1,
                  ),
                ),
                child: ListTile(
                  title: Text(
                    option,
                    style: TextStyle(fontFamily: 'Georgia', color: textColor),
                  ),
                  trailing: icon != null
                      ? Icon(
                          icon,
                          color: option == question.correctAnswer
                              ? Colors.green
                              : Colors.red,
                        )
                      : null,
                  onTap: () => _handleAnswer(option),
                ),
              );
            },
          ),
        ),
        if (_answered)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Theme.of(context).primaryColor,
                foregroundColor: Theme.of(context).scaffoldBackgroundColor,
                minimumSize: const Size(double.infinity, 50),
              ),
              onPressed: _generateQuestion,
              child: Text(
                isCorrect ? 'Next' : 'Continue',
                style: const TextStyle(fontSize: 16, fontFamily: 'Georgia'),
              ),
            ),
          ),
      ],
    );
  }
}


===== recommendation_service.dart =====

import 'dart:math';
import 'package:quotes_app/quote.dart';

class RecommendationService {
  final List<Quote> allQuotes;
  final List<Quote> favoriteQuotes;
  final Map<String, int> likeCounts;
  final Map<String, int> viewCounts;
  final int totalViews;
  final Set<String> preferredAuthors;
  final Set<String> preferredTags;
  final int? sessionSeed;

  // Feature weights can be tuned to adjust recommendation quality
  static const Map<String, double> _featureWeights = {
    'author': 3.0,
    'tags': 1.5,
    'period': 1.0,
    'year': 1.0,
    'sentiment': 1.5,
    'tone_label': 2.5,
    'tone_intensity': 2.0,
    'length': 2.0,
  };

  // A conservative weight for how much view proportion affects the penalty
  static const double _viewProportionWeight = 0.5;

  // Size of the pool for weighted random sampling
  static const int _reservoirSize = 150;

  // Pre-calculated normalization values
  final double _maxQuoteLength;
  final double _maxYear;
  final double _minYear;

  // Random number generator for session-specific recommendations
  final Random _random;

  RecommendationService({
    required this.allQuotes,
    required this.favoriteQuotes,
    required this.likeCounts,
    required this.viewCounts,
    required this.totalViews,
    this.preferredAuthors = const {},
    this.preferredTags = const {},
    this.sessionSeed,
  }) : _maxQuoteLength = allQuotes
           .map((q) => q.text.length)
           .reduce((a, b) => a > b ? a : b)
           .toDouble(),
       _maxYear = allQuotes
           .where((q) => q.year != null)
           .map((q) => q.year!)
           .reduce((a, b) => a > b ? a : b)
           .toDouble(),
       _minYear = allQuotes
           .where((q) => q.year != null)
           .map((q) => q.year!)
           .reduce((a, b) => a < b ? a : b)
           .toDouble(),
       _random = Random(sessionSeed);

  List<Quote> getRecommendations() {
    // Only provide recommendations if the user has favorited a meaningful number of quotes
    if (favoriteQuotes.length < 10) {
      return (List<Quote>.from(allQuotes)..shuffle(_random));
    }

    final favoriteQuoteIds = favoriteQuotes.map((q) => q.id).toSet();
    final recommendations = <Quote, double>{};

    for (final candidate in allQuotes) {
      double rawScore = 0.0;
      for (final favorite in favoriteQuotes) {
        // Use a logarithmic scale for the like multiplier for diminishing returns
        final likeMultiplier = log((likeCounts[favorite.id] ?? 1) + 1);
        rawScore += _calculateSimilarity(candidate, favorite) * likeMultiplier;
      }

      // Add a novelty bonus for non-favorited quotes to encourage discovery
      if (!favoriteQuoteIds.contains(candidate.id)) {
        rawScore += 1.0;
      }

      // Add a bonus for preferred authors from onboarding
      if (preferredAuthors.contains(candidate.authorName)) {
        rawScore *= 1.5; // Give a 50% boost
      }

      // Add a bonus for matching preferred tags
      final candidateTags = candidate.tags.toSet();
      final matchedTags = candidateTags.intersection(preferredTags).length;
      if (matchedTags > 0) {
        rawScore *= (1.0 + 0.2 * matchedTags); // 20% boost per matched tag
      }

      // 2. Exposure penalty: down-weight score based on view count
      final views = viewCounts[candidate.id] ?? 0;
      final viewProportion = totalViews > 0 ? views / totalViews : 0;
      final penalty =
          sqrt(1 + views) * (1 + _viewProportionWeight * viewProportion);
      final effectiveScore = rawScore / penalty;

      recommendations[candidate] = effectiveScore;
    }

    final sortedRecommendations = recommendations.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));

    // 3. Top-K Reservoir: limit the pool to most relevant items
    final reservoir = sortedRecommendations.take(_reservoirSize).toList();

    // 4. Weighted Sampling: shuffle the reservoir based on score
    final weightedSample = _performWeightedSampling(reservoir);

    // Append the rest of the items, shuffled, for variety if user scrolls far
    final remainingQuotes =
        sortedRecommendations.skip(_reservoirSize).map((e) => e.key).toList()
          ..shuffle(_random);

    return weightedSample + remainingQuotes;
  }

  double _calculateSimilarity(Quote a, Quote b) {
    double totalSimilarity = 0;

    // Author
    if (a.authorName == b.authorName) {
      totalSimilarity += 1.0 * _featureWeights['author']!;
    }

    // Tags (Jaccard Similarity)
    final tagsA = a.tags.toSet();
    final tagsB = b.tags.toSet();
    final intersection = tagsA.intersection(tagsB).length;
    final union = tagsA.union(tagsB).length;
    if (union > 0) {
      totalSimilarity += (intersection / union) * _featureWeights['tags']!;
    }

    // Period
    if (a.period != null && a.period == b.period) {
      totalSimilarity += 1.0 * _featureWeights['period']!;
    }

    // Year
    if (a.year != null && b.year != null) {
      totalSimilarity +=
          _normalizedGaussianSimilarity(
            a.year!.toDouble(),
            b.year!.toDouble(),
            _maxYear - _minYear,
          ) *
          _featureWeights['year']!;
    }

    // Sentiment
    if (a.sentimentScore != null && b.sentimentScore != null) {
      totalSimilarity +=
          _normalizedGaussianSimilarity(
            a.sentimentScore!,
            b.sentimentScore!,
            2.0,
          ) *
          _featureWeights['sentiment']!; // Range is -1 to 1, so 2.0
    }

    // Tone Label
    if (a.tone != null && a.tone == b.tone) {
      totalSimilarity += 1.0 * _featureWeights['tone_label']!;
    }

    // Tone Intensity
    if (a.intensity != null && b.intensity != null) {
      totalSimilarity +=
          _normalizedGaussianSimilarity(
            a.intensity!.toDouble(),
            b.intensity!.toDouble(),
            100.0,
          ) *
          _featureWeights['tone_intensity']!; // Range is 0-100
    }

    // Quote Length
    totalSimilarity +=
        _normalizedGaussianSimilarity(
          a.text.length.toDouble(),
          b.text.length.toDouble(),
          _maxQuoteLength,
        ) *
        _featureWeights['length']!;

    return totalSimilarity;
  }

  // Performs weighted random sampling without replacement
  List<Quote> _performWeightedSampling(
    List<MapEntry<Quote, double>> reservoir,
  ) {
    final result = <Quote>[];
    final tempReservoir = List<MapEntry<Quote, double>>.from(reservoir);

    if (tempReservoir.isEmpty) {
      return result;
    }

    while (tempReservoir.isNotEmpty) {
      final totalWeight = tempReservoir.fold(
        0.0,
        (sum, item) => sum + item.value,
      );

      if (totalWeight <= 0) {
        // If remaining weights are zero, shuffle and add the rest
        tempReservoir.shuffle(_random);
        result.addAll(tempReservoir.map((e) => e.key));
        break;
      }

      final pick = _random.nextDouble() * totalWeight;
      var cumulativeWeight = 0.0;

      for (var i = 0; i < tempReservoir.length; i++) {
        cumulativeWeight += tempReservoir[i].value;
        if (pick <= cumulativeWeight) {
          final selected = tempReservoir.removeAt(i);
          result.add(selected.key);
          break; // Exit inner loop once item is picked
        }
      }
    }
    return result;
  }

  // Calculates similarity on a scale from 0 to 1 using a Gaussian-like curve
  double _normalizedGaussianSimilarity(double v1, double v2, double range) {
    if (range == 0) return 1.0;
    final diff = (v1 - v2).abs();
    // Use a simplified exponential decay function
    return exp(-pow(diff / (range * 0.5), 2));
  }
}


===== main.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quote_app.dart';
import 'package:quotes_app/services/notification_service.dart';
import 'package:quotes_app/services/purchase_service.dart';
import 'package:quotes_app/services/revenuecat_keys.dart';
import 'package:quotes_app/services/theme_controller.dart';
import 'package:timezone/data/latest_all.dart' as tz;

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  tz.initializeTimeZones();
  await NotificationService.init();
  await ThemeController.instance.init();
  await PurchaseService.instance.configure(iosApiKey: rcAppleApiKey);
  runApp(const MyApp());

  // Handle notification that launched the app after first frame
  WidgetsBinding.instance.addPostFrameCallback((_) {
    NotificationService.handleInitialNotification();
  });
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    ThemeController.instance.addListener(_onThemeChanged);
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    ThemeController.instance.removeListener(_onThemeChanged);
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  void _onThemeChanged() {
    setState(() {});
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // Only sync if user has active subscriptions to avoid unnecessary network calls
      PurchaseService.instance.syncEntitlementFromRC().catchError((_) {
        // Silently handle sync errors on resume
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Literature Bites',
      navigatorKey: NotificationService.navigatorKey,
      theme: ThemeController.instance.themeData,
      home: const QuoteApp(),
      onGenerateRoute: (settings) {
        if (settings.name == '/quote') {
          final quoteId = settings.arguments as String?;
          return MaterialPageRoute(
            builder: (context) {
              return QuoteApp(quoteId: quoteId);
            },
          );
        }
        return null;
      },
    );
  }
}


===== author_quotes_page.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quote.dart';

class AuthorQuotesPage extends StatelessWidget {
  final String authorName;
  final List<Quote> quotes;
  final bool isDarkMode;

  const AuthorQuotesPage({
    super.key,
    required this.authorName,
    required this.quotes,
    required this.isDarkMode,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: isDarkMode
          ? Colors.black
          : const Color.fromARGB(255, 240, 234, 225),
      appBar: AppBar(
        title: Text(
          authorName,
          style: TextStyle(
            fontFamily: 'Georgia',
            color: isDarkMode ? Colors.white : Colors.black,
          ),
        ),
        backgroundColor: isDarkMode
            ? Colors.black
            : const Color.fromARGB(255, 240, 234, 225),
        elevation: 0,
        iconTheme: IconThemeData(
          color: isDarkMode ? Colors.white : Colors.black,
        ),
      ),
      body: ListView.builder(
        itemCount: quotes.length,
        itemBuilder: (context, index) {
          final quote = quotes[index];
          return Card(
            color: isDarkMode ? Colors.grey[850] : Colors.white,
            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    '"${quote.text}"',
                    style: TextStyle(
                      fontFamily: 'Georgia',
                      fontSize: 16,
                      fontStyle: FontStyle.italic,
                      color: isDarkMode ? Colors.white : Colors.black,
                    ),
                  ),
                  if (quote.displaySource.isNotEmpty) ...[
                    const SizedBox(height: 12),
                    Text(
                      '— ${quote.displaySource}',
                      style: TextStyle(
                        fontFamily: 'Georgia',
                        fontSize: 14,
                        color: isDarkMode ? Colors.white70 : Colors.black87,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}


===== profile_rewards_page.dart =====

import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/services/rewards_service.dart';
import 'package:quotes_app/info_card.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:quotes_app/services/purchase_service.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/services/revenuecat_keys.dart';
import 'package:quotes_app/browse_hub.dart';
import 'package:quotes_app/learn_hub.dart';
import 'package:quotes_app/widgets/settings_sheet.dart';
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/quote_service.dart';
import 'package:quotes_app/utils/feature_gate.dart';

class ProfileRewardsPage extends StatefulWidget {
  const ProfileRewardsPage({super.key});

  @override
  State<ProfileRewardsPage> createState() => _ProfileRewardsPageState();
}

class _ProfileRewardsPageState extends State<ProfileRewardsPage> {
  late Future<RewardsSnapshot> _rewardsFuture;
  int _favoriteQuotesCount = 0;
  List<Quote> _allQuotes = [];
  List<Quote> _favoriteQuotes = [];
  Map<String, int> _viewCounts = {};
  Map<String, int> _likeCounts = {};

  @override
  void initState() {
    super.initState();
    _loadData();
    Analytics.instance.logEvent('profile.opened');
  }

  void _loadData() {
    _rewardsFuture = RewardsService.instance.load();
    _loadStats();
    setState(() {});
  }

  Future<void> _loadStats() async {
    final prefs = await SharedPreferences.getInstance();
    final favoriteIds = prefs.getStringList('favoriteQuoteIds') ?? [];

    _allQuotes = await QuoteService.loadQuotes();
    _favoriteQuotes = _allQuotes
        .where((q) => favoriteIds.contains(q.id))
        .toList();

    setState(() {
      _favoriteQuotesCount = favoriteIds.length;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text(
          'Your Profile & Rewards',
          style: TextStyle(color: Theme.of(context).primaryColor),
        ),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      body: FutureBuilder<RewardsSnapshot>(
        future: _rewardsFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          } else if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          } else if (!snapshot.hasData) {
            return const Center(child: Text('No data available.'));
          }

          final rewards = snapshot.data!;
          return RefreshIndicator(
            onRefresh: () async => _loadData(),
            child: ListView(
              padding: const EdgeInsets.all(16.0),
              children: [
                _buildHeader(rewards.tier),
                const SizedBox(height: 24),
                _buildActivePasses(
                  rewards.activePasses,
                  isPro: rewards.tier == "Pro",
                ),
                const SizedBox(height: 24),
                if (rewards.nextPass != null)
                  _buildNextReward(rewards.nextPass!),
                const SizedBox(height: 24),
                _buildUsageStats(rewards),
                const SizedBox(height: 24),
                _buildFooter(),
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildHeader(String tier) {
    bool isPro = tier == "Pro";
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Account Status',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                      color: Theme.of(context).primaryColor,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Row(
                    children: [
                      if (isPro) ...[
                        Lottie.asset(
                          'assets/lottie/badge_sparkle.json',
                          width: 20,
                          height: 20,
                        ),
                        const SizedBox(width: 6),
                      ],
                      Text(
                        isPro ? 'Pro' : 'Standard',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                          color: Theme.of(
                            context,
                          ).primaryColor.withOpacity(0.8),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              if (isPro)
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    gradient: const LinearGradient(
                      colors: [Colors.blue, Colors.purple],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: const Text(
                    'Pro User',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                      fontSize: 14,
                    ),
                  ),
                )
              else
                GradientOutlinedButton(
                  onPressed: () {
                    openPaywall(
                      context: context,
                      contextKey: 'profile_upgrade',
                    ).then((result) {
                      if (result == true) {
                        _loadData(); // Refresh the entire page
                      }
                    });
                  },
                  backgroundColor: Theme.of(context).cardColor,
                  child: const Text(
                    'Upgrade',
                    style: TextStyle(fontWeight: FontWeight.w600),
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }

  void _navigateToFeature(String featureKey) {
    switch (featureKey) {
      case EntitlementsService.browseAuthor:
      case EntitlementsService.browsePeriod:
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => BrowseHubPage(
              allQuotes: _allQuotes,
              favoriteQuotes: _favoriteQuotes,
              viewCounts: _viewCounts,
              initialSelectedAuthors: const {},
              initialSelectedTags: const {},
            ),
          ),
        );
        break;
      case EntitlementsService.premiumThemes:
      case EntitlementsService.premiumFonts:
      case EntitlementsService.premiumShareStyles:
        showModalBottomSheet(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (context) => FractionallySizedBox(
            heightFactor: 0.75,
            child: SettingsSheet(
              allQuotes: _allQuotes,
              favoriteQuotes: _favoriteQuotes,
              viewCounts: _viewCounts,
            ),
          ),
        );
        break;
      case EntitlementsService.srsUnlimited:
      case EntitlementsService.learnTrainer:
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => LearnHubPage(
              allQuotes: _allQuotes,
              favoriteQuotes: _favoriteQuotes,
              viewCounts: _viewCounts,
              likeCounts: _likeCounts,
            ),
          ),
        );
        break;
    }
  }

  Widget _buildActivePasses(List<ActivePass> passes, {required bool isPro}) {
    if (isPro) {
      final proFeatures = EntitlementsService.proFeatureDisplayNames.values
          .toList();
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'All Pro Features Unlocked',
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 12),
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
              childAspectRatio: 2.5,
            ),
            itemCount: proFeatures.length,
            itemBuilder: (context, index) {
              final feature = proFeatures[index];
              return Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Colors.blue.shade300, Colors.purple.shade300],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Center(
                  child: Text(
                    feature,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              );
            },
          ),
        ],
      );
    }
    if (passes.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Theme.of(context).cardColor,
          borderRadius: BorderRadius.circular(12),
        ),
        child: const Center(
          child: Text(
            "You don’t have any passes yet—earn one by keeping your streak!",
            textAlign: TextAlign.center,
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Active Passes',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Theme.of(context).primaryColor,
          ),
        ),
        const SizedBox(height: 12),
        SizedBox(
          height: 120,
          child: ListView.builder(
            scrollDirection: Axis.horizontal,
            itemCount: passes.length,
            itemBuilder: (context, index) {
              final pass = passes[index];
              return Container(
                width: 180,
                margin: const EdgeInsets.only(right: 12),
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Colors.blue.shade300, Colors.purple.shade300],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      pass.displayName,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    Text(
                      'Expires in ${_formatDuration(pass.timeRemaining)}',
                      style: const TextStyle(
                        fontSize: 12,
                        color: Colors.white70,
                      ),
                    ),
                    TextButton(
                      onPressed: () {
                        Analytics.instance.logEvent('profile.active_pass_try', {
                          'feature': pass.featureKey,
                        });
                        _navigateToFeature(pass.featureKey);
                      },
                      child: const Text(
                        'Try',
                        style: TextStyle(color: Colors.white),
                      ),
                    ),
                  ],
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  String _formatDuration(Duration d) {
    if (d.inDays > 0) {
      return '${d.inDays}d ${d.inHours.remainder(24)}h';
    }
    if (d.inHours > 0) {
      return '${d.inHours}h ${d.inMinutes.remainder(60)}m';
    }
    return '${d.inMinutes}m';
  }

  Widget _buildNextReward(NextPassInfo nextPass) {
    Analytics.instance.logEvent('profile.next_reward_seen', {
      'nextMilestone': nextPass.nextMilestone,
      'daysRemaining': nextPass.daysRemaining,
    });

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Text(
                'Next free pass in ${nextPass.daysRemaining} days',
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const Spacer(),
              Lottie.asset(
                'assets/lottie/pulse_streak.json',
                width: 24,
                height: 24,
              ),
            ],
          ),
          const SizedBox(height: 8),
          LinearProgressIndicator(
            value: 1 - (nextPass.daysRemaining / 7),
            backgroundColor: Colors.grey.shade300,
            valueColor: const AlwaysStoppedAnimation<Color>(Colors.green),
          ),
          const SizedBox(height: 8),
          Text(
            'You\'ll unlock: ${nextPass.featureDisplayNamesAtNextMilestone.join(', ')} at day ${nextPass.nextMilestone}',
          ),
        ],
      ),
    );
  }

  Widget _buildUsageStats(RewardsSnapshot rewards) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Usage Stats',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Theme.of(context).primaryColor,
          ),
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: _buildStatCard(
                context,
                'Current Streak',
                rewards.currentStreak.toString(),
                Icons.local_fire_department_outlined,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _buildStatCard(
                context,
                'Longest Streak',
                '—',
                Icons.trending_up,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: _buildStatCard(
                context,
                'Favorited',
                _favoriteQuotesCount.toString(),
                Icons.favorite_outline,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildFooter() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        TextButton(
          onPressed: _handleRestore,
          child: const Text('Restore Purchases'),
        ),
        TextButton(
          onPressed: () async {
            await launchUrl(
              Uri.parse('itms-apps://apps.apple.com/account/subscriptions'),
              mode: LaunchMode.externalApplication,
            );
          },
          child: const Text('Manage Subscription'),
        ),
        TextButton(
          onPressed: _handleRefresh,
          child: const Text('Refresh Membership Status'),
        ),
      ],
    );
  }

  Future<void> _handleRestore() async {
    Analytics.instance.logEvent('profile.restore');
    final isProBefore = await EntitlementsService.instance.isPro();

    try {
      final customerInfo = await PurchaseService.instance.restore();
      final isProAfter =
          customerInfo.entitlements.all[rcEntitlementKey]?.isActive ?? false;

      if (mounted) {
        if (isProAfter && !isProBefore) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Purchases restored successfully.'),
              backgroundColor: Colors.green,
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('No new purchases to restore.')),
          );
        }
        _loadData();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Restore failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _handleRefresh() async {
    Analytics.instance.logEvent('profile.refresh_membership');
    final isProBefore = await EntitlementsService.instance.isPro();

    try {
      final customerInfo = await PurchaseService.instance
          .syncEntitlementFromRC();
      final isProAfter =
          customerInfo.entitlements.all[rcEntitlementKey]?.isActive ?? false;

      if (mounted) {
        if (isProAfter && !isProBefore) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Membership status refreshed successfully.'),
              backgroundColor: Colors.green,
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Membership status is up to date.')),
          );
        }
        _loadData();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Refresh failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Widget _buildStatCard(
    BuildContext context,
    String title,
    String value,
    IconData icon, {
    Color? color,
  }) {
    final cardColor = color ?? Theme.of(context).primaryColor.withOpacity(0.7);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, size: 28, color: cardColor),
          const SizedBox(height: 12),
          Text(
            value,
            style: TextStyle(
              fontSize: 28,
              fontWeight: FontWeight.bold,
              color: color ?? Theme.of(context).primaryColor,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            title,
            style: TextStyle(
              fontSize: 15,
              color: Theme.of(context).primaryColor.withOpacity(0.8),
            ),
          ),
        ],
      ),
    );
  }
}


===== dev_panel.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/services/streak_service.dart';

class DevPanelPage extends StatefulWidget {
  const DevPanelPage({super.key});

  @override
  DevPanelPageState createState() => DevPanelPageState();
}

class DevPanelPageState extends State<DevPanelPage> {
  bool _isPro = false;
  Map<String, DateTime> _passes = {};
  int _streakCount = 0;

  @override
  void initState() {
    super.initState();
    _loadStatus();
  }

  Future<void> _loadStatus() async {
    final isPro = await EntitlementsService.instance.isPro();
    final passes = await EntitlementsService.instance.getFeaturePasses();
    final streakCount = await StreakService.instance.getStreakCount();
    setState(() {
      _isPro = isPro;
      _passes = passes;
      _streakCount = streakCount;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Developer Panel')),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          _buildProStatusSection(),
          const Divider(),
          _buildStreakSection(),
          const Divider(),
          _buildFeaturePassesSection(),
        ],
      ),
    );
  }

  Widget _buildProStatusSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Pro Status', style: Theme.of(context).textTheme.headlineSmall),
        SwitchListTile(
          title: Text(_isPro ? 'Pro Active' : 'Pro Inactive'),
          value: _isPro,
          onChanged: (value) async {
            await EntitlementsService.instance.setPro(value);
            await _loadStatus();
          },
        ),
      ],
    );
  }

  Widget _buildStreakSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Streak: $_streakCount days',
          style: Theme.of(context).textTheme.headlineSmall,
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            ElevatedButton(
              onPressed: () async {
                await StreakService.instance.simulateMilestone(3);
                await _loadStatus();
              },
              child: const Text('Simulate Day 3'),
            ),
            ElevatedButton(
              onPressed: () async {
                await StreakService.instance.simulateMilestone(7);
                await _loadStatus();
              },
              child: const Text('Simulate Day 7'),
            ),
            ElevatedButton(
              onPressed: () async {
                await StreakService.instance.simulateMilestone(14);
                await _loadStatus();
              },
              child: const Text('Simulate Day 14'),
            ),
            ElevatedButton(
              onPressed: () async {
                await StreakService.instance.resetStreak();
                await _loadStatus();
              },
              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
              child: const Text('Reset Streak'),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildFeaturePassesSection() {
    final allFeatures = [
      EntitlementsService.browseAuthor,
      EntitlementsService.browseTags,
      EntitlementsService.browsePeriod,
      EntitlementsService.premiumThemes,
      EntitlementsService.premiumFonts,
      EntitlementsService.premiumShareStyles,
      EntitlementsService.srsUnlimited,
    ];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Feature Passes',
          style: Theme.of(context).textTheme.headlineSmall,
        ),
        ...allFeatures.map((key) => _buildPassControl(key)),
        const SizedBox(height: 16),
        if (_passes.isNotEmpty)
          ElevatedButton(
            onPressed: () async {
              await EntitlementsService.instance.clearAllPasses();
              await _loadStatus();
            },
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Clear All Passes'),
          ),
      ],
    );
  }

  Widget _buildPassControl(String featureKey) {
    final expiry = _passes[featureKey];
    final isActive = expiry != null && expiry.isAfter(DateTime.now());

    return ListTile(
      title: Text(featureKey),
      subtitle: Text(isActive ? 'Expires: ${expiry.toLocal()}' : 'Inactive'),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          ElevatedButton(
            onPressed: () async {
              await EntitlementsService.instance.grantFeaturePass(
                featureKey,
                const Duration(days: 7),
              );
              await _loadStatus();
            },
            child: const Text('Grant 7 Days'),
          ),
          if (isActive) ...[
            const SizedBox(width: 8),
            ElevatedButton(
              onPressed: () async {
                await EntitlementsService.instance.revokeFeaturePass(
                  featureKey,
                );
                await _loadStatus();
              },
              style: ElevatedButton.styleFrom(backgroundColor: Colors.orange),
              child: const Text('Revoke'),
            ),
          ],
        ],
      ),
    );
  }
}


===== browse_by_author.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quote.dart';

class _Author implements Comparable<_Author> {
  final String name;
  final int score;

  const _Author({required this.name, required this.score});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _Author &&
          runtimeType == other.runtimeType &&
          name == other.name;

  @override
  int get hashCode => name.hashCode;

  @override
  int compareTo(_Author other) {
    if (other.score == score) {
      return name.compareTo(other.name);
    }
    return other.score.compareTo(score);
  }
}

const List<String> _curatedAuthors = [
  'Albert Camus',
  'Oscar Wilde',
  'Bertrand Russell',
  'Friedrich Nietzsche',
  'Jean-Paul Sartre',
  'Fyodor Dostoevsky',
  'Leo Tolstoy',
  'George Orwell',
  'Aldous Huxley',
  'Virginia Woolf',
  'James Joyce',
  'William Shakespeare',
  'Mark Twain',
  'Ernest Hemingway',
  'Jane Austen',
  'Charles Dickens',
  'Kurt Vonnegut',
  'Philip K. Dick',
  'Franz Kafka',
  'Simone de Beauvoir',
  'George Eliot', // Mary Ann Evans
  'Hermann Hesse',
  'Seneca',
  'Marcus Aurelius',
  'Epictetus',
];

class BrowseByAuthorPage extends StatefulWidget {
  final List<Quote> allQuotes;
  final Set<String> initialSelectedAuthors;

  const BrowseByAuthorPage({
    super.key,
    required this.allQuotes,
    required this.initialSelectedAuthors,
  });

  @override
  State<BrowseByAuthorPage> createState() => _BrowseByAuthorPageState();
}

class _BrowseByAuthorPageState extends State<BrowseByAuthorPage> {
  List<_Author> _allAuthors = [];
  List<_Author> _collectionAuthors = [];
  List<_Author> _recommendedAuthors = [];
  List<_Author> _otherAuthors = [];
  List<_Author> _filteredAuthors = [];
  final Set<_Author> _selectedAuthors = {};
  final TextEditingController _searchController = TextEditingController();
  final List<dynamic> _listItems = [];

  @override
  void initState() {
    super.initState();
    final Map<String, int> authorScores = {};
    for (var quote in widget.allQuotes) {
      final authorName = quote.authorName;
      final authorScore = quote.author_score ?? 0;
      if (!authorScores.containsKey(authorName) ||
          authorScores[authorName]! < authorScore) {
        authorScores[authorName] = authorScore;
      }
    }
    _allAuthors =
        authorScores.entries
            .map((entry) => _Author(name: entry.key, score: entry.value))
            .toList()
          ..sort();

    _collectionAuthors = _allAuthors
        .where((author) => widget.initialSelectedAuthors.contains(author.name))
        .toList();

    _recommendedAuthors = _allAuthors
        .where(
          (author) =>
              _curatedAuthors.contains(author.name) &&
              !widget.initialSelectedAuthors.contains(author.name),
        )
        .toList();
    _otherAuthors = _allAuthors
        .where(
          (author) =>
              !_curatedAuthors.contains(author.name) &&
              !widget.initialSelectedAuthors.contains(author.name),
        )
        .toList();

    _filteredAuthors = _allAuthors;

    _selectedAuthors.addAll(
      _allAuthors.where(
        (author) => widget.initialSelectedAuthors.contains(author.name),
      ),
    );

    _searchController.addListener(() {
      _filterAuthors();
    });

    _buildCategorizedList();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _filterAuthors() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredAuthors = _allAuthors
          .where((author) => author.name.toLowerCase().contains(query))
          .toList();
    });
  }

  void _buildCategorizedList() {
    _listItems.clear();

    if (_collectionAuthors.isNotEmpty) {
      _listItems.add('Collection Authors');
      _listItems.addAll(_collectionAuthors);
    }

    if (_recommendedAuthors.isNotEmpty) {
      _listItems.add('Recommended Authors');
      _listItems.addAll(_recommendedAuthors);
    }

    if (_otherAuthors.isNotEmpty) {
      _listItems.add('All Authors');
      _listItems.addAll(_otherAuthors);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text(
          'Browse by Author',
          style: TextStyle(
            fontFamily: 'Georgia',
            color: Theme.of(context).primaryColor,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              final selectedNames = _selectedAuthors.map((a) => a.name).toSet();
              Navigator.of(context).pop(selectedNames);
            },
            child: Text(
              'Done',
              style: TextStyle(
                color: Theme.of(context).primaryColor,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 16),
            TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search for an author...',
                prefixIcon: const Icon(Icons.search),
                filled: true,
                fillColor: Theme.of(context).primaryColor.withOpacity(0.05),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(30),
                  borderSide: BorderSide.none,
                ),
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: _searchController.text.isNotEmpty
                  ? _buildFilteredAuthorList()
                  : _buildCategorizedAuthorList(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFilteredAuthorList() {
    return ListView.builder(
      itemCount: _filteredAuthors.length,
      itemBuilder: (context, index) {
        return _buildAuthorTile(_filteredAuthors[index]);
      },
    );
  }

  Widget _buildCategorizedAuthorList() {
    return ListView.builder(
      itemCount: _listItems.length,
      itemBuilder: (context, index) {
        final item = _listItems[index];
        if (item is String) {
          return _buildSectionHeader(item);
        } else if (item is _Author) {
          return _buildAuthorTile(item);
        }
        return const SizedBox.shrink();
      },
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 8),
      child: Text(
        title,
        style: TextStyle(
          fontFamily: 'EBGaramond',
          fontSize: 18,
          fontWeight: FontWeight.bold,
          color: Theme.of(context).primaryColor.withOpacity(0.5),
        ),
      ),
    );
  }

  Widget _buildAuthorTile(_Author author) {
    final isSelected = _selectedAuthors.contains(author);
    return ListTile(
      title: Text(
        author.name,
        style: TextStyle(
          fontFamily: 'EBGaramond',
          color: Theme.of(context).primaryColor,
        ),
      ),
      trailing: Checkbox(
        value: isSelected,
        onChanged: (bool? value) {
          setState(() {
            if (value == true) {
              _selectedAuthors.add(author);
            } else {
              _selectedAuthors.remove(author);
            }
          });
        },
        activeColor: Theme.of(context).primaryColor,
        checkColor: Theme.of(context).scaffoldBackgroundColor,
      ),
      onTap: () {
        setState(() {
          if (isSelected) {
            _selectedAuthors.remove(author);
          } else {
            _selectedAuthors.add(author);
          }
        });
      },
    );
  }
}


===== period_quotes_page.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quote.dart';

class PeriodQuotesPage extends StatelessWidget {
  final String periodName;
  final List<Quote> quotes;

  const PeriodQuotesPage({
    super.key,
    required this.periodName,
    required this.quotes,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text(
          periodName,
          style: TextStyle(
            fontFamily: 'Georgia',
            color: Theme.of(context).primaryColor,
          ),
        ),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      body: ListView.builder(
        itemCount: quotes.length,
        itemBuilder: (context, index) {
          final quote = quotes[index];
          return Card(
            color: Theme.of(context).cardColor,
            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    '"${quote.text}"',
                    style: TextStyle(
                      fontFamily: 'Georgia',
                      fontSize: 16,
                      fontStyle: FontStyle.italic,
                      color: Theme.of(context).primaryColor,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Align(
                    alignment: Alignment.centerRight,
                    child: Text(
                      '— ${quote.authorInfo}',
                      style: TextStyle(
                        fontFamily: 'Georgia',
                        fontSize: 14,
                        color: Theme.of(context).primaryColor.withOpacity(0.7),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}


===== browse_by_period_filter.dart =====

import 'package:flutter/material.dart';
import 'dart:async';
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/models/period_catalog.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';

class AuthorInfo {
  final String name;
  final int? birthYear;
  final int? deathYear;
  int quoteCount;
  bool isSelected;

  AuthorInfo({
    required this.name,
    this.birthYear,
    this.deathYear,
    required this.quoteCount,
    this.isSelected = true,
  });

  String get lifeSpan {
    if (birthYear != null && deathYear != null) {
      return '$birthYear–$deathYear';
    } else if (birthYear != null) {
      return '$birthYear–';
    } else if (deathYear != null) {
      return '–$deathYear';
    }
    return '';
  }
}

class BrowseByPeriodFilterPage extends StatefulWidget {
  final List<Quote> allQuotes;
  final String? initialPeriod;
  final int? initialStartYear;
  final int? initialEndYear;

  const BrowseByPeriodFilterPage({
    super.key,
    required this.allQuotes,
    this.initialPeriod,
    this.initialStartYear,
    this.initialEndYear,
  });

  @override
  State<BrowseByPeriodFilterPage> createState() =>
      _BrowseByPeriodFilterPageState();
}

class _BrowseByPeriodFilterPageState extends State<BrowseByPeriodFilterPage> {
  late int _startYear;
  late int _endYear;
  String? _selectedPeriod;
  List<AuthorInfo> _authors = [];
  bool _isSubmitting = false;
  Timer? _rangeDebounce;

  @override
  void initState() {
    super.initState();

    // Check for route arguments first
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final args =
          ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
      if (args != null && mounted) {
        final selectedPeriod = args['selectedPeriod'] as String?;
        final startYear = args['startYear'] as int?;
        final endYear = args['endYear'] as int?;

        if (selectedPeriod != null && startYear != null && endYear != null) {
          setState(() {
            _startYear = startYear;
            _endYear = endYear;
            _selectedPeriod = selectedPeriod;
          });
          _updateAuthors();
          return;
        }
      }
    });

    // Initialize with provided values or defaults
    if (widget.initialPeriod != null) {
      final period = PeriodCatalog.getPeriodByName(widget.initialPeriod!);
      if (period != null) {
        _startYear = period.startYear;
        _endYear = period.endYear;
        _selectedPeriod = period.name;
      } else {
        _initializeDefaults();
      }
    } else if (widget.initialStartYear != null &&
        widget.initialEndYear != null) {
      _startYear = widget.initialStartYear!;
      _endYear = widget.initialEndYear!;
      _selectedPeriod = null;
    } else {
      _initializeDefaults();
    }

    _updateAuthors();
    Analytics.instance.logEvent('browse_period.opened');
  }

  void _initializeDefaults() {
    // Default to Modernism period
    final defaultPeriod = PeriodCatalog.getPeriodByName('Modernism')!;
    _startYear = defaultPeriod.startYear;
    _endYear = defaultPeriod.endYear;
    _selectedPeriod = defaultPeriod.name;
  }

  @override
  void dispose() {
    _rangeDebounce?.cancel();
    super.dispose();
  }

  void _updateAuthors() {
    final filteredQuotes = PeriodCatalog.getQuotesForRange(
      widget.allQuotes,
      _startYear,
      _endYear,
    );

    // Group authors by name and collect their info
    final authorMap = <String, AuthorInfo>{};

    for (final quote in filteredQuotes) {
      final authorName = quote.authorName;

      if (authorMap.containsKey(authorName)) {
        authorMap[authorName]!.quoteCount++;
      } else {
        authorMap[authorName] = AuthorInfo(
          name: authorName,
          birthYear: quote.authorBirth,
          deathYear: quote.authorDeath,
          quoteCount: 1,
          isSelected: true,
        );
      }
    }

    setState(() {
      _authors = authorMap.values.toList()
        ..sort((a, b) {
          // Sort by birth year if available, then by name
          if (a.birthYear != null && b.birthYear != null) {
            return a.birthYear!.compareTo(b.birthYear!);
          }
          return a.name.compareTo(b.name);
        });
    });
  }

  void _selectPeriod(String periodName) {
    final period = PeriodCatalog.getPeriodByName(periodName);
    if (period != null) {
      setState(() {
        _selectedPeriod = periodName;
        _startYear = period.startYear;
        _endYear = period.endYear;
      });
      _updateAuthors();
      Analytics.instance.logEvent('browse_period.select_preset', {
        'period': periodName,
      });
    }
  }

  void _setCustomRange(int startYear, int endYear) {
    setState(() {
      _startYear = startYear;
      _endYear = endYear;
      _selectedPeriod = null; // Clear preset selection for custom range
    });
    _updateAuthors();
    Analytics.instance.logEvent('browse_period.custom_range', {
      'start': startYear,
      'end': endYear,
    });
  }

  void _applyFilter() {
    if (_isSubmitting) return;
    setState(() {
      _isSubmitting = true;
    });
    final selectedAuthors = _authors
        .where((author) => author.isSelected)
        .map((author) => author.name)
        .toSet();

    Analytics.instance.logEvent('browse_period.filter_applied', {
      'start_year': _startYear,
      'end_year': _endYear,
      'selected_authors': selectedAuthors.length,
    });

    // Return the filter data (like browse by author/tags pattern)
    // Defer pop to next frame to avoid Navigator re-entrancy (_debugLocked)
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        Navigator.of(context).pop({
          'period_filter': {
            'period_name': _selectedPeriod ?? '$_startYear–$_endYear',
            'start_year': _startYear,
            'end_year': _endYear,
            'selected_authors': selectedAuthors,
          },
        });
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text(
          'Browse by Period',
          style: TextStyle(
            color: Theme.of(context).primaryColor,
            fontFamily: 'EBGaramond',
          ),
        ),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        scrolledUnderElevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      body: Column(
        children: [
          // Header with subtitle
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Select a period or set a custom year range',
                  style: TextStyle(
                    fontSize: 16,
                    color: Theme.of(context).primaryColor.withOpacity(0.7),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  '$_startYear–$_endYear',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    color: Theme.of(context).primaryColor,
                  ),
                ),
              ],
            ),
          ),

          // Preset chips
          _buildPresetChips(),

          const SizedBox(height: 16),

          // Custom range slider
          _buildRangeSlider(lbTheme),

          const SizedBox(height: 24),

          // Authors section header
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Authors (${_authors.length})',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                    color: Theme.of(context).primaryColor,
                  ),
                ),
                Row(
                  children: [
                    TextButton(
                      onPressed: () {
                        setState(() {
                          for (var author in _authors) {
                            author.isSelected = true;
                          }
                        });
                      },
                      child: const Text('Select All'),
                    ),
                    TextButton(
                      onPressed: () {
                        setState(() {
                          for (var author in _authors) {
                            author.isSelected = false;
                          }
                        });
                      },
                      child: const Text('Unselect All'),
                    ),
                  ],
                ),
              ],
            ),
          ),

          // Authors list
          Expanded(child: _buildAuthorsList()),
        ],
      ),

      // Go button
      bottomNavigationBar: _buildGoButton(lbTheme),
    );
  }

  Widget _buildPresetChips() {
    return Container(
      height: 50,
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: PeriodCatalog.periods.map((period) {
          final isSelected = _selectedPeriod == period.name;

          return Container(
            margin: const EdgeInsets.only(right: 8),
            child: FilterChip(
              label: Text(period.name),
              selected: isSelected,
              onSelected: (selected) => _selectPeriod(period.name),
              backgroundColor: Theme.of(context).cardColor,
              selectedColor: Theme.of(context).primaryColor.withOpacity(0.2),
              labelStyle: TextStyle(
                color: isSelected
                    ? Theme.of(context).primaryColor
                    : Theme.of(context).primaryColor.withOpacity(0.7),
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
              ),
              side: BorderSide(
                color: isSelected
                    ? Theme.of(context).primaryColor
                    : Theme.of(context).primaryColor.withOpacity(0.3),
                width: isSelected ? 2 : 1,
              ),
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildRangeSlider(LBTheme? lbTheme) {
    return Container(
      padding: const EdgeInsets.all(16),
      margin: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: lbTheme?.controlSurface ?? Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: lbTheme?.controlBorder ?? Colors.grey.shade300,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Custom Year Range',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: Theme.of(context).primaryColor,
            ),
          ),
          const SizedBox(height: 16),
          RangeSlider(
            values: RangeValues(_startYear.toDouble(), _endYear.toDouble()),
            min: PeriodCatalog.minYear.toDouble(),
            max: PeriodCatalog.maxYear.toDouble(),
            divisions: (PeriodCatalog.maxYear - PeriodCatalog.minYear) ~/ 10,
            labels: RangeLabels(_startYear.toString(), _endYear.toString()),
            onChanged: (values) {
              _rangeDebounce?.cancel();
              _rangeDebounce = Timer(const Duration(milliseconds: 150), () {
                if (mounted) {
                  _setCustomRange(values.start.round(), values.end.round());
                }
              });
            },
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                PeriodCatalog.minYear.toString(),
                style: TextStyle(
                  fontSize: 12,
                  color: Theme.of(context).primaryColor.withOpacity(0.7),
                ),
              ),
              Text(
                PeriodCatalog.maxYear.toString(),
                style: TextStyle(
                  fontSize: 12,
                  color: Theme.of(context).primaryColor.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildAuthorsList() {
    if (_authors.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.person_off_outlined,
              size: 48,
              color: Theme.of(context).primaryColor.withOpacity(0.5),
            ),
            const SizedBox(height: 16),
            Text(
              'No authors found for this period',
              style: TextStyle(
                fontSize: 16,
                color: Theme.of(context).primaryColor.withOpacity(0.7),
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Try adjusting your date range',
              style: TextStyle(
                fontSize: 14,
                color: Theme.of(context).primaryColor.withOpacity(0.5),
              ),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: _authors.length,
      itemBuilder: (context, index) {
        final author = _authors[index];

        return CheckboxListTile(
          value: author.isSelected,
          onChanged: (value) {
            setState(() {
              author.isSelected = value ?? false;
            });
          },
          title: Text(
            author.name,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: Theme.of(context).primaryColor,
            ),
          ),
          subtitle: Text(
            author.lifeSpan.isNotEmpty ? author.lifeSpan : 'Unknown dates',
            style: TextStyle(
              fontSize: 14,
              color: Theme.of(context).primaryColor.withOpacity(0.7),
            ),
          ),
          dense: true,
          contentPadding: EdgeInsets.zero,
          controlAffinity: ListTileControlAffinity.leading,
        );
      },
    );
  }

  Widget _buildGoButton(LBTheme? lbTheme) {
    final selectedCount = _authors.where((a) => a.isSelected).length;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: lbTheme?.controlSurface ?? Theme.of(context).cardColor,
        border: Border(
          top: BorderSide(
            color: lbTheme?.controlBorder ?? Colors.grey.shade300,
          ),
        ),
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              '$selectedCount authors selected',
              style: TextStyle(
                fontSize: 14,
                color: Theme.of(context).primaryColor.withOpacity(0.7),
              ),
            ),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              height: 50,
              child: ElevatedButton(
                onPressed: selectedCount > 0 && !_isSubmitting
                    ? _applyFilter
                    : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(
                    0xFF1976D2,
                  ), // Dark blue to match slider
                  foregroundColor: Colors.white,
                  disabledBackgroundColor: const Color(
                    0xFF1976D2,
                  ).withOpacity(0.3),
                  disabledForegroundColor: Colors.white.withOpacity(0.5),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: const Text(
                  'Go',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== browse_hub.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/browse.dart';
import 'package:quotes_app/browse_by_author.dart';
import 'package:quotes_app/browse_by_period_filter.dart';
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/utils/feature_gate.dart';
import 'package:quotes_app/widgets/settings_sheet.dart';
import 'package:quotes_app/widgets/tag_chip.dart';
import 'package:quotes_app/widgets/pro_badge.dart';
import 'package:quotes_app/utils/gate_overlay.dart';
import 'dart:ui';
import 'package:quotes_app/theme/lb_theme_extension.dart';

class BrowseHubPage extends StatefulWidget {
  final List<Quote> allQuotes;
  final List<Quote> favoriteQuotes;
  final Map<String, int> viewCounts;
  final Set<String> initialSelectedTags;
  final Set<String> initialSelectedAuthors;

  const BrowseHubPage({
    super.key,
    required this.allQuotes,
    required this.favoriteQuotes,
    required this.viewCounts,
    required this.initialSelectedTags,
    required this.initialSelectedAuthors,
  });

  @override
  State<BrowseHubPage> createState() => _BrowseHubPageState();
}

class _BrowseHubPageState extends State<BrowseHubPage> {
  bool _showAllCollections = false;
  bool _authorFeatureAllowed = false;
  bool _periodFeatureAllowed = false;

  @override
  void initState() {
    super.initState();
    _checkProStatus();
  }

  void _checkProStatus() async {
    final isPro = await EntitlementsService.instance.isPro();
    final hasAuthorPass = await EntitlementsService.instance.isFeatureActive(
      EntitlementsService.browseAuthor,
    );
    final hasPeriodPass = await EntitlementsService.instance.isFeatureActive(
      EntitlementsService.browsePeriod,
    );
    if (mounted) {
      setState(() {
        _authorFeatureAllowed = isPro || hasAuthorPass;
        _periodFeatureAllowed = isPro || hasPeriodPass;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      body: CustomScrollView(
        slivers: <Widget>[
          SliverAppBar(
            backgroundColor: Theme.of(context).scaffoldBackgroundColor,
            pinned: true,
            elevation: 0,
            scrolledUnderElevation: 0,
            titleSpacing: 16,
            toolbarHeight: 88,
            title: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('Browse'),
                const SizedBox(height: 4),
                Text(
                  'Explore by tags, author, period or custom packs',
                  style: textTheme.titleSmall?.copyWith(
                    color: colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
              ],
            ),
            actions: [
              IconButton(
                icon: const Icon(Icons.settings_outlined),
                onPressed: () => _showSettings(context),
              ),
            ],
          ),
          _buildSection(
            context,
            title: 'For You',
            subtitle: 'Shortcuts and your top tags',
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _buildButtonCard(
                  context,
                  icon: Icons.favorite_border,
                  title: 'Your Favorites',
                  subtitle: 'Revisit your favorite quotes',
                  onTap: () {
                    Navigator.of(context).pop({'favorites': true});
                  },
                ),
                const SizedBox(height: 12),
                _buildButtonCard(
                  context,
                  icon: Icons.sell_outlined,
                  title: 'Explore by Tags',
                  subtitle: 'Find quotes by specific tags',
                  onTap: () async {
                    final selectedTags = await Navigator.push<Set<String>>(
                      context,
                      MaterialPageRoute(
                        builder: (context) => BrowsePage(
                          allQuotes: widget.allQuotes,
                          initialSelectedTags: widget.initialSelectedTags,
                        ),
                      ),
                    );
                    if (selectedTags != null && context.mounted) {
                      Navigator.pop(context, {'tags': selectedTags});
                    }
                  },
                ),
                const SizedBox(height: 8),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Text(
                    'Your Top Tags',
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      color: Theme.of(
                        context,
                      ).colorScheme.onSurface.withOpacity(0.6),
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: _getTopTags().map((tag) {
                      return TagChip(
                        tag: tag,
                        isSelected: false,
                        onTap: (selectedTag) => _onTagTap(selectedTag),
                      );
                    }).toList(),
                  ),
                ),
              ],
            ),
          ),
          _buildSection(
            context,
            title: 'Authors',
            subtitle: 'Find all quotes from specific authors',
            showProBadge: !_authorFeatureAllowed,
            child: _buildButtonCard(
              context,
              icon: Icons.person_outline,
              title: 'Browse by Authors',
              subtitle: 'See every author in the library',
              showGradientBorder: !_authorFeatureAllowed,
              onTap: () {
                requireFeature(
                  context,
                  EntitlementsService.browseAuthor,
                  onAllowed: () async {
                    final result = await Navigator.push<Set<String>>(
                      context,
                      MaterialPageRoute(
                        builder: (_) => BrowseByAuthorPage(
                          allQuotes: widget.allQuotes,
                          initialSelectedAuthors: widget.initialSelectedAuthors,
                        ),
                      ),
                    );
                    if (result != null && context.mounted) {
                      Navigator.of(context).pop({'authors': result});
                    }
                  },
                  onBlocked: () => openPaywall(
                    context: context,
                    contextKey: 'browse_author',
                  ),
                );
              },
            ),
          ),
          _buildAuthorCollectionGrid(context),
          _buildPeriodsSection(context),
        ],
      ),
    );
  }

  Widget _buildSection(
    BuildContext context, {
    required String title,
    String? subtitle,
    required Widget child,
    bool showProBadge = false,
  }) {
    final cs = Theme.of(context).colorScheme;
    return SliverToBoxAdapter(
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        title,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                      if (showProBadge) ...[
                        const SizedBox(width: 8),
                        const ProBadge(),
                      ],
                    ],
                  ),
                  if (subtitle != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      subtitle,
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: cs.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ],
              ),
            ),
            const SizedBox(height: 12),
            child,
          ],
        ),
      ),
    );
  }

  Widget _buildButtonCard(
    BuildContext context, {
    required IconData icon,
    required dynamic title, // Can be String or Widget
    required String subtitle,
    required VoidCallback onTap,
    bool showGradientBorder = false,
  }) {
    final lbTheme = Theme.of(context).extension<LBTheme>();
    final cs = Theme.of(context).colorScheme;

    Widget cardContent = Card(
      margin: const EdgeInsets.symmetric(horizontal: 16),
      elevation: 1,
      color: lbTheme?.controlSurface,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: showGradientBorder
              ? Colors.transparent
              : (lbTheme?.controlBorder ??
                    Theme.of(context).colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Row(
            children: [
              Icon(
                icon,
                size: 32,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: title is String
                              ? Text(
                                  title,
                                  style: Theme.of(context).textTheme.titleMedium
                                      ?.copyWith(fontWeight: FontWeight.w600),
                                )
                              : title as Widget,
                        ),
                      ],
                    ),
                    const SizedBox(height: 2),
                    Text(
                      subtitle,
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(
                          context,
                        ).colorScheme.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),
              const Icon(Icons.chevron_right),
            ],
          ),
        ),
      ),
    );

    if (showGradientBorder) {
      return Container(
        margin: const EdgeInsets.symmetric(horizontal: 16),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          gradient: LinearGradient(
            colors: [
              cs.secondary.withOpacity(0.6),
              cs.primary.withOpacity(0.6),
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: Container(
          margin: const EdgeInsets.all(1), // Thin border width
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(11),
            color: lbTheme?.controlSurface ?? Theme.of(context).cardColor,
          ),
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(11),
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Row(
                children: [
                  Icon(
                    icon,
                    size: 32,
                    color: Theme.of(context).colorScheme.primary,
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Expanded(
                              child: title is String
                                  ? Text(
                                      title,
                                      style: Theme.of(context)
                                          .textTheme
                                          .titleMedium
                                          ?.copyWith(
                                            fontWeight: FontWeight.w600,
                                          ),
                                    )
                                  : title as Widget,
                            ),
                          ],
                        ),
                        const SizedBox(height: 2),
                        Text(
                          subtitle,
                          style: Theme.of(context).textTheme.bodyMedium
                              ?.copyWith(
                                color: Theme.of(
                                  context,
                                ).colorScheme.onSurface.withOpacity(0.6),
                              ),
                        ),
                      ],
                    ),
                  ),
                  const Icon(Icons.chevron_right),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return cardContent;
  }

  void _onTagTap(String tag) {
    Navigator.of(context).pop({
      'tags': {tag},
    });
  }

  static const List<Map<String, dynamic>> _authorCollections = [
    {
      'title': 'The Stoics',
      'subtitle': 'Timeless wisdom',
      'authors': [
        'Seneca',
        'Epictetus',
        'Marcus Aurelius',
        'Zeno of Citium',
        'Chrysippus',
        'Musonius Rufus',
        'Hierocles',
        'Posidonius',
      ],
    },
    {
      'title': 'The Romantics',
      'subtitle': 'Passionate verses',
      'authors': [
        'William Wordsworth',
        'John Keats',
        'Lord Byron',
        'Percy Bysshe Shelley',
        'Samuel Taylor Coleridge',
        'William Blake',
        'Mary Shelley',
        'Sir Walter Scott',
      ],
    },
    {
      'title': 'Modernist Voices',
      'subtitle': 'New perspectives',
      'authors': [
        'Virginia Woolf',
        'James Joyce',
        'T.S. Eliot',
        'Ezra Pound',
        'Gertrude Stein',
        'Marcel Proust',
        'Franz Kafka',
        'William Faulkner',
      ],
    },
    {
      'title': 'Women of Letters',
      'subtitle': 'Influential voices',
      'authors': [
        'Virginia Woolf',
        'Jane Austen',
        'Emily Dickinson',
        'Sylvia Plath',
        'George Eliot',
        'Charlotte Brontë',
        'Simone de Beauvoir',
        'Mary Wollstonecraft',
      ],
    },
    {
      'title': 'Russian Greats',
      'subtitle': 'Literary giants',
      'authors': [
        'Leo Tolstoy',
        'Fyodor Dostoevsky',
        'Anton Chekhov',
        'Alexander Pushkin',
        'Nikolai Gogol',
        'Ivan Turgenev',
        'Mikhail Bulgakov',
        'Boris Pasternak',
      ],
    },
    {
      'title': 'The Transcendentalists',
      'subtitle': 'Nature & individualism',
      'authors': [
        'Ralph Waldo Emerson',
        'Henry David Thoreau',
        'Walt Whitman',
        'Margaret Fuller',
        'Bronson Alcott',
        'Orestes Brownson',
        'Jones Very',
        'Theodore Parker',
      ],
    },
    {
      'title': 'Political Minds',
      'subtitle': 'Historic speeches',
      'authors': [
        'Winston Churchill',
        'Abraham Lincoln',
        'Mahatma Gandhi',
        'Nelson Mandela',
        'Martin Luther King Jr.',
        'Thomas Jefferson',
        'John Locke',
        'Niccolò Machiavelli',
      ],
    },
    {
      'title': 'Existential Currents',
      'subtitle': 'Meaning & absurdity',
      'authors': [
        'Albert Camus',
        'Jean-Paul Sartre',
        'Friedrich Nietzsche',
        'Søren Kierkegaard',
        'Simone de Beauvoir',
        'Martin Heidegger',
        'Fyodor Dostoevsky',
        'Franz Kafka',
      ],
    },
  ];

  static const List<Map<String, dynamic>> _periods = [
    {
      'title': 'Enlightenment',
      'range': '1680-1800',
      'start_year': 1680,
      'end_year': 1800,
    },
    {
      'title': 'Romanticism',
      'range': '1780-1850',
      'start_year': 1780,
      'end_year': 1850,
    },
    {
      'title': 'Victorian',
      'range': '1837-1901',
      'start_year': 1837,
      'end_year': 1901,
    },
    {
      'title': 'Modernism',
      'range': '1900-1945',
      'start_year': 1900,
      'end_year': 1945,
    },
    {
      'title': 'Contemporary',
      'range': '1945-Present',
      'start_year': 1945,
      'end_year': 2024,
    },
  ];

  List<Map<String, dynamic>> _getFilteredCollections() {
    final allAuthors = widget.allQuotes.map((q) => q.authorName).toSet();
    return _authorCollections.where((collection) {
      final authors = collection['authors'] as List<String>;
      return authors.any((author) => allAuthors.contains(author));
    }).toList();
  }

  Widget _buildPeriodsSection(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();
    final cs = Theme.of(context).colorScheme;
    return SliverToBoxAdapter(
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        'Periods',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                      if (!_periodFeatureAllowed) ...[
                        const SizedBox(width: 8),
                        const ProBadge(),
                      ],
                    ],
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Explore quotes from different historical periods',
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: cs.onSurface.withOpacity(0.6),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 12),
            SizedBox(
              height: 100,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: _periods.length,
                itemBuilder: (context, index) {
                  final period = _periods[index];
                  return SizedBox(
                    width: 160,
                    child: Card(
                      elevation: 0,
                      color: lbTheme?.controlSurface,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                        side: BorderSide(
                          color:
                              lbTheme?.controlBorder ??
                              Theme.of(
                                context,
                              ).colorScheme.outline.withOpacity(0.2),
                        ),
                      ),
                      child: InkWell(
                        onTap: () {
                          requireFeature(
                            context,
                            EntitlementsService.browsePeriod,
                            onAllowed: () async {
                              final result = await Navigator.push(
                                context,
                                MaterialPageRoute(
                                  builder: (context) =>
                                      BrowseByPeriodFilterPage(
                                        allQuotes: widget.allQuotes,
                                      ),
                                  settings: RouteSettings(
                                    arguments: {
                                      'selectedPeriod': period['title'],
                                      'startYear': period['start_year'],
                                      'endYear': period['end_year'],
                                    },
                                  ),
                                ),
                              );
                              // Handle the returned filter
                              if (result != null && context.mounted) {
                                Navigator.of(context).pop(result);
                              }
                            },
                            onBlocked: () => openPaywall(
                              context: context,
                              contextKey: 'browse_period',
                            ),
                          );
                        },
                        borderRadius: BorderRadius.circular(12),
                        child: Padding(
                          padding: const EdgeInsets.all(12.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Text(
                                period['title'] as String,
                                style: Theme.of(context).textTheme.titleMedium,
                              ),
                              const SizedBox(height: 4),
                              Text(
                                period['range'] as String,
                                style: Theme.of(context).textTheme.bodyMedium
                                    ?.copyWith(
                                      color: cs.onSurface.withOpacity(0.6),
                                    ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
            const SizedBox(height: 12),
            _buildButtonCard(
              context,
              icon: Icons.timeline_outlined,
              title: 'Browse by Period',
              subtitle: 'Open the period collections',
              showGradientBorder: !_periodFeatureAllowed,
              onTap: () {
                requireFeature(
                  context,
                  EntitlementsService.browsePeriod,
                  onAllowed: () async {
                    final result = await Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => BrowseByPeriodFilterPage(
                          allQuotes: widget.allQuotes,
                        ),
                      ),
                    );
                    // Handle the returned filter
                    if (result != null && context.mounted) {
                      Navigator.of(context).pop(result);
                    }
                  },
                  onBlocked: () => openPaywall(
                    context: context,
                    contextKey: 'browse_period',
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAuthorCollectionGrid(BuildContext context) {
    final filteredCollections = _getFilteredCollections();
    final collectionsToShow = _showAllCollections
        ? filteredCollections
        : filteredCollections.take(4).toList();

    return SliverToBoxAdapter(
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        'Author Collections',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                      if (!_authorFeatureAllowed) ...[
                        const SizedBox(width: 8),
                        const ProBadge(),
                      ],
                    ],
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Curated packs of writers',
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(
                        context,
                      ).colorScheme.onSurface.withOpacity(0.6),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 12),
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              padding: const EdgeInsets.symmetric(horizontal: 16),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
                childAspectRatio: 1.2,
              ),
              itemCount: collectionsToShow.length,
              itemBuilder: (context, index) {
                final collection = collectionsToShow[index];
                return _buildCollectionTile(
                  context,
                  collection,
                  _authorFeatureAllowed,
                );
              },
            ),
            if (filteredCollections.length > 4)
              Padding(
                padding: const EdgeInsets.only(top: 12.0, right: 16.0),
                child: Align(
                  alignment: Alignment.centerRight,
                  child: TextButton(
                    onPressed: () {
                      setState(() {
                        _showAllCollections = !_showAllCollections;
                      });
                    },
                    child: Text(
                      _showAllCollections
                          ? 'Show less'
                          : '+ ${filteredCollections.length - 4} more collections',
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildCollectionTile(
    BuildContext context,
    Map<String, dynamic> collection,
    bool isAllowed,
  ) {
    final lbTheme = Theme.of(context).extension<LBTheme>();
    final cs = Theme.of(context).colorScheme;
    final title = collection['title'] as String;
    final authors = List<String>.from(collection['authors'] as List);
    final preview = (authors.take(2).toList())..sort();
    final subtitle = 'Authors like ${preview.join(', ')}';

    final tileContent = SizedBox(
      width: double.infinity,
      child: Card(
        elevation: 0,
        color: lbTheme?.controlSurface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          side: BorderSide(
            color: lbTheme?.controlBorder ?? cs.outline.withOpacity(0.2),
          ),
        ),
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                cs.primary.withOpacity(0.05),
                cs.secondary.withOpacity(0.05),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(
                  title,
                  style: Theme.of(context).textTheme.titleMedium,
                  overflow: TextOverflow.ellipsis,
                  maxLines: 2,
                ),
                const SizedBox(height: 4),
                Text(
                  subtitle,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: cs.onSurface.withOpacity(0.7),
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 2,
                ),
              ],
            ),
          ),
        ),
      ),
    );

    return GateOverlay(
      allowed: isAllowed,
      onBlocked: () =>
          openPaywall(context: context, contextKey: 'browse_author'),
      child: GestureDetector(
        onTap: isAllowed
            ? () async {
                final result = await Navigator.push<Set<String>>(
                  context,
                  MaterialPageRoute(
                    builder: (_) => BrowseByAuthorPage(
                      allQuotes: widget.allQuotes,
                      initialSelectedAuthors: authors.toSet(),
                    ),
                  ),
                );
                if (result != null && context.mounted) {
                  Navigator.of(context).pop({'authors': result});
                }
              }
            : null,
        child: tileContent,
      ),
    );
  }

  List<String> _getTopTags() {
    final Map<String, int> tagCounts = {};

    // 1. From favorites
    if (widget.favoriteQuotes.isNotEmpty) {
      for (var quote in widget.favoriteQuotes) {
        for (var tag in quote.tags) {
          tagCounts[tag] = (tagCounts[tag] ?? 0) + 1;
        }
      }
    }

    // 2. Fallback to recently viewed
    if (tagCounts.isEmpty && widget.viewCounts.isNotEmpty) {
      // This is a simplified stand-in. A proper implementation
      // would need a list of recently viewed quote IDs.
      final viewedQuotes = widget.allQuotes
          .where((q) => widget.viewCounts.containsKey(q.id))
          .toList();
      viewedQuotes.sort(
        (a, b) => widget.viewCounts[b.id]!.compareTo(widget.viewCounts[a.id]!),
      );
      final recentQuotes = viewedQuotes.take(100);

      for (var quote in recentQuotes) {
        for (var tag in quote.tags) {
          tagCounts[tag] = (tagCounts[tag] ?? 0) + 1;
        }
      }
    }

    // 3. Fallback to corpus counts
    if (tagCounts.isEmpty) {
      for (var quote in widget.allQuotes) {
        for (var tag in quote.tags) {
          tagCounts[tag] = (tagCounts[tag] ?? 0) + 1;
        }
      }
    }

    final sortedTags = tagCounts.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));

    return sortedTags.map((e) => e.key).take(5).toList();
  }

  void _showSettings(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return const FractionallySizedBox(
          heightFactor: 0.75,
          child: SettingsSheet(),
        );
      },
    );
  }
}


===== learn_hub.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/author_quiz_page.dart';
import 'package:quotes_app/flashcards_page.dart';
import 'package:quotes_app/quiz_page.dart';
import 'package:quotes_app/quote_quiz_page.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/utils/feature_gate.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';
import 'package:quotes_app/learn/personalised_quiz_setup_page.dart';
import 'package:quotes_app/srs_service.dart';
import 'quote.dart';

class LearnHubPage extends StatefulWidget {
  final List<Quote> allQuotes;
  final List<Quote> favoriteQuotes;
  final Map<String, int> viewCounts;
  final Map<String, int> likeCounts;

  const LearnHubPage({
    super.key,
    required this.allQuotes,
    required this.favoriteQuotes,
    required this.viewCounts,
    required this.likeCounts,
  });

  @override
  State<LearnHubPage> createState() => _LearnHubPageState();
}

class _LearnHubPageState extends State<LearnHubPage> {
  bool _trainerAllowed = false; // Pro or Feature Pass: learn_trainer
  int _learnedQuotesCount = 0;
  int _favoritesCount = 0;

  @override
  void initState() {
    super.initState();
    _checkProStatus();
    _loadStats();
  }

  void _checkProStatus() async {
    final isPro = await EntitlementsService.instance.isPro();
    final hasTrainerPass = await EntitlementsService.instance.isFeatureActive(
      'learn_trainer',
    );
    if (!mounted) return;
    setState(() {
      _trainerAllowed = isPro || hasTrainerPass;
    });
  }

  Future<void> _loadStats() async {
    final learnedCount = await SRSService().getLearnedQuotesCount();
    setState(() {
      _learnedQuotesCount = learnedCount;
      _favoritesCount = widget.favoriteQuotes.length;
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        title: Text('Learn', style: theme.textTheme.titleLarge),
        backgroundColor: theme.scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: theme.primaryColor),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          _buildHeroQuizCard(context, locked: !_trainerAllowed),
          const SizedBox(height: 16),
          _buildStatsRow(context),
          const SizedBox(height: 24),
          _buildSectionHeader(
            context,
            title: 'Shortcuts',
            subtitle: 'Quick ways to start learning',
          ),
          const SizedBox(height: 12),
          GridView.count(
            crossAxisCount: 2,
            crossAxisSpacing: 16,
            mainAxisSpacing: 16,
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            children: [
              _buildLearnModeCard(
                context,
                icon: Icons.history,
                title: 'Recent Favorites',
                description: 'Practice your last 10 favorites',
                locked: !_trainerAllowed,
                onTap: () {
                  if (!_trainerAllowed) {
                    openPaywall(
                      context: context,
                      contextKey: 'learn_shortcuts',
                    );
                    return;
                  }
                  final recentQuotes = widget.favoriteQuotes.reversed
                      .take(10)
                      .toList();
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => QuizPage(
                        allQuotes: widget.allQuotes,
                        favoriteQuotes: recentQuotes,
                        viewCounts: widget.viewCounts,
                      ),
                    ),
                  );
                },
              ),
              _buildLearnModeCard(
                context,
                icon: Icons.star,
                title: 'Top Favorites',
                description: 'Practice your most-liked quotes',
                locked: !_trainerAllowed,
                onTap: () {
                  if (!_trainerAllowed) {
                    openPaywall(
                      context: context,
                      contextKey: 'learn_shortcuts',
                    );
                    return;
                  }
                  final sortedFavorites = List<Quote>.from(
                    widget.favoriteQuotes,
                  );
                  sortedFavorites.sort(
                    (a, b) => (widget.likeCounts[b.id] ?? 0).compareTo(
                      widget.likeCounts[a.id] ?? 0,
                    ),
                  );
                  final topQuotes = sortedFavorites.take(10).toList();
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => QuizPage(
                        allQuotes: widget.allQuotes,
                        favoriteQuotes: topQuotes,
                        viewCounts: widget.viewCounts,
                      ),
                    ),
                  );
                },
              ),
            ],
          ),
          const SizedBox(height: 24),
          _buildSectionHeader(
            context,
            title: 'Modes',
            subtitle: 'Choose how you want to practice',
          ),
          const SizedBox(height: 12),
          GridView.count(
            crossAxisCount: 2,
            crossAxisSpacing: 16,
            mainAxisSpacing: 16,
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            children: [
              _buildLearnModeCard(
                context,
                icon: Icons.style,
                title: 'Flashcards',
                description: 'Review quotes and authors',
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) =>
                          FlashcardsPage(favoriteQuotes: widget.favoriteQuotes),
                    ),
                  );
                },
              ),
              _buildLearnModeCard(
                context,
                icon: Icons.person_search,
                title: 'Author Details',
                description: 'Test your knowledge of authors',
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => AuthorQuizPage(
                        favoriteQuotes: widget.favoriteQuotes,
                        allQuotes: widget.allQuotes,
                      ),
                    ),
                  );
                },
              ),
              _buildLearnModeCard(
                context,
                icon: Icons.format_quote,
                title: 'Quote Quizzes',
                description: 'Identify authors and sources',
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => QuoteQuizPage(
                        favoriteQuotes: widget.favoriteQuotes,
                        allQuotes: widget.allQuotes,
                      ),
                    ),
                  );
                },
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(
    BuildContext context, {
    required String title,
    String? subtitle,
  }) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: theme.textTheme.titleLarge),
        if (subtitle != null) ...[
          const SizedBox(height: 4),
          Text(
            subtitle,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: cs.onSurface.withOpacity(0.6),
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildHeroQuizCard(BuildContext context, {bool locked = false}) {
    final cs = Theme.of(context).colorScheme;
    final cardContent = SizedBox(
      width: double.infinity,
      child: Card(
        clipBehavior: Clip.antiAlias,
        elevation: 4,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                cs.primary.withOpacity(0.1),
                cs.secondary.withOpacity(0.1),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: InkWell(
            onTap: () {
              requireFeature(
                context,
                'learn_trainer',
                onAllowed: () async {
                  final config = await Navigator.of(context)
                      .push<PersonalisedQuizConfig>(
                        MaterialPageRoute(
                          builder: (context) => PersonalisedQuizSetupPage(
                            favoriteQuotes: widget.favoriteQuotes,
                          ),
                        ),
                      );
                  if (config != null && mounted) {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => QuizPage(
                          allQuotes: widget.allQuotes,
                          favoriteQuotes: widget.favoriteQuotes
                              .where((q) => config.quoteIds.contains(q.id))
                              .toList(),
                          viewCounts: widget.viewCounts,
                        ),
                      ),
                    );
                  }
                },
                onBlocked: () =>
                    openPaywall(context: context, contextKey: 'learn_trainer'),
              );
            },
            child: Container(
              padding: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    cs.primary.withOpacity(0.85),
                    cs.secondary.withOpacity(0.85),
                  ],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.quiz, color: Colors.white, size: 40),
                  const SizedBox(height: 16),
                  Text(
                    'Personalised Quiz',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'A configurable challenge that spans authors, quotes, and sources.',
                    style: Theme.of(
                      context,
                    ).textTheme.bodyLarge?.copyWith(color: Colors.white70),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );

    if (!locked) return cardContent;

    return SizedBox(
      width: double.infinity,
      child: Stack(
        children: [
          cardContent,
          Positioned(
            top: 8,
            right: 8,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [Colors.purple, Colors.blue],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
                borderRadius: BorderRadius.circular(999),
              ),
              child: const Text(
                'PRO',
                style: TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 10,
                  letterSpacing: 0.4,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatsRow(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Row(
      children: [
        Expanded(
          child: _statChip(
            context,
            label: 'Quotes Learned',
            value: _learnedQuotesCount.toString(),
            icon: Icons.school,
            color: cs.primary,
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: _statChip(
            context,
            label: 'Total Favourites',
            value: _favoritesCount.toString(),
            icon: Icons.favorite,
            color: cs.primary,
          ),
        ),
      ],
    );
  }

  Widget _statChip(
    BuildContext context, {
    required String label,
    required String value,
    required IconData icon,
    required Color color,
  }) {
    final lb = Theme.of(context).extension<LBTheme>();
    return Container(
      decoration: BoxDecoration(
        color: (lb?.controlSurface) ?? Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color:
              (lb?.controlBorder) ??
              Theme.of(context).colorScheme.outline.withOpacity(0.2),
        ),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
      child: Row(
        children: [
          Container(
            decoration: BoxDecoration(
              color: color.withOpacity(0.15),
              borderRadius: BorderRadius.circular(8),
            ),
            padding: const EdgeInsets.all(8),
            child: Icon(icon, color: color),
          ),
          const SizedBox(width: 10),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: Theme.of(context).textTheme.bodySmall),
              Text(value, style: Theme.of(context).textTheme.titleMedium),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildLearnModeCard(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String description,
    required VoidCallback onTap,
    bool locked = false,
  }) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final lb = theme.extension<LBTheme>();

    final baseCard = SizedBox(
      width: double.infinity,
      child: Card(
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        color: (lb?.controlSurface) ?? theme.cardColor,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(16),
            gradient: LinearGradient(
              colors: [
                cs.primary.withOpacity(0.1),
                cs.secondary.withOpacity(0.1),
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(16),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Icon(
                    icon,
                    size: 36,
                    color: theme.primaryColor.withOpacity(0.9),
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(title, style: theme.textTheme.titleMedium),
                      const SizedBox(height: 4),
                      Text(
                        description,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: cs.onSurface.withOpacity(0.75),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );

    if (!locked) return baseCard;

    return Stack(
      children: [
        baseCard,
        Positioned(
          top: 8,
          right: 8,
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [Colors.purple, Colors.blue],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              borderRadius: BorderRadius.circular(999),
            ),
            child: const Text(
              'PRO',
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                fontSize: 10,
                letterSpacing: 0.4,
              ),
            ),
          ),
        ),
      ],
    );
  }
}


===== info_card.dart =====

import 'package:flutter/material.dart';

class InfoCard extends StatelessWidget {
  final String title;
  final String message;
  final List<Widget> actions;
  final Color? color;

  const InfoCard({
    super.key,
    required this.title,
    required this.message,
    this.actions = const [],
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      color: color ?? Theme.of(context).cardColor,
      margin: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 0,
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Icon(
              Icons.info_outline,
              color: Theme.of(context).primaryColor.withOpacity(0.7),
              size: 40,
            ),
            const SizedBox(height: 16),
            Text(
              title,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).primaryColor,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              message,
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                height: 1.5,
                color: Theme.of(context).colorScheme.onSurface,
              ),
            ),
            if (actions.isNotEmpty) ...[
              const SizedBox(height: 24),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: actions
                    .map(
                      (e) => Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 8.0),
                        child: e,
                      ),
                    )
                    .toList(),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

class GradientOutlinedButton extends StatelessWidget {
  final VoidCallback onPressed;
  final Widget child;
  final Gradient gradient;
  final double strokeWidth;
  final double borderRadius;
  final Color? backgroundColor;

  const GradientOutlinedButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.strokeWidth = 1.5,
    this.borderRadius = 30.0,
    this.gradient = const LinearGradient(
      colors: [Colors.purpleAccent, Colors.blueAccent],
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
    ),
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return DecoratedBox(
      decoration: BoxDecoration(
        gradient: gradient,
        borderRadius: BorderRadius.circular(borderRadius),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(borderRadius),
          onTap: onPressed,
          child: Container(
            margin: EdgeInsets.all(strokeWidth),
            padding: const EdgeInsets.symmetric(
              horizontal: 24.0,
              vertical: 12.0,
            ),
            decoration: BoxDecoration(
              color:
                  backgroundColor ?? Theme.of(context).scaffoldBackgroundColor,
              borderRadius: BorderRadius.circular(borderRadius - strokeWidth),
            ),
            child: DefaultTextStyle(
              style:
                  Theme.of(context).textTheme.labelLarge?.copyWith(
                    color: Theme.of(context).primaryColor,
                    fontWeight: FontWeight.w600,
                  ) ??
                  const TextStyle(),
              child: child,
            ),
          ),
        ),
      ),
    );
  }
}


===== learn/srs_session_screen.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/srs_service.dart';
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/learn/flashcard.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/utils/feature_gate.dart';

class SrsSessionScreen extends StatefulWidget {
  final List<Quote> allQuotes;
  final List<Quote> favoriteQuotes;

  const SrsSessionScreen({
    super.key,
    required this.allQuotes,
    required this.favoriteQuotes,
  });

  @override
  State<SrsSessionScreen> createState() => _SrsSessionScreenState();
}

class _SrsSessionScreenState extends State<SrsSessionScreen> {
  final SRSService _srsService = SRSService();
  List<String> _dueQuoteIds = [];
  int _currentIndex = 0;
  int _reviewsToday = 0;
  bool _capReached = false;

  @override
  void initState() {
    super.initState();
    Analytics.instance.logEvent(Analytics.learnSrsOpened);
    _loadDueQuotes();
  }

  Future<void> _loadDueQuotes() async {
    final dueQuoteIds = await _srsService.loadDue(DateTime.now());
    final canReviewMore = await _srsService.canReviewMore(DateTime.now());
    setState(() {
      _dueQuoteIds = dueQuoteIds;
      _capReached = !canReviewMore;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Spaced Repetition (${_dueQuoteIds.length} due)'),
      ),
      body: _capReached
          ? _buildCapReachedNudge()
          : (_dueQuoteIds.isEmpty ? _buildEmptyState() : _buildSession()),
    );
  }

  Widget _buildCapReachedNudge() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text('You\'ve reached your daily review limit!'),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: () {
              openPaywall(context: context, contextKey: 'srs_unlimited');
            },
            child: const Text('See options'),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text('No reviews due today!'),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: () {
              final favoriteQuoteIds = widget.favoriteQuotes
                  .map((q) => q.id)
                  .toSet();
              _srsService.addMany(favoriteQuoteIds);
              Analytics.instance.logEvent(Analytics.learnAddToSrs, {
                'count': favoriteQuoteIds.length,
                'source': 'favorites',
              });
              _loadDueQuotes();
            },
            child: const Text('Add from Favorites'),
          ),
        ],
      ),
    );
  }

  Widget _buildSession() {
    final quote = widget.allQuotes.firstWhere(
      (q) => q.id == _dueQuoteIds[_currentIndex],
    );
    return Flashcard(
      quote: quote,
      onAnswer: (correct) {
        _srsService.grade(quote.id, correct: correct, today: DateTime.now());
        setState(() {
          _reviewsToday++;
        });
        Analytics.instance.logEvent(Analytics.learnSrsGraded, {
          'correct': correct,
        });
        if (_currentIndex < _dueQuoteIds.length - 1) {
          setState(() {
            _currentIndex++;
          });
        } else {
          Analytics.instance.logEvent(Analytics.learnSrsFinished, {
            'reviewed': _dueQuoteIds.length,
            'remaining': 0,
          });
          _loadDueQuotes();
        }
      },
    );
  }
}


===== learn/flashcard.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quote.dart';

class Flashcard extends StatefulWidget {
  final Quote quote;
  final Function(bool) onAnswer;

  const Flashcard({super.key, required this.quote, required this.onAnswer});

  @override
  State<Flashcard> createState() => _FlashcardState();
}

class _FlashcardState extends State<Flashcard> {
  bool _showAnswer = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(widget.quote.text),
        const SizedBox(height: 16),
        if (_showAnswer) ...[
          Text(widget.quote.authorName),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              ElevatedButton(
                onPressed: () => widget.onAnswer(true),
                child: const Text('I was right'),
              ),
              ElevatedButton(
                onPressed: () => widget.onAnswer(false),
                child: const Text('I was wrong'),
              ),
            ],
          ),
        ] else ...[
          ElevatedButton(
            onPressed: () {
              setState(() {
                _showAnswer = true;
              });
            },
            child: const Text('Show Answer'),
          ),
        ],
      ],
    );
  }
}


===== learn/personalised_quiz_setup_page.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/quote.dart';

class PersonalisedQuizConfig {
  final int length;
  final Set<String> quoteIds;

  PersonalisedQuizConfig({required this.length, required this.quoteIds});
}

class PersonalisedQuizSetupPage extends StatefulWidget {
  final List<Quote> favoriteQuotes;

  const PersonalisedQuizSetupPage({super.key, required this.favoriteQuotes});

  @override
  State<PersonalisedQuizSetupPage> createState() =>
      _PersonalisedQuizSetupPageState();
}

class _PersonalisedQuizSetupPageState extends State<PersonalisedQuizSetupPage> {
  int _length = 10;
  final Set<String> _selectedQuoteIds = {};
  final Set<String> _selectedTags = {};
  final Set<String> _selectedPeriods = {};

  @override
  void initState() {
    super.initState();
    _preselectQuotes();
  }

  void _preselectQuotes() {
    final filteredQuotes = _getFilteredQuotes();
    filteredQuotes.shuffle();
    setState(() {
      _selectedQuoteIds.clear();
      _selectedQuoteIds.addAll(filteredQuotes.take(_length).map((q) => q.id));
    });
  }

  List<Quote> _getFilteredQuotes() {
    return widget.favoriteQuotes.where((quote) {
      final tagMatch =
          _selectedTags.isEmpty ||
          quote.tags.any((tag) => _selectedTags.contains(tag));
      final periodMatch =
          _selectedPeriods.isEmpty || _selectedPeriods.contains(quote.period);
      return tagMatch && periodMatch;
    }).toList();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Configure Quiz'),
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        elevation: 0,
        iconTheme: IconThemeData(color: Theme.of(context).primaryColor),
      ),
      body: ListView(
        padding: const EdgeInsets.all(12.0),
        children: [
          _buildLengthSelector(),
          const SizedBox(height: 12),
          _buildFilterSection(
            title: 'Filter by Tag',
            chips: [
              'Any',
              ...widget.favoriteQuotes.expand((q) => q.tags).toSet(),
            ],
            selectedValues: _selectedTags,
            onSelected: (value) {
              setState(() {
                if (value == 'Any') {
                  _selectedTags.clear();
                } else {
                  if (_selectedTags.contains(value)) {
                    _selectedTags.remove(value);
                  } else {
                    _selectedTags.add(value);
                  }
                }
              });
              _preselectQuotes();
            },
          ),
          const SizedBox(height: 8),
          _buildFilterSection(
            title: 'Filter by Period',
            chips: [
              'Any',
              'Enlightenment',
              'Romanticism',
              'Victorian',
              'Modernism',
              'Contemporary',
            ],
            selectedValues: _selectedPeriods,
            onSelected: (value) {
              setState(() {
                if (value == 'Any') {
                  _selectedPeriods.clear();
                } else {
                  if (_selectedPeriods.contains(value)) {
                    _selectedPeriods.remove(value);
                  } else {
                    _selectedPeriods.add(value);
                  }
                }
              });
              _preselectQuotes();
            },
          ),
          const SizedBox(height: 12),
          _buildQuoteSelector(),
        ],
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.all(16.0),
        child: ElevatedButton(
          style: ElevatedButton.styleFrom(
            backgroundColor: Theme.of(context).primaryColor,
            foregroundColor: Theme.of(context).colorScheme.onPrimary,
            padding: const EdgeInsets.symmetric(vertical: 16),
            textStyle: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
          onPressed: () {
            final config = PersonalisedQuizConfig(
              length: _selectedQuoteIds.length,
              quoteIds: _selectedQuoteIds,
            );
            Navigator.of(context).pop(config);
          },
          child: const Text('Start Quiz'),
        ),
      ),
    );
  }

  Widget _buildLengthSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Length', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8.0,
          children:
              [5, 10, 20].map((length) {
                bool canSelect = widget.favoriteQuotes.length >= length;
                return ChoiceChip(
                  label: Text('$length Questions'),
                  selected: _length == length,
                  onSelected: canSelect
                      ? (selected) {
                          if (selected) {
                            setState(() => _length = length);
                            _preselectQuotes();
                          }
                        }
                      : null,
                );
              }).toList()..add(
                ChoiceChip(
                  label: const Text('Custom'),
                  selected: ![5, 10, 20].contains(_selectedQuoteIds.length),
                  onSelected: (selected) {},
                ),
              ),
        ),
      ],
    );
  }

  Widget _buildFilterSection({
    required String title,
    required List<String> chips,
    required Set<String> selectedValues,
    required ValueChanged<String> onSelected,
  }) {
    return ExpansionTile(
      title: Text(title),
      children: [
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Wrap(
            spacing: 8.0,
            children: chips.map((value) {
              final bool isAny = value == 'Any';
              final bool isSelected = isAny
                  ? selectedValues.isEmpty
                  : selectedValues.contains(value);
              return FilterChip(
                label: Text(value),
                selected: isSelected,
                onSelected: (selected) {
                  onSelected(value);
                },
              );
            }).toList(),
          ),
        ),
      ],
    );
  }

  Widget _buildQuoteSelector() {
    final selectedQuotes = widget.favoriteQuotes
        .where((q) => _selectedQuoteIds.contains(q.id))
        .toList();
    final unselectedQuotes = widget.favoriteQuotes
        .where((q) => !_selectedQuoteIds.contains(q.id))
        .toList();

    return Column(
      children: [
        ExpansionTile(
          title: Text('Selected Quotes (${selectedQuotes.length})'),
          initiallyExpanded: true,
          children: selectedQuotes
              .map((quote) => _buildQuoteTile(quote))
              .toList(),
        ),
        ExpansionTile(
          title: const Text('Add from Favorites'),
          children: unselectedQuotes
              .map((quote) => _buildQuoteTile(quote))
              .toList(),
        ),
      ],
    );
  }

  Widget _buildQuoteTile(Quote quote) {
    return CheckboxListTile(
      title: Text(quote.text, maxLines: 2),
      value: _selectedQuoteIds.contains(quote.id),
      onChanged: (value) {
        setState(() {
          if (value ?? false) {
            _selectedQuoteIds.add(quote.id);
          } else {
            _selectedQuoteIds.remove(quote.id);
          }
        });
      },
    );
  }
}


===== utils/feature_gate.dart =====

import 'package:flutter/material.dart';
import '../services/entitlements_service.dart';
import '../services/purchase_service.dart';
import '../widgets/paywall.dart';

Future<void> requireFeature(
  BuildContext ctx,
  String featureKey, {
  required VoidCallback onAllowed,
  required VoidCallback onBlocked,
}) async {
  final isAllowed = await EntitlementsService.instance.isFeatureActive(
    featureKey,
  );

  if (isAllowed) {
    onAllowed();
  } else {
    onBlocked();
  }
}

/// Opens the paywall with the specified context
Future<bool?> openPaywall({
  required BuildContext context,
  required String contextKey,
  PurchasePlan initialPlan = PurchasePlan.annual,
}) async {
  return await showModalBottomSheet<bool>(
    context: context,
    isScrollControlled: true,
    backgroundColor: Colors.transparent,
    builder: (context) {
      return FractionallySizedBox(
        heightFactor: 0.9,
        child: Paywall(contextKey: contextKey, initialPlan: initialPlan),
      );
    },
  );
}


===== utils/share_quote.dart =====

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:screenshot/screenshot.dart';
import 'package:share_plus/share_plus.dart';
import '../quote.dart';

Future<void> shareQuoteAsImage(
  BuildContext context,
  Quote quote,
  bool isDarkMode,
) async {
  final screenshotController = ScreenshotController();

  final image = await screenshotController.captureFromWidget(
    _buildSharableQuoteCard(quote, isDarkMode),
    pixelRatio: MediaQuery.of(context).devicePixelRatio,
    context: context,
  );

  final directory = await getApplicationDocumentsDirectory();
  final imagePath = await File('${directory.path}/quote.png').create();
  await imagePath.writeAsBytes(image);

  await Share.shareXFiles([XFile(imagePath.path)]);
}

Widget _buildSharableQuoteCard(Quote quote, bool isDarkMode) {
  return Material(
    color: isDarkMode ? Colors.black : const Color.fromARGB(255, 240, 234, 225),
    child: Container(
      padding: const EdgeInsets.all(32.0),
      child: _buildQuoteCard(quote, isDarkMode),
    ),
  );
}

Widget _buildQuoteCard(Quote quote, bool isDarkMode) {
  // This is a simplified version of the quote card for sharing.
  // It's not interactive, so we don't need all the callbacks.
  return Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: <Widget>[
      Text(
        quote.text,
        style: TextStyle(
          fontSize: 24,
          fontWeight: FontWeight.w500,
          fontFamily: "EBGaramond",
          color: isDarkMode ? Colors.white : Colors.black,
          height: 1.4,
        ),
        textAlign: TextAlign.left,
      ),
      const SizedBox(height: 20.0),
      Text(
        '— ${quote.authorInfo}',
        style: TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.w300,
          color: const Color.fromARGB(255, 166, 165, 165),
          fontFamily: "EBGaramond",
        ),
        textAlign: TextAlign.right,
      ),
      if (quote.displaySource.isNotEmpty) ...[
        const SizedBox(height: 8.0),
        Text(
          quote.displaySource,
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w300,
            color: const Color.fromARGB(255, 140, 140, 140),
            fontFamily: "EBGaramond",
            fontStyle: FontStyle.italic,
          ),
          textAlign: TextAlign.right,
        ),
      ],
    ],
  );
}


===== utils/gate_overlay.dart =====

import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:quotes_app/widgets/pro_badge.dart';

class GateOverlay extends StatelessWidget {
  final Widget child;
  final bool allowed;
  final VoidCallback onBlocked;
  final bool showProBadge;
  final double blurSigma;

  const GateOverlay({
    super.key,
    required this.child,
    required this.allowed,
    required this.onBlocked,
    this.showProBadge = true,
    this.blurSigma = 2.0,
  });

  @override
  Widget build(BuildContext context) {
    if (allowed) {
      return child;
    }

    return Stack(
      children: [
        // Original content with blur
        ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: blurSigma, sigmaY: blurSigma),
            child: Container(
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.06),
                borderRadius: BorderRadius.circular(12),
              ),
              child: child,
            ),
          ),
        ),

        // Tap detector for paywall
        Positioned.fill(
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: onBlocked,
              borderRadius: BorderRadius.circular(12),
              child: Container(),
            ),
          ),
        ),

        // PRO badge
        if (showProBadge) Positioned(top: 8, right: 8, child: const ProBadge()),
      ],
    );
  }
}


===== utils/system_ui.dart =====

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

void setSystemUIOverlayStyle(bool isDarkMode) {
  SystemChrome.setSystemUIOverlayStyle(
    SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: isDarkMode ? Brightness.light : Brightness.dark,
    ),
  );
}


===== utils/font_size_helpers.dart =====

import 'package:flutter/material.dart';

double getFontSize(String text) {
  if (text.length > 300) return 20.0;
  if (text.length > 200) return 22.0;
  if (text.length > 120) return 24.0;
  if (text.length > 80) return 26.0;
  return 28.0;
}

double getSourceFontSize(String source) {
  if (source.length > 100) return 15.0;
  if (source.length > 80) return 16.0;
  if (source.length > 60) return 17.0;
  return 18.0;
}


===== utils/membership_feedback.dart =====

import 'dart:io';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';

class MembershipFeedback {
  static Future<void> showMessage(
    BuildContext context, {
    required String title,
    required String message,
  }) {
    final theme = Theme.of(context);
    final actionColor = theme.colorScheme.primary;
    final dialog = Platform.isIOS
        ? CupertinoAlertDialog(
            title: Text(title, style: theme.textTheme.titleMedium),
            content: Text(message, style: theme.textTheme.bodyMedium),
            actions: [
              CupertinoDialogAction(
                onPressed: () => Navigator.of(context, rootNavigator: true).pop(),
                isDefaultAction: true,
                child: Text('OK', style: TextStyle(color: actionColor)),
              ),
            ],
          )
        : AlertDialog(
            title: Text(title, style: theme.textTheme.titleMedium),
            content: Text(message, style: theme.textTheme.bodyMedium),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context, rootNavigator: true).pop(),
                child: Text('OK', style: TextStyle(color: actionColor)),
              ),
            ],
          );

    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (_) => dialog,
    );
  }

  static Widget loadingOverlay(
    BuildContext context, {
    required bool isLoading,
    required Widget child,
  }) {
    if (!isLoading) return child;
    final theme = Theme.of(context);
    final lbTheme = theme.extension<LBTheme>();
    final overlayColor = lbTheme?.controlSurface.withOpacity(0.86) ??
        theme.colorScheme.surface.withOpacity(0.86);

    return Stack(
      children: [
        child,
        Positioned.fill(
          child: Container(
            color: overlayColor,
            alignment: Alignment.center,
            child: const SizedBox(
              width: 36,
              height: 36,
              child: CircularProgressIndicator(strokeWidth: 3),
            ),
          ),
        ),
      ],
    );
  }
}


===== models/period_catalog.dart =====

import 'package:quotes_app/quote.dart';

class PeriodRange {
  final String name;
  final int startYear;
  final int endYear;
  final String? description;

  const PeriodRange({
    required this.name,
    required this.startYear,
    required this.endYear,
    this.description,
  });

  bool containsYear(int year) {
    return year >= startYear && year <= endYear;
  }

  String get displayRange => '$startYear–$endYear';
}

class PeriodCatalog {
  static const List<PeriodRange> periods = [
    PeriodRange(
      name: 'Enlightenment',
      startYear: 1680,
      endYear: 1800,
      description: 'Age of Reason and scientific revolution',
    ),
    PeriodRange(
      name: 'Romanticism',
      startYear: 1780,
      endYear: 1850,
      description: 'Emotion, nature, and individualism',
    ),
    PeriodRange(
      name: 'Victorian',
      startYear: 1837,
      endYear: 1901,
      description: 'British cultural dominance and moral values',
    ),
    PeriodRange(
      name: 'Modernism',
      startYear: 1900,
      endYear: 1945,
      description: 'Experimental forms and breaking tradition',
    ),
    PeriodRange(
      name: 'Postmodern',
      startYear: 1945,
      endYear: 1990,
      description: 'Questioning truth and embracing plurality',
    ),
    PeriodRange(
      name: 'Contemporary',
      startYear: 1990,
      endYear: 2024,
      description: 'Digital age and global interconnectedness',
    ),
  ];

  static const int minYear = 1600;
  static const int maxYear = 2024;

  /// Infer period from year if not explicitly set
  static String? inferPeriodFromYear(int? year) {
    if (year == null) return null;

    for (final period in periods) {
      if (period.containsYear(year)) {
        return period.name;
      }
    }

    // Handle edge cases for very old or very new works
    if (year < minYear) return 'Pre-Enlightenment';
    if (year > maxYear) return 'Future';

    return null;
  }

  /// Get period range by name
  static PeriodRange? getPeriodByName(String name) {
    try {
      return periods.firstWhere(
        (p) => p.name.toLowerCase() == name.toLowerCase(),
      );
    } catch (e) {
      return null;
    }
  }

  /// Get quotes count for a period range
  static int getQuoteCountForRange(
    List<Quote> quotes,
    int startYear,
    int endYear,
  ) {
    return quotes.where((quote) {
      final year = quote.year;
      if (year != null) {
        return year >= startYear && year <= endYear;
      }
      // Check if quote has explicit period that matches our range
      final quotePeriod = quote.period;
      if (quotePeriod != null) {
        final periodRange = getPeriodByName(quotePeriod);
        if (periodRange != null) {
          // Check if periods overlap
          return !(periodRange.endYear < startYear ||
              periodRange.startYear > endYear);
        }
      }
      return false;
    }).length;
  }

  /// Get quotes for a specific period range
  static List<Quote> getQuotesForRange(
    List<Quote> quotes,
    int startYear,
    int endYear,
  ) {
    return quotes.where((quote) {
      final year = quote.year;
      if (year != null) {
        return year >= startYear && year <= endYear;
      }
      // Check if quote has explicit period that matches our range
      final quotePeriod = quote.period;
      if (quotePeriod != null) {
        final periodRange = getPeriodByName(quotePeriod);
        if (periodRange != null) {
          // Check if periods overlap
          return !(periodRange.endYear < startYear ||
              periodRange.startYear > endYear);
        }
      }
      return false;
    }).toList();
  }
}


===== models/notification_prefs.dart =====

import 'package:flutter/material.dart';

class NotificationPrefs {
  final List<TimeOfDay> times; // sorted, unique, local time
  final Set<String> authors; // optional; empty = no author filter
  final Set<String> tags; // optional; empty = no tag filter
  final int? startYear; // optional
  final int? endYear; // optional
  final Set<int> weekdays; // 1=Mon … 7=Sun; default all 7
  final int dailyCap; // guards double scheduling; default times.length
  final int lookbackDays; // de-duplicate within N days; default 14
  final int version; // schema version

  const NotificationPrefs({
    required this.times,
    this.authors = const {},
    this.tags = const {},
    this.startYear,
    this.endYear,
    this.weekdays = const {1, 2, 3, 4, 5, 6, 7},
    this.dailyCap = 2,
    this.lookbackDays = 14,
    this.version = 1,
  });

  /// Default free tier preferences: 2 times per day, no filters
  static NotificationPrefs defaultFree() {
    return const NotificationPrefs(
      times: [
        TimeOfDay(hour: 9, minute: 0), // 09:00
        TimeOfDay(hour: 20, minute: 0), // 20:00
      ],
      dailyCap: 2,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'times': times
          .map(
            (t) =>
                '${t.hour.toString().padLeft(2, '0')}:${t.minute.toString().padLeft(2, '0')}',
          )
          .toList(),
      'authors': authors.toList(),
      'tags': tags.toList(),
      'startYear': startYear,
      'endYear': endYear,
      'weekdays': weekdays.toList(),
      'dailyCap': dailyCap,
      'lookbackDays': lookbackDays,
      'version': version,
    };
  }

  static NotificationPrefs fromJson(Map<String, dynamic> json) {
    final timeStrings = List<String>.from(json['times'] ?? []);
    final times = timeStrings.map((timeStr) {
      final parts = timeStr.split(':');
      return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
    }).toList();

    return NotificationPrefs(
      times: times,
      authors: Set<String>.from(json['authors'] ?? []),
      tags: Set<String>.from(json['tags'] ?? []),
      startYear: json['startYear'],
      endYear: json['endYear'],
      weekdays: Set<int>.from(json['weekdays'] ?? [1, 2, 3, 4, 5, 6, 7]),
      dailyCap: json['dailyCap'] ?? 2,
      lookbackDays: json['lookbackDays'] ?? 14,
      version: json['version'] ?? 1,
    );
  }

  NotificationPrefs copyWith({
    List<TimeOfDay>? times,
    Set<String>? authors,
    Set<String>? tags,
    int? startYear,
    int? endYear,
    Set<int>? weekdays,
    int? dailyCap,
    int? lookbackDays,
    int? version,
  }) {
    return NotificationPrefs(
      times: times ?? this.times,
      authors: authors ?? this.authors,
      tags: tags ?? this.tags,
      startYear: startYear ?? this.startYear,
      endYear: endYear ?? this.endYear,
      weekdays: weekdays ?? this.weekdays,
      dailyCap: dailyCap ?? this.dailyCap,
      lookbackDays: lookbackDays ?? this.lookbackDays,
      version: version ?? this.version,
    );
  }

  /// Check if this is effectively the default free configuration
  bool get isDefaultFree {
    return times.length == 2 &&
        times.contains(const TimeOfDay(hour: 9, minute: 0)) &&
        times.contains(const TimeOfDay(hour: 20, minute: 0)) &&
        authors.isEmpty &&
        tags.isEmpty &&
        startYear == null &&
        endYear == null &&
        weekdays.length == 7;
  }

  /// Get a human-readable description of the schedule
  String get scheduleDescription {
    if (times.isEmpty) return 'No reminders';
    if (times.length == 1) return '1/day';
    return '${times.length}/day';
  }

  /// Get formatted times string for display
  String get timesDisplay {
    if (times.isEmpty) return 'None';
    return times
        .map(
          (t) =>
              '${t.hour.toString().padLeft(2, '0')}:${t.minute.toString().padLeft(2, '0')}',
        )
        .join(' • ');
  }

  /// Check if notifications should be sent on a specific weekday
  bool isActiveOnWeekday(int weekday) {
    return weekdays.contains(weekday);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! NotificationPrefs) return false;

    return _listEquals(times, other.times) &&
        _setEquals(authors, other.authors) &&
        _setEquals(tags, other.tags) &&
        startYear == other.startYear &&
        endYear == other.endYear &&
        _setEquals(weekdays, other.weekdays) &&
        dailyCap == other.dailyCap &&
        lookbackDays == other.lookbackDays &&
        version == other.version;
  }

  @override
  int get hashCode {
    return Object.hash(
      Object.hashAll(times),
      Object.hashAll(authors),
      Object.hashAll(tags),
      startYear,
      endYear,
      Object.hashAll(weekdays),
      dailyCap,
      lookbackDays,
      version,
    );
  }

  static bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  static bool _setEquals<T>(Set<T> a, Set<T> b) {
    if (a.length != b.length) return false;
    return a.containsAll(b);
  }
}


===== theme/theme_registry.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';

// Theme IDs
const String lightThemeId = 'light';
const String darkThemeId = 'dark';
const String sandThemeId = 'sand';
const String inkThemeId = 'ink';
const String roseThemeId = 'rose';
const String noirThemeId = 'noir';

// Font IDs
const String garamondFontId = 'garamond';
const String ptSansNarrowFontId = 'pt_sans_narrow';
const String tangerineFontId = 'tangerine';

class ThemeRegistry {
  static final Map<String, ThemeData> _themes = {
    lightThemeId: _buildLightTheme(),
    darkThemeId: _buildDarkTheme(),
    sandThemeId: _buildSandTheme(),
    inkThemeId: _buildInkTheme(),
    roseThemeId: _buildRoseTheme(),
    noirThemeId: _buildNoirTheme(),
  };

  static final Map<String, String> _fonts = {
    garamondFontId: 'EBGaramond',
    ptSansNarrowFontId: 'PTSansNarrow',
    tangerineFontId: 'Tangerine',
  };

  static ThemeData getTheme(String themeId, String fontId) {
    final baseTheme = _themes[themeId] ?? _buildLightTheme();
    final fontFamily = _fonts[fontId] ?? 'EBGaramond';

    return baseTheme.copyWith(
      textTheme: baseTheme.textTheme.apply(fontFamily: fontFamily),
    );
  }

  static ThemeData _buildLightTheme() {
    const paper = Color(0xFFF4EFE8); // warm paper
    const primary = Color(0xFF333333); // soft charcoal

    return ThemeData(
      brightness: Brightness.light,
      primaryColor: primary,
      scaffoldBackgroundColor: paper,
      dividerColor: Color(0x1F000000), // ~12% black
      appBarTheme: const AppBarTheme(
        backgroundColor: paper,
        elevation: 0,
        surfaceTintColor: Colors.transparent,
        scrolledUnderElevation: 0,
        foregroundColor: primary,
      ),
      colorScheme: ColorScheme.fromSeed(
        seedColor: primary,
        brightness: Brightness.light,
        background: paper,
      ),
      fontFamily: 'EBGaramond',
      extensions: const <ThemeExtension<dynamic>>[
        LBTheme(
          controlSurface: Color.fromARGB(255, 234, 227, 218),
          controlOnSurface: Color.fromARGB(255, 30, 30, 30),
          controlBorder: Color.fromARGB(20, 0, 0, 0),
        ),
      ],
    );
  }

  static ThemeData _buildDarkTheme() {
    return ThemeData(
      brightness: Brightness.dark,
      primaryColor: Colors.white,
      scaffoldBackgroundColor: Colors.black,
      colorScheme: ColorScheme.fromSeed(
        seedColor: Colors.white,
        brightness: Brightness.dark,
        background: Colors.black,
      ),
      fontFamily: 'EBGaramond',
      extensions: const <ThemeExtension<dynamic>>[
        LBTheme(
          controlSurface: Color.fromARGB(255, 30, 30, 30),
          controlOnSurface: Color.fromARGB(255, 220, 220, 220),
          controlBorder: Color.fromARGB(20, 255, 255, 255),
        ),
      ],
    );
  }

  static ThemeData _buildSandTheme() {
    const sand = Color(0xFFF2EADD); // desaturated sand
    const primary = Color(0xFF4F3B2A); // muted walnut

    return ThemeData(
      brightness: Brightness.light,
      primaryColor: primary,
      scaffoldBackgroundColor: sand,
      dividerColor: Color(0x14000000), // ~8% black
      appBarTheme: const AppBarTheme(
        backgroundColor: sand,
        elevation: 0,
        surfaceTintColor: Colors.transparent,
        scrolledUnderElevation: 0,
        foregroundColor: primary,
      ),
      colorScheme: ColorScheme.fromSeed(
        seedColor: primary,
        brightness: Brightness.light,
        background: Color(0xFFF3EDE2), // slightly cooler sand
      ),
      extensions: const <ThemeExtension<dynamic>>[
        LBTheme(
          controlSurface: Color(0xFFE8DECE), // warm card
          controlOnSurface: Color(0xFF4F3B2A),
          controlBorder: Color(0x1A4F3B2A), // ~10% walnut
        ),
      ],
    );
  }

  static ThemeData _buildInkTheme() {
    const sheet = Color(0xFFFBFDFF); // neutral, bright “paper”
    const primary = Color(0xFF11284C); // muted navy/ink

    return ThemeData(
      brightness: Brightness.light,
      primaryColor: primary,
      scaffoldBackgroundColor: sheet,
      dividerColor: Color(0x1A11284C), // ~10% ink
      appBarTheme: const AppBarTheme(
        backgroundColor: sheet,
        elevation: 0,
        surfaceTintColor: Colors.transparent,
        scrolledUnderElevation: 0,
        foregroundColor: primary,
      ),
      colorScheme: ColorScheme.fromSeed(
        seedColor: primary,
        brightness: Brightness.light,
        background: Color(0xFFF6F8FC), // cool off-white
      ),
      extensions: const <ThemeExtension<dynamic>>[
        LBTheme(
          controlSurface: Color(0xFFEEF2FA), // cool card
          controlOnSurface: Color(0xFF102A56),
          controlBorder: Color(0x1911284C), // ~10% ink, slightly lighter
        ),
      ],
    );
  }

  static ThemeData _buildRoseTheme() {
    const vellum = Color(0xFFFFF7F9); // airy rose paper
    const primary = Color(0xFF7A2E3A); // dusty burgundy

    return ThemeData(
      brightness: Brightness.light,
      primaryColor: primary,
      scaffoldBackgroundColor: vellum,
      dividerColor: Color(0x1A7A2E3A), // ~10% burgundy
      appBarTheme: const AppBarTheme(
        backgroundColor: vellum,
        elevation: 0,
        surfaceTintColor: Colors.transparent,
        scrolledUnderElevation: 0,
        foregroundColor: primary,
      ),
      colorScheme: ColorScheme.fromSeed(
        seedColor: primary,
        brightness: Brightness.light,
        background: Color(0xFFFFF0F3), // gentle rose wash
      ),
      extensions: const <ThemeExtension<dynamic>>[
        LBTheme(
          controlSurface: Color(0xFFFBE9ED), // soft rose card
          controlOnSurface: Color(0xFF7A2E3A),
          controlBorder: Color(0x197A2E3A), // ~10% burgundy, lighter
        ),
      ],
    );
  }

  static ThemeData _buildNoirTheme() {
    return ThemeData(
      brightness: Brightness.dark,
      primaryColor: const Color(0xFFFFFFFF),
      scaffoldBackgroundColor: const Color(0xFF1C1C1E),
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFFFFFFFF),
        brightness: Brightness.dark,
        background: const Color(0xFF1C1C1E),
      ),
      extensions: const <ThemeExtension<dynamic>>[
        LBTheme(
          controlSurface: Color(0xFF2C2C2E),
          controlOnSurface: Color(0xFFE5E5E7),
          controlBorder: Color.fromARGB(20, 255, 255, 255),
        ),
      ],
    );
  }
}


===== theme/lb_theme_extension.dart =====

import 'package:flutter/material.dart';

class LBTheme extends ThemeExtension<LBTheme> {
  const LBTheme({
    required this.controlSurface,
    required this.controlOnSurface,
    required this.controlBorder,
  });

  final Color controlSurface;
  final Color controlOnSurface;
  final Color controlBorder;

  @override
  ThemeExtension<LBTheme> copyWith({
    Color? controlSurface,
    Color? controlOnSurface,
    Color? controlBorder,
  }) {
    return LBTheme(
      controlSurface: controlSurface ?? this.controlSurface,
      controlOnSurface: controlOnSurface ?? this.controlOnSurface,
      controlBorder: controlBorder ?? this.controlBorder,
    );
  }

  @override
  ThemeExtension<LBTheme> lerp(
    covariant ThemeExtension<LBTheme>? other,
    double t,
  ) {
    if (other is! LBTheme) {
      return this;
    }
    return LBTheme(
      controlSurface: Color.lerp(controlSurface, other.controlSurface, t)!,
      controlOnSurface: Color.lerp(
        controlOnSurface,
        other.controlOnSurface,
        t,
      )!,
      controlBorder: Color.lerp(controlBorder, other.controlBorder, t)!,
    );
  }

  /// Get quote text style based on theme
  TextStyle quoteTextStyle(BuildContext context, double fontSize) {
    final textTheme = Theme.of(context).textTheme.headlineSmall!;
    final isTangerine = textTheme.fontFamily == 'Tangerine';

    return textTheme.copyWith(
      fontSize: isTangerine ? fontSize * 1.4 : fontSize, // Boost Tangerine size
      fontWeight: isTangerine
          ? FontWeight.w600
          : FontWeight.w500, // Boost Tangerine weight
      color: Theme.of(context).primaryColor,
      height: 1.4,
    );
  }

  /// Get author/source text style based on theme
  TextStyle authorTextStyle(BuildContext context, double fontSize) {
    final textTheme = Theme.of(context).textTheme.titleSmall!;
    final isTangerine = textTheme.fontFamily == 'Tangerine';

    return textTheme.copyWith(
      fontSize: isTangerine ? fontSize * 1.2 : fontSize, // Boost Tangerine size
      fontWeight: isTangerine
          ? FontWeight.w600
          : FontWeight.w300, // Boost Tangerine weight
      color: const Color.fromARGB(255, 166, 165, 165),
    );
  }

  /// Get source text style based on theme
  TextStyle sourceTextStyle(BuildContext context, double fontSize) {
    final textTheme = Theme.of(context).textTheme.labelLarge!;
    final isTangerine = textTheme.fontFamily == 'Tangerine';

    return textTheme.copyWith(
      fontSize: isTangerine
          ? fontSize * 1.15
          : fontSize, // Boost Tangerine size
      fontWeight: isTangerine
          ? FontWeight.w500
          : FontWeight.w300, // Boost Tangerine weight
      color: const Color.fromARGB(255, 140, 140, 140),
      fontStyle: FontStyle.italic,
    );
  }

  /// Get button text style based on theme
  TextStyle buttonTextStyle(BuildContext context) {
    return Theme.of(
      context,
    ).textTheme.labelLarge!.copyWith(color: Theme.of(context).primaryColor);
  }
}


===== services/theme_controller.dart =====

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:quotes_app/theme/theme_registry.dart';
import 'package:quotes_app/services/entitlements_service.dart';

class ThemeController {
  static final ThemeController instance = ThemeController._();
  ThemeController._();

  static const String _themeIdKey = 'theme_id';
  static const String _fontIdKey = 'font_id';

  late String _themeId;
  late String _fontId;

  ThemeData get themeData => ThemeRegistry.getTheme(_themeId, _fontId);
  String get themeId => _themeId;
  String get fontId => _fontId;

  final List<VoidCallback> _listeners = [];

  Future<void> init() async {
    final prefs = await SharedPreferences.getInstance();
    final savedThemeId = prefs.getString(_themeIdKey) ?? lightThemeId;
    final savedFontId = prefs.getString(_fontIdKey) ?? garamondFontId;

    // Validate theme access for former Pro users
    _themeId = await _validateThemeAccess(savedThemeId);
    _fontId = await _validateFontAccess(savedFontId);

    // Save corrected values if they were changed
    if (_themeId != savedThemeId) {
      await prefs.setString(_themeIdKey, _themeId);
    }
    if (_fontId != savedFontId) {
      await prefs.setString(_fontIdKey, _fontId);
    }
  }

  Future<String> _validateThemeAccess(String themeId) async {
    final freeThemes = [lightThemeId, darkThemeId];
    if (freeThemes.contains(themeId)) {
      return themeId; // Free theme, always accessible
    }

    // Premium theme - check access
    final hasAccess = await EntitlementsService.instance.isFeatureActive(
      'premium_themes',
    );
    if (hasAccess) {
      return themeId; // User has access, keep the theme
    }

    // No access to premium theme, fall back to light theme
    return lightThemeId;
  }

  Future<String> _validateFontAccess(String fontId) async {
    final freeFonts = [garamondFontId];
    if (freeFonts.contains(fontId)) {
      return fontId; // Free font, always accessible
    }

    // Premium fonts - check access
    final hasAccess = await EntitlementsService.instance.isFeatureActive(
      'premium_fonts',
    );
    if (hasAccess) {
      return fontId; // User has access, keep the font
    }

    // No access to premium font, fall back to garamond
    return garamondFontId;
  }

  Future<void> setTheme(String themeId) async {
    _themeId = themeId;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_themeIdKey, themeId);
    _notifyListeners();
  }

  Future<void> setFont(String fontId) async {
    _fontId = fontId;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_fontIdKey, fontId);
    _notifyListeners();
  }

  void addListener(VoidCallback listener) {
    _listeners.add(listener);
  }

  void removeListener(VoidCallback listener) {
    _listeners.remove(listener);
  }

  void _notifyListeners() {
    for (var listener in _listeners) {
      listener();
    }
  }
}


===== services/entitlements_service.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:quotes_app/services/analytics.dart';

class EntitlementsService {
  static final EntitlementsService instance = EntitlementsService._();
  Completer<void>? _writeLock;

  static const _entitlementsKey = 'entitlements';
  static const _isProKey = 'isPro';
  static const _proSinceKey = 'proSince';
  static const _featurePassesKey = 'featurePasses';

  // Feature Keys
  static const String browseTags = 'browse_tags';
  static const String browseAuthor = 'browse_author';
  static const String browsePeriod = 'browse_period';
  static const String premiumThemes = 'premium_themes';
  static const String premiumFonts = 'premium_fonts';
  static const String premiumShareStyles = 'premium_share_styles';
  static const String srsUnlimited = 'srs_unlimited';
  static const String learnTrainer = 'learn_trainer';

  static const Map<String, String> proFeatureDisplayNames = {
    browseAuthor: 'Browse by Author',
    browsePeriod: 'Browse by Period',
    premiumThemes: 'Premium Themes',
    premiumFonts: 'Premium Fonts',
    premiumShareStyles: 'Premium Share Styles',
    srsUnlimited: 'Unlimited Learning',
    learnTrainer: 'Personalised Learning',
  };

  EntitlementsService._();

  Future<Map<String, dynamic>> _loadEntitlements() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_entitlementsKey);
    if (jsonString != null) {
      try {
        final loaded = json.decode(jsonString) as Map<String, dynamic>;
        // Basic validation
        if (loaded.containsKey(_isProKey) &&
            loaded.containsKey(_featurePassesKey)) {
          return loaded;
        }
      } catch (e) {
        // Corrupt data, fall back to default
      }
    }
    // Default entitlements
    return {
      _isProKey: false,
      _proSinceKey: null,
      _featurePassesKey: <String, String>{},
    };
  }

  Future<void> _saveEntitlements(Map<String, dynamic> entitlements) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_entitlementsKey, json.encode(entitlements));
  }

  Future<void> _mutex(Future<void> Function() criticalSection) async {
    while (_writeLock != null) {
      await _writeLock!.future;
    }
    _writeLock = Completer();
    try {
      await criticalSection();
    } finally {
      _writeLock!.complete();
      _writeLock = null;
    }
  }

  Future<bool> isPro() async {
    final entitlements = await _loadEntitlements();
    return entitlements['isPro'] as bool;
  }

  /// Helper for Pro-only features that don't have Feature Passes
  Future<bool> isProOnlyFeature(String key) async {
    return await isPro();
  }

  Future<void> clearExpiredPasses() async {
    final entitlements = await _loadEntitlements();
    final passes = Map<String, String>.from(
      entitlements[_featurePassesKey] as Map,
    );
    final now = DateTime.now().toUtc();

    final futures = <Future<void>>[];
    passes.removeWhere((key, value) {
      final expiry = DateTime.tryParse(value)?.toUtc();
      final isExpired = expiry == null || !expiry.isAfter(now);
      if (isExpired) {
        futures.add(
          Analytics.instance.logEvent('entitlement.feature_pass_expired', {
            'feature': key,
          }),
        );
      }
      return isExpired;
    });

    await Future.wait(futures);

    entitlements[_featurePassesKey] = passes;
    await _saveEntitlements(entitlements);
  }

  Future<Map<String, DateTime>> getFeaturePasses() async {
    await clearExpiredPasses();
    final entitlements = await _loadEntitlements();
    final passes = Map<String, String>.from(
      entitlements[_featurePassesKey] as Map,
    );
    return passes.map((key, value) => MapEntry(key, DateTime.parse(value)));
  }

  Future<void> grantFeaturePass(
    String featureKey,
    Duration duration, {
    String source = 'unknown',
  }) async {
    await _mutex(() async {
      await clearExpiredPasses();
      final entitlements = await _loadEntitlements();
      final passes = Map<String, String>.from(
        entitlements[_featurePassesKey] as Map,
      );
      final now = DateTime.now().toUtc();

      final currentExpiryStr = passes[featureKey];
      DateTime newExpiry;
      if (currentExpiryStr != null) {
        final currentExpiry = DateTime.parse(currentExpiryStr).toUtc();
        if (currentExpiry.isAfter(now)) {
          // Extend existing pass
          newExpiry = currentExpiry.add(duration);
        } else {
          // Grant new pass as old one expired
          newExpiry = now.add(duration);
        }
      } else {
        // Grant new pass
        newExpiry = now.add(duration);
      }

      passes[featureKey] = newExpiry.toIso8601String();
      entitlements[_featurePassesKey] = passes;
      await _saveEntitlements(entitlements);
      await Analytics.instance.logEvent('entitlement.feature_pass_granted', {
        'feature': featureKey,
        'source': source,
        'expiresAt': newExpiry.toIso8601String(),
      });
    });
  }

  Future<bool> isFeatureActive(String featureKey) async {
    if (await isPro()) {
      return true;
    }

    final passes = await getFeaturePasses();
    return passes.containsKey(featureKey);
  }

  Future<Duration?> timeRemaining(String featureKey) async {
    if (await isPro()) return null; // Pro has infinite duration

    final passes = await getFeaturePasses();
    final expiry = passes[featureKey];

    if (expiry == null) return null;

    final remaining = expiry.difference(DateTime.now().toUtc());
    return remaining.isNegative ? null : remaining;
  }

  Future<List<String>> activeFeatureKeys() async {
    final passes = await getFeaturePasses();
    return passes.keys.toList();
  }

  // Helper for dev panel
  Future<void> revokeFeaturePass(String featureKey) async {
    await _mutex(() async {
      final entitlements = await _loadEntitlements();
      final passes = Map<String, String>.from(
        entitlements[_featurePassesKey] as Map,
      );
      passes.remove(featureKey);
      entitlements[_featurePassesKey] = passes;
      await _saveEntitlements(entitlements);
    });
  }

  // Helper for dev panel and purchase service
  Future<void> setPro(bool isPro, {DateTime? since}) async {
    await _mutex(() async {
      final entitlements = await _loadEntitlements();
      entitlements[_isProKey] = isPro;
      entitlements[_proSinceKey] = isPro
          ? (since ?? DateTime.now().toUtc()).toIso8601String()
          : null;
      await _saveEntitlements(entitlements);
    });
  }

  // Helper for dev panel
  Future<void> clearAllPasses() async {
    await _mutex(() async {
      final entitlements = await _loadEntitlements();
      entitlements[_featurePassesKey] = <String, String>{};
      await _saveEntitlements(entitlements);
    });
  }
}


===== services/purchase_service.dart =====

import 'dart:io';

import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:purchases_flutter/purchases_flutter.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/services/revenuecat_keys.dart';

enum PurchasePlan {
  monthly(r'$rc_monthly'),
  annual(r'$rc_annual');

  const PurchasePlan(this.id);
  final String id;
}

class PurchaseService {
  static final PurchaseService instance = PurchaseService._();
  PurchaseService._();

  Offerings? _offerings;

  /// No longer a mock
  bool get isMock => false;

  Future<void> configure({required String iosApiKey, String? appUserId}) async {
    // Android is deferred for now
    if (!Platform.isIOS) return;

    try {
      final config = PurchasesConfiguration(iosApiKey);
      await Purchases.configure(config);

      if (appUserId != null) {
        await logIn(appUserId);
      }

      Purchases.addCustomerInfoUpdateListener((customerInfo) async {
        final active =
            customerInfo.entitlements.all[rcEntitlementKey]?.isActive ?? false;
        await EntitlementsService.instance.setPro(
          active,
          since: active ? DateTime.now() : null,
        );
        Analytics.instance.logEvent('purchase.entitlement_changed', {
          'active': active,
        });
      });

      await syncEntitlementFromRC();
    } catch (e) {
      Analytics.instance.logEvent('purchase.configure_error', {
        'error': e.toString(),
      });
    }
  }

  Future<CustomerInfo> syncEntitlementFromRC() async {
    try {
      // Ensure purchases done outside the app (offer codes, subscription changes) are synced on iOS
      if (Platform.isIOS) {
        await Purchases.syncPurchases();
      }
      // Force a fresh fetch from RevenueCat (CustomerInfo is cached ~5 minutes)
      await Purchases.invalidateCustomerInfoCache();
      final info = await Purchases.getCustomerInfo();
      final active = info.entitlements.all[rcEntitlementKey]?.isActive ?? false;

      // Only update and log if status changed to avoid over-logging
      final currentProStatus = await EntitlementsService.instance.isPro();
      if (currentProStatus != active) {
        await EntitlementsService.instance.setPro(
          active,
          since: active ? DateTime.now() : null,
        );
        Analytics.instance.logEvent('purchase.entitlement_changed', {
          'active': active,
          'from': currentProStatus,
          'to': active,
        });
      }

      return info;
    } catch (e) {
      // Only log errors in debug mode to reduce noise
      if (e.toString().contains('ASDErrorDomain') ||
          e.toString().contains('StoreKit')) {
        // Handle App Store specific errors gracefully
        Analytics.instance.logEvent('purchase.store_error', {
          'error': e.toString(),
          'type': 'app_store_error',
        });
        return await Purchases.getCustomerInfo(); // Return cached data
      } else {
        Analytics.instance.logEvent('purchase.entitlement_sync_error', {
          'error': e.toString(),
        });
        rethrow;
      }
    }
  }

  Future<void> logIn(String appUserId) async {
    try {
      await Purchases.logIn(appUserId);
      await refreshOfferings();
    } catch (e) {
      Analytics.instance.logEvent('purchase.login_error', {
        'error': e.toString(),
      });
    }
  }

  Future<void> logOut() async {
    try {
      await Purchases.logOut();
      await refreshOfferings();
    } catch (e) {
      Analytics.instance.logEvent('purchase.logout_error', {
        'error': e.toString(),
      });
    }
  }

  /// Purchase a plan
  Future<bool> purchase(String planId) async {
    await Analytics.instance.logEvent('purchase.start', {'plan': planId});

    try {
      final packageToPurchase = _offerings?.current?.getPackage(planId);
      if (packageToPurchase == null) {
        throw Exception('Could not find package for plan $planId');
      }
      final purchaseResult = await Purchases.purchasePackage(packageToPurchase);
      final info = purchaseResult.customerInfo;
      final isActive =
          info.entitlements.all[rcEntitlementKey]?.isActive ?? false;
      await EntitlementsService.instance.setPro(
        isActive,
        since: isActive ? DateTime.now() : null,
      );
      await Analytics.instance.logEvent('purchase.success', {'plan': planId});
      return true;
    } on PlatformException catch (e) {
      final errorCode = PurchasesErrorHelper.getErrorCode(e);
      if (errorCode == PurchasesErrorCode.purchaseCancelledError) {
        Analytics.instance.logEvent('purchase.cancelled', {'plan': planId});
        return false;
      } else if (errorCode ==
          PurchasesErrorCode.productNotAvailableForPurchaseError) {
        Analytics.instance.logEvent('purchase.product_unavailable', {
          'plan': planId,
        });
        throw Exception('Product not available for purchase');
      } else if (errorCode == PurchasesErrorCode.paymentPendingError) {
        Analytics.instance.logEvent('purchase.payment_pending', {
          'plan': planId,
        });
        return false; // Don't rethrow for pending payments
      } else {
        Analytics.instance.logEvent('purchase.error', {
          'plan': planId,
          'error': e.toString(),
          'code': errorCode.toString(),
        });
        rethrow;
      }
    } catch (e) {
      // Handle network errors gracefully
      if (e.toString().contains('network') ||
          e.toString().contains('timeout')) {
        Analytics.instance.logEvent('purchase.network_error', {
          'plan': planId,
          'error': e.toString(),
        });
        throw Exception(
          'Network error. Please check your connection and try again.',
        );
      } else {
        Analytics.instance.logEvent('purchase.error', {
          'plan': planId,
          'error': e.toString(),
        });
        rethrow;
      }
    }
  }

  /// Restore purchases
  Future<CustomerInfo> restore() async {
    await Analytics.instance.logEvent('purchase.restore_start');
    try {
      final customerInfo = await Purchases.restorePurchases();
      final isActive =
          customerInfo.entitlements.all[rcEntitlementKey]?.isActive ?? false;
      await EntitlementsService.instance.setPro(
        isActive,
        since: isActive ? DateTime.now() : null,
      );
      await Analytics.instance.logEvent('purchase.restore_success');
      return customerInfo;
    } catch (e) {
      await Analytics.instance.logEvent('purchase.restore_error', {
        'error': e.toString(),
      });
      rethrow;
    }
  }

  Future<void> refreshOfferings() async {
    try {
      _offerings = await Purchases.getOfferings();
    } catch (e) {
      Analytics.instance.logEvent('purchase.offerings_error', {
        'error': e.toString(),
      });
    }
  }

  Future<void> ensureOfferingsLoaded() async {
    if (_offerings == null) {
      await refreshOfferings();
    }
  }

  Package? _getPackageForPlan(PurchasePlan plan) {
    return _offerings?.current?.getPackage(plan.id);
  }

  /// Get display price for a plan
  String? getPlanPrice(PurchasePlan plan) {
    return _getPackageForPlan(plan)?.storeProduct.priceString;
  }

  /// Get per-month equivalent price for annual plan
  String? getAnnualPerMonthPrice() {
    final annualPackage = _getPackageForPlan(PurchasePlan.annual);
    if (annualPackage == null) return null;

    final product = annualPackage.storeProduct;
    final price = product.price;

    if (price <= 0) return null;

    final format = NumberFormat.simpleCurrency(name: product.currencyCode);
    return format.format(price / 12);
  }

  /// Get plan display name
  String getPlanDisplayName(PurchasePlan plan) {
    // This could also come from the package's storeProduct.title if needed
    switch (plan) {
      case PurchasePlan.monthly:
        return 'Monthly';
      case PurchasePlan.annual:
        return 'Annual';
    }
  }

  /// Returns a string like "Start with a 7 day free trial" or null if no trial.
  String? getTrialDescription(PurchasePlan plan) {
    final package = _getPackageForPlan(plan);
    final introPrice = package?.storeProduct.introductoryPrice;

    if (introPrice == null || introPrice.price > 0) return null;

    final units = introPrice.periodNumberOfUnits;
    if (units == 0) return null;

    var period = introPrice.periodUnit.name;
    if (units > 1) {
      period = '${period}s';
    }

    return 'Start with a $units $period free trial';
  }
}


===== services/rewards_service.dart =====

import 'dart:async';

import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/services/streak_service.dart';

class RewardsSnapshot {
  final String tier;
  final List<ActivePass> activePasses;
  final NextPassInfo? nextPass;
  final int currentStreak;

  RewardsSnapshot({
    required this.tier,
    required this.activePasses,
    required this.currentStreak,
    this.nextPass,
  });
}

class ActivePass {
  final String featureKey;
  final String displayName;
  final Duration timeRemaining;

  ActivePass({
    required this.featureKey,
    required this.displayName,
    required this.timeRemaining,
  });
}

class NextPassInfo {
  final int nextMilestone;
  final int daysRemaining;
  final List<String> featureKeysAtNextMilestone;
  final List<String> featureDisplayNamesAtNextMilestone;

  NextPassInfo({
    required this.nextMilestone,
    required this.daysRemaining,
    required this.featureKeysAtNextMilestone,
    required this.featureDisplayNamesAtNextMilestone,
  });
}

class RewardsService {
  static final RewardsService instance = RewardsService._();
  RewardsService._();

  int _calculateNextMilestone(int currentStreak) {
    const interval = 3;
    if (currentStreak == 0) return interval;
    return ((currentStreak / interval).floor() + 1) * interval;
  }

  List<String> _getFeaturesForMilestone(int milestone) {
    // Cycle through the pro features list for rewards
    final rewardableFeatures = EntitlementsService.proFeatureDisplayNames.keys
        .toList();
    final cycleIndex =
        ((milestone / 3) - 1).floor() % rewardableFeatures.length;
    return [rewardableFeatures[cycleIndex]];
  }

  Future<RewardsSnapshot> load() async {
    final isPro = await EntitlementsService.instance.isPro();
    final tier = isPro ? "Pro" : "Free";
    final streakCount = await StreakService.instance.getStreakCount();

    final activePasses = <ActivePass>[];
    if (!isPro) {
      final activeKeys = await EntitlementsService.instance.activeFeatureKeys();
      // Define features that are now free (don't show passes for these)
      final freeFeatures = {EntitlementsService.browseTags};

      for (final key in activeKeys) {
        // Skip showing passes for features that are now free
        if (freeFeatures.contains(key)) continue;

        final remaining = await EntitlementsService.instance.timeRemaining(key);
        if (remaining != null && !remaining.isNegative) {
          activePasses.add(
            ActivePass(
              featureKey: key,
              displayName:
                  EntitlementsService.proFeatureDisplayNames[key] ?? key,
              timeRemaining: remaining,
            ),
          );
        }
      }
    }

    NextPassInfo? nextPass;
    if (!isPro) {
      final nextMilestone = _calculateNextMilestone(streakCount);
      final daysRemaining = nextMilestone - streakCount;
      final features = _getFeaturesForMilestone(nextMilestone);
      final featureDisplayNames = features
          .map((f) => EntitlementsService.proFeatureDisplayNames[f] ?? f)
          .toList();

      nextPass = NextPassInfo(
        nextMilestone: nextMilestone,
        daysRemaining: daysRemaining,
        featureKeysAtNextMilestone: features,
        featureDisplayNamesAtNextMilestone: featureDisplayNames,
      );
    }

    return RewardsSnapshot(
      tier: tier,
      activePasses: activePasses,
      nextPass: nextPass,
      currentStreak: streakCount,
    );
  }
}


===== services/revenuecat_keys.dart =====

// Replace with your live keys from RevenueCat dashboard
const String rcAppleApiKey = 'appl_FtlDvQRksqynMXWbAclzNghVfHu';
// const String rcGoogleApiKey = 'REVENUECAT_GOOGLE_API_KEY';

// Entitlement configured in RevenueCat
const String rcEntitlementKey = 'pro';


===== services/notification_service.dart =====

import 'dart:convert';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart'; // For addPostFrameCallback
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/models/notification_prefs.dart';
import 'package:quotes_app/models/period_catalog.dart';
import 'package:quotes_app/services/analytics.dart';
import 'streak_service.dart';

class NotificationService {
  static final FlutterLocalNotificationsPlugin _notificationsPlugin =
      FlutterLocalNotificationsPlugin();

  static GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

  // ID namespace for our notifications to avoid conflicts
  static const int _baseNotificationId = 1000;
  static const int _streakNotificationId = 999;
  static const String _prefsKey = 'notif_prefs_v1';

  static Future<void> init() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const DarwinInitializationSettings initializationSettingsIOS =
        DarwinInitializationSettings(
          requestAlertPermission: true,
          requestBadgePermission: true,
          requestSoundPermission: true,
        );

    const InitializationSettings initializationSettings =
        InitializationSettings(
          android: initializationSettingsAndroid,
          iOS: initializationSettingsIOS,
        );

    final details = await _notificationsPlugin
        .getNotificationAppLaunchDetails();
    _initialPayload = details?.notificationResponse?.payload;

    await _notificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: onDidReceiveNotificationResponse,
    );
  }

  static String? _initialPayload;

  /// Should be called once after runApp to process notification that launched the app
  static void handleInitialNotification() {
    if (_initialPayload != null) {
      navigatorKey.currentState?.pushNamed(
        '/quote',
        arguments: _initialPayload,
      );
      _initialPayload = null; // Clear to avoid duplicate navigation
    }
  }

  static void onDidReceiveNotificationResponse(
    NotificationResponse notificationResponse,
  ) async {
    final String? payload = notificationResponse.payload;
    if (payload != null) {
      debugPrint('notification payload: $payload');
      navigatorKey.currentState?.pushNamed('/quote', arguments: payload);
    }
  }

  /// Load notification preferences from SharedPreferences
  static Future<NotificationPrefs> loadNotificationPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final prefsJson = prefs.getString(_prefsKey);

    if (prefsJson == null) {
      // Migration: create default preferences
      final defaultPrefs = NotificationPrefs.defaultFree();
      await saveNotificationPrefs(defaultPrefs);
      return defaultPrefs;
    }

    try {
      final map = json.decode(prefsJson) as Map<String, dynamic>;
      return NotificationPrefs.fromJson(map);
    } catch (e) {
      debugPrint('Error loading notification prefs: $e');
      // Return default and save it
      final defaultPrefs = NotificationPrefs.defaultFree();
      await saveNotificationPrefs(defaultPrefs);
      return defaultPrefs;
    }
  }

  /// Save notification preferences to SharedPreferences
  static Future<void> saveNotificationPrefs(NotificationPrefs prefs) async {
    final sp = await SharedPreferences.getInstance();
    final prefsJson = json.encode(prefs.toJson());
    await sp.setString(_prefsKey, prefsJson);
  }

  /// Request notification permissions if needed
  static Future<bool> requestPermissionsIfNeeded() async {
    final androidPermission = await _notificationsPlugin
        .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin
        >()
        ?.requestNotificationsPermission();

    final iosPermission = await _notificationsPlugin
        .resolvePlatformSpecificImplementation<
          IOSFlutterLocalNotificationsPlugin
        >()
        ?.requestPermissions(alert: true, badge: true, sound: true);

    return (androidPermission ?? true) && (iosPermission ?? true);
  }

  /// Sync notifications with preferences - main entry point for prefs-based scheduling
  static Future<void> syncWithPrefs(
    NotificationPrefs prefs,
    DateTime now, {
    List<Quote>? feed,
    List<Quote>? favoriteQuotes,
  }) async {
    debugPrint('📱 Syncing notifications with preferences...');

    // Check permissions first
    final hasPermission = await requestPermissionsIfNeeded();
    if (!hasPermission) {
      debugPrint('❌ Notification permissions denied');
      return;
    }

    // Cancel all our previous notifications (preserve streak notifications)
    await _cancelOurNotifications();

    if (prefs.times.isEmpty) {
      debugPrint('📱 No notification times configured');
      return;
    }

    // Schedule notifications for the next 7 days
    int notificationCount = 0;
    for (int dayOffset = 0; dayOffset < 7; dayOffset++) {
      final targetDate = now.add(Duration(days: dayOffset));
      final weekday = targetDate.weekday; // 1=Monday, 7=Sunday

      if (!prefs.isActiveOnWeekday(weekday)) {
        continue; // Skip this day
      }

      for (final time in prefs.times) {
        final scheduledTime = _createScheduledTime(targetDate, time);

        // Skip if the time has already passed today
        if (scheduledTime.isBefore(now)) {
          continue;
        }

        final quote = pickQuoteForSlot(
          scheduledTime,
          prefs,
          feed: feed ?? [],
          favoriteQuotes: favoriteQuotes ?? [],
        );

        if (quote != null) {
          final notificationId = _baseNotificationId + notificationCount;
          await _scheduleNotification(
            notificationId,
            _getTitleForTime(time),
            quote.text,
            quote.id,
            scheduledTime,
          );

          notificationCount++;

          // Respect daily cap
          if (notificationCount >= prefs.dailyCap * 7) {
            break;
          }
        }
      }
    }

    debugPrint('🎯 Scheduled $notificationCount notifications over 7 days');

    // Log analytics
    Analytics.instance.logEvent(Analytics.notifScheduledTotal, {
      'count_7d': notificationCount,
    });

    // Schedule streak reminder if needed
    await _scheduleStreakReminderIfNeeded();

    // Save the scheduling time for future reference
    final sp = await SharedPreferences.getInstance();
    await sp.setInt('last_sync_timestamp', now.millisecondsSinceEpoch);
  }

  /// Pick a quote for a specific notification slot
  static Quote? pickQuoteForSlot(
    DateTime when,
    NotificationPrefs prefs, {
    required List<Quote> feed,
    required List<Quote> favoriteQuotes,
  }) {
    // Get available quotes based on filters
    List<Quote> candidates = _filterQuotesByPrefs(feed, prefs);

    if (candidates.isEmpty) {
      // Fall back to personalized feed (existing logic)
      final favoriteIds = favoriteQuotes.map((q) => q.id).toSet();
      candidates = feed.where((q) => !favoriteIds.contains(q.id)).toList();
    }

    if (candidates.isEmpty) {
      // Last resort: use any quote from feed
      candidates = feed;
    }

    if (candidates.isEmpty) {
      return null;
    }

    // Avoid recent quotes
    final recentIds = _getRecentQuoteIds();
    final nonRecentCandidates = candidates
        .where((q) => !recentIds.contains(q.id))
        .toList();

    final selectedCandidates = nonRecentCandidates.isNotEmpty
        ? nonRecentCandidates
        : candidates;

    // Use deterministic selection based on time to avoid duplicate quotes at same time
    final seed =
        when.millisecondsSinceEpoch ~/ (1000 * 60 * 60); // Hour-based seed
    final random = Random(seed);
    final selectedQuote =
        selectedCandidates[random.nextInt(selectedCandidates.length)];

    // Remember this quote
    _addToRecentQuoteIds(selectedQuote.id, prefs.lookbackDays);

    return selectedQuote;
  }

  /// Filter quotes by preferences
  static List<Quote> _filterQuotesByPrefs(
    List<Quote> quotes,
    NotificationPrefs prefs,
  ) {
    List<Quote> filtered = quotes;

    // Filter by authors
    if (prefs.authors.isNotEmpty) {
      filtered = filtered
          .where((q) => prefs.authors.contains(q.authorName))
          .toList();
    }

    // Filter by tags
    if (prefs.tags.isNotEmpty) {
      filtered = filtered
          .where((q) => q.tags.any((tag) => prefs.tags.contains(tag)))
          .toList();
    }

    // Filter by period
    if (prefs.startYear != null && prefs.endYear != null) {
      filtered = PeriodCatalog.getQuotesForRange(
        filtered,
        prefs.startYear!,
        prefs.endYear!,
      );
    }

    return filtered;
  }

  /// Cancel our notifications (preserve streak notifications)
  static Future<void> _cancelOurNotifications() async {
    // Cancel notifications in our ID range
    for (int i = _baseNotificationId; i < _baseNotificationId + 1000; i++) {
      await _notificationsPlugin.cancel(i);
    }
  }

  /// Get title for notification based on time
  static String _getTitleForTime(TimeOfDay time) {
    if (time.hour < 12) {
      return 'Morning Quote';
    } else if (time.hour < 17) {
      return 'Afternoon Reflection';
    } else {
      return 'Evening Thought';
    }
  }

  /// Create a TZDateTime for a specific date and time
  static tz.TZDateTime _createScheduledTime(DateTime date, TimeOfDay time) {
    return tz.TZDateTime(
      tz.local,
      date.year,
      date.month,
      date.day,
      time.hour,
      time.minute,
    );
  }

  /// Get recent quote IDs to avoid repetition
  static Set<String> _getRecentQuoteIds() {
    // This would ideally be async, but for simplicity we'll use a synchronous approach
    // In production, you might want to cache this in memory
    return {}; // Simplified for now
  }

  /// Add quote ID to recent list
  static void _addToRecentQuoteIds(String quoteId, int lookbackDays) {
    // Simplified for now - in production, maintain a ring buffer in SharedPreferences
  }

  /// Legacy method - now delegates to prefs-based system
  static Future<void> scheduleForToday({
    required List<Quote> feed,
    required List<Quote> favoriteQuotes,
    required DateTime now,
  }) async {
    // Load preferences and use the new system
    final prefs = await loadNotificationPrefs();
    await syncWithPrefs(prefs, now, feed: feed, favoriteQuotes: favoriteQuotes);
  }

  static Future<void> _scheduleStreakReminderIfNeeded() async {
    final streakService = StreakService.instance;
    final data = await streakService.loadData(); // A method to expose the data
    final today = streakService
        .getTodayLocal(); // A method to get today's date string
    final lastEngagementDate = data['last_engagement_local_date'];

    if (lastEngagementDate != today) {
      final reminderTime = _nextInstanceOfTime(DateTime.now(), 20); // 8 PM

      debugPrint('⏰ Scheduling streak reminder for: $reminderTime');

      await _scheduleNotification(
        _streakNotificationId, // Use a special ID for streak reminders
        'Don\'t Break Your Streak!',
        'Keep your reading streak alive with today\'s quote',
        'streak_reminder',
        reminderTime,
      );
    }
  }

  static tz.TZDateTime _nextInstanceOfTime(DateTime now, int hour) {
    final tz.TZDateTime scheduledDate = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      hour,
    );
    return scheduledDate.isBefore(now)
        ? scheduledDate.add(const Duration(days: 1))
        : scheduledDate;
  }

  static Future<void> _scheduleNotification(
    int id,
    String title,
    String body,
    String payload,
    tz.TZDateTime scheduledTime,
  ) async {
    await _notificationsPlugin.zonedSchedule(
      id,
      title,
      body,
      scheduledTime,
      const NotificationDetails(
        android: AndroidNotificationDetails(
          'daily_quotes_channel',
          'Daily Quotes',
          channelDescription: 'Channel for daily quote notifications',
          importance: Importance.max,
          priority: Priority.high,
        ),
        iOS: DarwinNotificationDetails(
          presentAlert: true,
          presentBadge: true,
          presentSound: true,
        ),
      ),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      payload: payload,
    );
  }
}


===== services/streak_service.dart =====

import 'dart:async';
import 'dart:convert';
import 'package:intl/intl.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/services/entitlements_service.dart';

class StreakService {
  static final StreakService instance = StreakService._();
  StreakService._();

  // Persistence Keys
  static const _lastEngagementDateKey = 'last_engagement_local_date';
  static const _streakCountKey = 'streak_count';
  static const _milestonesShownKey = 'milestones_shown';
  static const _weeklyViewKey =
      'weekly_view'; // Stores list of local date strings "YYYY-MM-DD"

  String getTodayLocal() {
    final now = DateTime.now();
    return DateFormat('yyyy-MM-dd').format(now);
  }

  Future<Map<String, dynamic>> loadData() async {
    final prefs = await SharedPreferences.getInstance();
    final weeklyViewJson = prefs.getString(_weeklyViewKey);
    final milestonesJson = prefs.getString(_milestonesShownKey);

    return {
      _lastEngagementDateKey: prefs.getString(_lastEngagementDateKey),
      _streakCountKey: prefs.getInt(_streakCountKey) ?? 0,
      _milestonesShownKey: (milestonesJson != null)
          ? (json.decode(milestonesJson) as List).cast<int>()
          : <int>[],
      _weeklyViewKey: (weeklyViewJson != null)
          ? (json.decode(weeklyViewJson) as List).cast<String>()
          : <String>[],
    };
  }

  Future<void> _saveData({
    String? lastEngagementDate,
    int? streakCount,
    List<int>? milestonesShown,
    List<String>? weeklyView,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    if (lastEngagementDate != null) {
      await prefs.setString(_lastEngagementDateKey, lastEngagementDate);
    }
    if (streakCount != null) {
      await prefs.setInt(_streakCountKey, streakCount);
    }
    if (milestonesShown != null) {
      await prefs.setString(_milestonesShownKey, json.encode(milestonesShown));
    }
    if (weeklyView != null) {
      await prefs.setString(_weeklyViewKey, json.encode(weeklyView));
    }
  }

  Future<Map<String, dynamic>> recordAppLaunch() async {
    final today = getTodayLocal();
    final data = await loadData();

    String? lastEngagementDate = data[_lastEngagementDateKey];
    int streakCount = data[_streakCountKey];
    List<int> milestonesShown = data[_milestonesShownKey];
    List<String> weeklyView = data[_weeklyViewKey];

    if (lastEngagementDate == today) {
      // Already engaged today, do nothing.
      return {'isNewEngagement': false, 'weeklyView': await getWeeklyView()};
    }

    final yesterday = DateFormat(
      'yyyy-MM-dd',
    ).format(DateTime.now().subtract(const Duration(days: 1)));
    int previousStreak = streakCount;

    if (lastEngagementDate == yesterday) {
      // Consecutive day, increment streak.
      streakCount++;
    } else {
      // Not consecutive, reset streak.
      streakCount = 1;
      weeklyView.clear();
    }

    await Analytics.instance.logEvent('streak.increment', {
      'from': previousStreak,
      'to': streakCount,
    });

    // Update weekly view
    weeklyView.add(today);
    if (weeklyView.length > 7) {
      weeklyView = weeklyView.sublist(weeklyView.length - 7);
    }

    // Check for new milestones
    int? newMilestone;
    List<String> awardedFeatureKeys = [];

    final isMilestoneDay = streakCount > 0 && streakCount % 3 == 0;

    if (isMilestoneDay && !milestonesShown.contains(streakCount)) {
      newMilestone = streakCount;
      milestonesShown.add(newMilestone);
      await Analytics.instance.logEvent('streak.milestone_shown', {
        'n': newMilestone,
      });

      // Grant feature passes by cycling through the pro features
      final proFeatures = EntitlementsService.proFeatureDisplayNames.keys
          .toList();
      final cycleIndex = ((newMilestone / 3) - 1).floor() % proFeatures.length;
      final featureToAward = proFeatures[cycleIndex];
      awardedFeatureKeys.add(featureToAward);

      await EntitlementsService.instance.grantFeaturePass(
        featureToAward,
        const Duration(days: 7),
        source: 'streak_$newMilestone',
      );
    }

    await _saveData(
      lastEngagementDate: today,
      streakCount: streakCount,
      milestonesShown: milestonesShown,
      weeklyView: weeklyView,
    );

    return {
      'isNewEngagement': true,
      'streakCount': streakCount,
      'milestone': newMilestone,
      'celebrationType': _getAnimationForMilestone(newMilestone),
      'awardedFeatureKeys': awardedFeatureKeys,
      'weeklyView': await getWeeklyView(),
    };
  }

  String? _getAnimationForMilestone(int? milestone) {
    if (milestone == null) return null;
    return milestone % 2 == 1 ? 'confetti' : 'fireworks';
  }

  Future<int> getStreakCount() async {
    final data = await loadData();
    return data[_streakCountKey];
  }

  Future<List<Map<String, dynamic>>> getWeeklyView() async {
    final data = await loadData();
    final List<String> engagementDates = data[_weeklyViewKey];
    if (engagementDates.isEmpty) return [];

    final today = getTodayLocal();
    final dayFormatter = DateFormat.E();
    final dateFormatter = DateFormat('yyyy-MM-dd');

    // Determine the start date of the current streak segment to display.
    // This will be the last 7 days of the streak.
    final List<String> displayDates = engagementDates.length > 7
        ? engagementDates.sublist(engagementDates.length - 7)
        : engagementDates;

    final List<Map<String, dynamic>> weeklyViewData = [];

    // If the streak is less than 7 days, fill the rest with empty days
    int emptySlots = 7 - displayDates.length;

    for (var dateString in displayDates) {
      final date = dateFormatter.parse(dateString);
      weeklyViewData.add({
        'dayName': dayFormatter.format(date),
        'isToday': dateString == today,
        'isCompleted': true, // All dates in the list are completed days
      });
    }

    // Add empty slots for the rest of the week
    for (int i = 0; i < emptySlots; i++) {
      final nextDay = dateFormatter
          .parse(displayDates.last)
          .add(Duration(days: i + 1));
      weeklyViewData.add({
        'dayName': dayFormatter.format(nextDay),
        'isToday': dateFormatter.format(nextDay) == today,
        'isCompleted': false,
      });
    }

    return weeklyViewData;
  }

  // dev panel helpers
  Future<void> resetStreak() async {
    await _saveData(
      lastEngagementDate: null,
      streakCount: 0,
      milestonesShown: [],
      weeklyView: [],
    );
  }

  Future<void> simulateMilestone(int milestone) async {
    await _saveData(
      lastEngagementDate: DateFormat(
        'yyyy-MM-dd',
      ).format(DateTime.now().subtract(Duration(days: 1))),
      streakCount: milestone - 1,
    );
  }
}


===== services/analytics.dart =====

import 'package:flutter/foundation.dart';

class Analytics {
  static final Analytics instance = Analytics._();

  Analytics._();

  Future<void> logEvent(String name, [Map<String, dynamic>? props]) async {
    // In production, this would send data to a service like Firebase or Amplitude.
    // For now, we'll only log critical events in release mode and all events in debug.
    final isProduction = const bool.fromEnvironment('dart.vm.product');

    // Always log critical events, but filter out noisy events in production
    final isCriticalEvent = _isCriticalEvent(name);

    if (kDebugMode || isProduction && isCriticalEvent) {
      // In production, you might want to use a proper logging service
      print('[Analytics] Event: $name, Properties: ${props ?? {}}');
    }
  }

  bool _isCriticalEvent(String eventName) {
    // Only log these critical events in production to reduce noise
    const criticalEvents = {
      'purchase.success',
      'purchase.error',
      'purchase.entitlement_changed',
      'purchase.store_error',
      'streak.milestone_shown',
      'learn.srs_cap_reached',
    };
    return criticalEvents.contains(eventName);
  }

  // Learn Hub Events
  static const String learnGuidedOpened = 'learn.guided_opened';
  static const String learnGuidedStarted = 'learn.guided_started';
  static const String learnGuidedAnswer = 'learn.guided_answer';
  static const String learnGuidedFinished = 'learn.guided_finished';
  static const String learnSrsOpened = 'learn.srs_opened';
  static const String learnSrsStarted = 'learn.srs_started';
  static const String learnSrsGraded = 'learn.srs_graded';
  static const String learnSrsFinished = 'learn.srs_finished';
  static const String learnSrsCapReached = 'learn.srs_cap_reached';
  static const String learnAddToSrs = 'learn.add_to_srs';
  static const String learnPaywallPrompt = 'learn.paywall_prompt';

  // Notification Events
  static const String notifSettingsOpened = 'notif.settings_opened';
  static const String notifEditOpened = 'notif.edit_opened';
  static const String notifCountChanged = 'notif.count_changed';
  static const String notifTimesChanged = 'notif.times_changed';
  static const String notifWeekdaysChanged = 'notif.weekdays_changed';
  static const String notifSourceChanged = 'notif.source_changed';
  static const String notifScheduledTotal = 'notif.scheduled_total';
  static const String notifDelivered = 'notif.delivered';
  static const String notifTapped = 'notif.tapped';
}


===== widgets/author_chip.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';

class AuthorChip extends StatelessWidget {
  final String authorName;
  final bool isSelected;
  final void Function(String)? onTap;

  const AuthorChip({
    super.key,
    required this.authorName,
    required this.isSelected,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();
    final colorScheme = Theme.of(context).colorScheme;

    return GestureDetector(
      onTap: () {
        if (onTap != null) {
          onTap!(authorName);
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? colorScheme.primary.withOpacity(0.12)
              : lbTheme?.controlSurface ?? colorScheme.surface,
          borderRadius: BorderRadius.circular(16.0),
          border: Border.all(
            color: isSelected
                ? colorScheme.primary
                : lbTheme?.controlBorder ??
                      colorScheme.outline.withOpacity(0.3),
            width: isSelected ? 1.0 : 0.5,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              authorName,
              style: Theme.of(context).textTheme.labelMedium?.copyWith(
                color: isSelected
                    ? colorScheme.primary
                    : colorScheme.onSurface.withOpacity(0.7),
                fontSize: 12.0,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
              ),
            ),
            if (isSelected) ...[
              const SizedBox(width: 6.0),
              Icon(Icons.close, size: 14.0, color: colorScheme.primary),
            ],
          ],
        ),
      ),
    );
  }
}


===== widgets/active_filters_bar.dart =====

import 'package:flutter/material.dart';

class ActiveFiltersBar extends StatelessWidget {
  final Set<String> selectedTags;
  final Set<String> selectedAuthors;
  final Map<String, dynamic>? periodFilter;
  final bool isFavoritesMode;
  final VoidCallback onClear;

  const ActiveFiltersBar({
    super.key,
    required this.selectedTags,
    required this.selectedAuthors,
    this.periodFilter,
    required this.isFavoritesMode,
    required this.onClear,
  });

  @override
  Widget build(BuildContext context) {
    final filters = [
      if (isFavoritesMode) 'Favorites',
      ...selectedTags,
      ...selectedAuthors,
      if (periodFilter != null)
        '${periodFilter!['start_year']}-${periodFilter!['end_year']}',
    ];

    if (filters.isEmpty) {
      return Container();
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      color: Theme.of(context).bottomAppBarTheme.color?.withOpacity(0.8),
      child: Row(
        children: [
          Expanded(
            child: SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Wrap(
                spacing: 8.0,
                children: filters.map((filter) {
                  return Chip(
                    label: Text(filter),
                    backgroundColor: Theme.of(
                      context,
                    ).chipTheme.backgroundColor,
                  );
                }).toList(),
              ),
            ),
          ),
          IconButton(icon: const Icon(Icons.clear), onPressed: onClear),
        ],
      ),
    );
  }
}


===== widgets/award_sheet.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/services/analytics.dart';

const Map<String, String> _featureDisplayNames = {
  'search': 'Search',
  'browse_tags': 'Browse by Tag',
  'browse_period': 'Browse by Period',
  'premium_themes': 'Premium Themes',
  'premium_fonts': 'Premium Fonts',
};

class AwardSheet extends StatelessWidget {
  final List<String> awardedFeatureKeys;
  final VoidCallback onSeeRewards;
  final ValueChanged<String> onTryFeature;

  const AwardSheet({
    super.key,
    required this.awardedFeatureKeys,
    required this.onSeeRewards,
    required this.onTryFeature,
  });

  @override
  Widget build(BuildContext context) {
    Analytics.instance.logEvent('award_sheet_opened', {
      'features': awardedFeatureKeys,
    });
    final bool isSingleAward = awardedFeatureKeys.length == 1;
    final String featureName = isSingleAward
        ? _featureDisplayNames[awardedFeatureKeys.first] ?? 'A New Feature'
        : 'New Features';

    return Container(
      padding: const EdgeInsets.all(24.0),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Text(
            'Unlocked: $featureName for 7 days',
            style: Theme.of(
              context,
            ).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          if (!isSingleAward)
            ...awardedFeatureKeys.map(
              (key) => Text(
                '• ${_featureDisplayNames[key] ?? key}',
                style: Theme.of(context).textTheme.titleMedium,
                textAlign: TextAlign.center,
              ),
            ),
          if (!isSingleAward) const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              if (isSingleAward) {
                onTryFeature(awardedFeatureKeys.first);
              } else {
                onSeeRewards();
              }
            },
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 16),
            ),
            child: Text(isSingleAward ? 'Try It' : 'See My Rewards'),
          ),
          const SizedBox(height: 8),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              if (isSingleAward) onSeeRewards();
            },
            child: Text(isSingleAward ? 'See My Rewards' : 'Dismiss'),
          ),
        ],
      ),
    );
  }
}


===== widgets/bottom_action_bar.dart =====

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';
import '../quote.dart';

class BottomActionBar extends StatelessWidget {
  final Quote currentQuote;
  final List<Quote> favoriteQuotes;
  final Map<String, int> likeCounts;
  final VoidCallback onShare;
  final VoidCallback onNext;
  final VoidCallback onPrevious;
  final VoidCallback onToggleFavorite;
  final void Function(BuildContext) onShowDetails;

  const BottomActionBar({
    super.key,
    required this.currentQuote,
    required this.favoriteQuotes,
    required this.likeCounts,
    required this.onShare,
    required this.onNext,
    required this.onPrevious,
    required this.onToggleFavorite,
    required this.onShowDetails,
  });

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>()!;

    return Container(
      width: double.infinity,
      height: 100.0,
      decoration: BoxDecoration(
        border: Border(top: BorderSide(width: 1, color: lbTheme.controlBorder)),
        color: lbTheme.controlSurface,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(30.0),
          topRight: Radius.circular(30.0),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.only(left: 25.0, right: 25.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: <Widget>[
            IconButton(
              icon: const Icon(Icons.share_outlined),
              iconSize: 24.0,
              color: lbTheme.controlOnSurface,
              onPressed: () {
                HapticFeedback.selectionClick();
                onShare();
              },
            ),
            IconButton(
              icon: const Icon(Icons.arrow_downward_outlined),
              iconSize: 24.0,
              color: lbTheme.controlOnSurface,
              onPressed: () {
                HapticFeedback.selectionClick();
                onNext();
              },
            ),
            IconButton(
              icon: Stack(
                clipBehavior: Clip.none,
                children: [
                  Icon(
                    favoriteQuotes.contains(currentQuote)
                        ? Icons.favorite
                        : Icons.favorite_border,
                    color: favoriteQuotes.contains(currentQuote)
                        ? Colors.red
                        : lbTheme.controlOnSurface,
                  ),
                  if ((likeCounts[currentQuote.id] ?? 0) > 1)
                    Positioned(
                      right: -8,
                      top: -4,
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 5,
                          vertical: 2,
                        ),
                        decoration: BoxDecoration(
                          color: Colors.red,
                          borderRadius: BorderRadius.circular(10),
                        ),
                        child: Text(
                          'x${likeCounts[currentQuote.id]}',
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 10,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                ],
              ),
              iconSize: 24.0,
              onPressed: () {
                HapticFeedback.lightImpact();
                onToggleFavorite();
              },
            ),
            IconButton(
              icon: const Icon(Icons.arrow_upward_outlined),
              iconSize: 24.0,
              color: lbTheme.controlOnSurface,
              onPressed: () {
                HapticFeedback.selectionClick();
                onPrevious();
              },
            ),
            Builder(
              builder: (context) {
                return IconButton(
                  icon: const Icon(Icons.sell_outlined),
                  iconSize: 24.0,
                  color: lbTheme.controlOnSurface,
                  onPressed: () {
                    HapticFeedback.selectionClick();
                    onShowDetails(context);
                  },
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}


===== widgets/streak_island.dart =====

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:lottie/lottie.dart';

class StreakIsland extends StatefulWidget {
  final String streakMessage;
  final List<Map<String, dynamic>> weeklyView; // Updated data structure
  final VoidCallback? onTap;
  final VoidCallback? onDismiss;

  const StreakIsland({
    super.key,
    required this.streakMessage,
    required this.weeklyView,
    this.onTap,
    this.onDismiss,
  });

  @override
  State<StreakIsland> createState() => _StreakIslandState();
}

class _StreakIslandState extends State<StreakIsland>
    with TickerProviderStateMixin {
  late AnimationController _slideController;
  late AnimationController _flameController;
  late Animation<Offset> _slideAnimation;

  @override
  void initState() {
    super.initState();

    _slideController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );

    _flameController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, -1), end: Offset.zero).animate(
          CurvedAnimation(parent: _slideController, curve: Curves.elasticOut),
        );

    // Add listener to detect when dismiss animation completes
    _slideController.addStatusListener((status) {
      if (status == AnimationStatus.dismissed) {
        widget.onDismiss?.call();
      }
    });

    // Start animations
    _slideController.forward();

    // Auto-hide after 5 seconds
    Future.delayed(const Duration(seconds: 5), () {
      if (mounted) {
        _slideController.reverse();
      }
    });
  }

  @override
  void dispose() {
    _slideController.dispose();
    _flameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Logic for generating days is now removed from here, as it's passed in.
    final days = widget.weeklyView;

    return SlideTransition(
      position: _slideAnimation,
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          margin: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
          padding: const EdgeInsets.all(16.0),
          decoration: BoxDecoration(
            color: Theme.of(context).cardColor,
            borderRadius: BorderRadius.circular(20.0),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1),
                spreadRadius: 2,
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
            border: Border.all(color: Theme.of(context).dividerColor, width: 1),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Streak message
              Text(
                widget.streakMessage,
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Theme.of(context).primaryColor,
                  fontFamily: 'EBGaramond',
                ),
              ),
              const SizedBox(height: 12),

              // Weekly view
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: days.map((day) {
                  return _buildDayIndicator(day);
                }).toList(),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDayIndicator(Map<String, dynamic> day) {
    final isCompleted = day['isCompleted'] as bool;
    final isToday = day['isToday'] as bool;
    final dayName = day['dayName'] as String; // Changed from 'day' to 'dayName'
    final isDark = Theme.of(context).brightness == Brightness.dark;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Day name
        Text(
          dayName,
          style: TextStyle(
            fontSize: 12,
            fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
            color: isToday
                ? (isDark ? Colors.orange.shade300 : Colors.orange.shade700)
                : (isDark ? Colors.grey.shade400 : Colors.grey.shade600),
            fontFamily: 'EBGaramond',
          ),
        ),
        const SizedBox(height: 4),

        // Day indicator
        Container(
          width: 48,
          height: 48,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: isCompleted
                ? Colors.orange.shade200
                : (isDark ? Colors.grey.shade700 : Colors.grey.shade300),
            border: Border.all(
              color: isToday
                  ? (isDark ? Colors.orange.shade300 : Colors.orange.shade700)
                  : Colors.transparent,
              width: isToday ? 2 : 0,
            ),
          ),
          child: isCompleted
              ? Center(
                  child: Container(
                    width: 36,
                    height: 36,
                    child: Lottie.asset(
                      'assets/animations/flame.json',
                      controller: _flameController,
                      onLoaded: (composition) {
                        _flameController.duration = composition.duration;
                        _flameController.repeat();
                      },
                      fit: BoxFit.contain,
                    ),
                  ),
                )
              : Container(),
        ),
      ],
    );
  }
}


===== widgets/milestone_celebration.dart =====

import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class SimpleCelebrationOverlay extends StatefulWidget {
  final String animationType; // 'confetti'
  final VoidCallback onComplete;

  const SimpleCelebrationOverlay({
    super.key,
    required this.animationType,
    required this.onComplete,
  });

  @override
  State<SimpleCelebrationOverlay> createState() =>
      _SimpleCelebrationOverlayState();
}

class _SimpleCelebrationOverlayState extends State<SimpleCelebrationOverlay>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();

    // Let the animation controller run for a long time to allow natural completion
    _controller = AnimationController(
      duration: const Duration(
        milliseconds: 10000,
      ), // Long duration, let Lottie control timing
      vsync: this,
    );

    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );

    _fadeAnimation = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(parent: _fadeController, curve: Curves.easeOut));

    _controller.forward();

    // Auto-complete after natural duration + fade
    Future.delayed(const Duration(milliseconds: 4000), () {
      if (mounted) {
        _fadeController.forward().then((_) {
          if (mounted) {
            widget.onComplete();
          }
        });
      }
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    _fadeController.dispose();
    super.dispose();
  }

  String get _animationPath {
    return 'assets/animations/confetti.json';
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _fadeAnimation,
        builder: (context, child) {
          return Opacity(
            opacity: _fadeAnimation.value,
            child: Container(
              width: double.infinity,
              height: double.infinity,
              child: Center(
                child: Lottie.asset(
                  _animationPath,
                  controller: _controller,
                  fit: BoxFit.contain,
                  alignment: Alignment.center,
                  repeat: false,
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}


===== widgets/notification_editor_sheet.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/models/notification_prefs.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/services/notification_service.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';
import 'package:quotes_app/quote.dart';
import 'package:quotes_app/browse_by_author.dart';
import 'package:quotes_app/browse.dart';

class NotificationEditorSheet extends StatefulWidget {
  final NotificationPrefs initialPrefs;
  final List<Quote> allQuotes;
  final List<Quote> favoriteQuotes;
  final Map<String, int> viewCounts;

  const NotificationEditorSheet({
    super.key,
    required this.initialPrefs,
    required this.allQuotes,
    required this.favoriteQuotes,
    required this.viewCounts,
  });

  @override
  State<NotificationEditorSheet> createState() =>
      _NotificationEditorSheetState();
}

class _NotificationEditorSheetState extends State<NotificationEditorSheet> {
  late NotificationPrefs _prefs;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _prefs = widget.initialPrefs;
    Analytics.instance.logEvent(Analytics.notifEditOpened);
  }

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();

    return Container(
      height: MediaQuery.of(context).size.height * 0.9,
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
      ),
      child: Column(
        children: [
          _buildHeader(),
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(16),
              children: [
                _buildTimesSection(lbTheme),
                const SizedBox(height: 24),
                _buildWeekdaysSection(lbTheme),
                const SizedBox(height: 24),
                _buildSourceSection(lbTheme),
                const SizedBox(height: 80), // Space for footer
              ],
            ),
          ),
          _buildFooter(),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor, width: 1),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Text(
            'Notification Settings',
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.w600),
          ),
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  Widget _buildTimesSection(LBTheme? lbTheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Times per Day',
          style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        Text(
          'Choose 1-6 times when you\'d like to receive quotes',
          style: TextStyle(
            color: Theme.of(
              context,
            ).textTheme.bodyMedium?.color?.withOpacity(0.7),
          ),
        ),
        const SizedBox(height: 16),

        // Count stepper
        Row(
          children: [
            IconButton(
              onPressed: _prefs.times.length > 1 ? _decreaseTimeCount : null,
              icon: const Icon(Icons.remove_circle_outline),
            ),
            Text(
              '${_prefs.times.length}',
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w600),
            ),
            IconButton(
              onPressed: _prefs.times.length < 6 ? _increaseTimeCount : null,
              icon: const Icon(Icons.add_circle_outline),
            ),
            const SizedBox(width: 16),
            Text(
              '${_prefs.times.length} time${_prefs.times.length == 1 ? '' : 's'} per day',
            ),
          ],
        ),

        const SizedBox(height: 16),

        // Time pickers
        ...List.generate(_prefs.times.length, (index) {
          return Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: _buildTimePicker(index, lbTheme),
          );
        }),
      ],
    );
  }

  Widget _buildTimePicker(int index, LBTheme? lbTheme) {
    final time = _prefs.times[index];

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: lbTheme?.controlSurface ?? Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: lbTheme?.controlBorder ?? Theme.of(context).dividerColor,
        ),
      ),
      child: Row(
        children: [
          Icon(_getIconForTime(time), color: Theme.of(context).primaryColor),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}',
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
            ),
          ),
          TextButton(
            onPressed: () => _editTime(index),
            child: const Text('Edit'),
          ),
        ],
      ),
    );
  }

  IconData _getIconForTime(TimeOfDay time) {
    if (time.hour < 6) return Icons.bedtime;
    if (time.hour < 12) return Icons.wb_sunny;
    if (time.hour < 18) return Icons.wb_sunny_outlined;
    return Icons.nights_stay;
  }

  Widget _buildWeekdaysSection(LBTheme? lbTheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Days of Week',
          style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        Text(
          'Select which days you want to receive notifications',
          style: TextStyle(
            color: Theme.of(
              context,
            ).textTheme.bodyMedium?.color?.withOpacity(0.7),
          ),
        ),
        const SizedBox(height: 16),

        Wrap(
          spacing: 8,
          children: List.generate(7, (index) {
            final weekday = index + 1; // 1=Monday, 7=Sunday
            final isSelected = _prefs.weekdays.contains(weekday);
            final dayName = _getDayName(weekday);

            return FilterChip(
              label: Text(dayName),
              selected: isSelected,
              onSelected: (selected) => _toggleWeekday(weekday),
              backgroundColor: lbTheme?.controlSurface,
              selectedColor: Theme.of(context).primaryColor.withOpacity(0.2),
              checkmarkColor: Theme.of(context).primaryColor,
            );
          }),
        ),
      ],
    );
  }

  String _getDayName(int weekday) {
    const names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return names[weekday - 1];
  }

  Widget _buildSourceSection(LBTheme? lbTheme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Quote Sources',
          style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        Text(
          'Filter quotes by authors or tags',
          style: TextStyle(
            color: Theme.of(
              context,
            ).textTheme.bodyMedium?.color?.withOpacity(0.7),
          ),
        ),
        const SizedBox(height: 16),

        // Authors
        _buildSourceSubsection(
          'Authors',
          _prefs.authors.isNotEmpty
              ? '${_prefs.authors.length} selected'
              : 'All authors',
          () => _editAuthors(),
          lbTheme,
        ),

        const SizedBox(height: 12),

        // Tags
        _buildSourceSubsection(
          'Tags',
          _prefs.tags.isNotEmpty
              ? '${_prefs.tags.length} selected'
              : 'All tags',
          () => _editTags(),
          lbTheme,
        ),

        const SizedBox(height: 12),
      ],
    );
  }

  Widget _buildSourceSubsection(
    String title,
    String subtitle,
    VoidCallback onTap,
    LBTheme? lbTheme,
  ) {
    return Container(
      decoration: BoxDecoration(
        color: lbTheme?.controlSurface ?? Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: lbTheme?.controlBorder ?? Theme.of(context).dividerColor,
        ),
      ),
      child: ListTile(
        title: Text(title),
        subtitle: Text(subtitle),
        trailing: const Icon(Icons.chevron_right),
        onTap: onTap,
      ),
    );
  }

  Widget _buildFooter() {
    return Container(
      padding: EdgeInsets.only(
        left: 16,
        right: 16,
        top: 16,
        bottom: 16 + MediaQuery.of(context).padding.bottom,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        border: Border(
          top: BorderSide(color: Theme.of(context).dividerColor, width: 1),
        ),
      ),
      child: Row(
        children: [
          Expanded(
            child: OutlinedButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Cancel'),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: ElevatedButton(
              onPressed: _isLoading ? null : _savePreferences,
              child: _isLoading
                  ? const SizedBox(
                      height: 16,
                      width: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Save'),
            ),
          ),
        ],
      ),
    );
  }

  void _increaseTimeCount() {
    if (_prefs.times.length >= 6) return;

    setState(() {
      final newTimes = List<TimeOfDay>.from(_prefs.times);
      // Add a new time 2 hours after the last one, wrapping around if needed
      final lastTime = newTimes.last;
      final newHour = (lastTime.hour + 2) % 24;
      newTimes.add(TimeOfDay(hour: newHour, minute: lastTime.minute));
      newTimes.sort((a, b) => a.hour.compareTo(b.hour));

      _prefs = _prefs.copyWith(times: newTimes);
    });

    Analytics.instance.logEvent(Analytics.notifCountChanged, {
      'count': _prefs.times.length,
    });
  }

  void _decreaseTimeCount() {
    if (_prefs.times.length <= 1) return;

    setState(() {
      final newTimes = List<TimeOfDay>.from(_prefs.times);
      newTimes.removeLast();

      _prefs = _prefs.copyWith(times: newTimes);
    });

    Analytics.instance.logEvent(Analytics.notifCountChanged, {
      'count': _prefs.times.length,
    });
  }

  void _editTime(int index) async {
    final currentTime = _prefs.times[index];
    final newTime = await showTimePicker(
      context: context,
      initialTime: currentTime,
    );

    if (newTime != null && newTime != currentTime) {
      setState(() {
        final newTimes = List<TimeOfDay>.from(_prefs.times);
        newTimes[index] = newTime;
        newTimes.sort((a, b) => a.hour.compareTo(b.hour));

        _prefs = _prefs.copyWith(times: newTimes);
      });

      Analytics.instance.logEvent(Analytics.notifTimesChanged, {
        'times': _prefs.times.map((t) => '${t.hour}:${t.minute}').toList(),
      });
    }
  }

  void _toggleWeekday(int weekday) {
    setState(() {
      final newWeekdays = Set<int>.from(_prefs.weekdays);
      if (newWeekdays.contains(weekday)) {
        // Don't allow removing all weekdays
        if (newWeekdays.length > 1) {
          newWeekdays.remove(weekday);
        }
      } else {
        newWeekdays.add(weekday);
      }

      _prefs = _prefs.copyWith(weekdays: newWeekdays);
    });

    Analytics.instance.logEvent(Analytics.notifWeekdaysChanged, {
      'days': _prefs.weekdays.length,
    });
  }

  void _editAuthors() async {
    final result = await Navigator.push<Set<String>>(
      context,
      MaterialPageRoute(
        builder: (context) => BrowseByAuthorPage(
          allQuotes: widget.allQuotes,
          initialSelectedAuthors: _prefs.authors,
        ),
      ),
    );

    if (result != null) {
      setState(() {
        _prefs = _prefs.copyWith(authors: result);
      });

      Analytics.instance.logEvent(Analytics.notifSourceChanged, {
        'authors_n': result.length,
        'tags_n': _prefs.tags.length,
      });
    }
  }

  void _editTags() async {
    final result = await Navigator.push<Set<String>>(
      context,
      MaterialPageRoute(
        builder: (context) => BrowsePage(
          allQuotes: widget.allQuotes,
          initialSelectedTags: _prefs.tags,
        ),
      ),
    );

    if (result != null) {
      setState(() {
        _prefs = _prefs.copyWith(tags: result);
      });

      Analytics.instance.logEvent(Analytics.notifSourceChanged, {
        'authors_n': _prefs.authors.length,
        'tags_n': result.length,
      });
    }
  }

  void _savePreferences() async {
    setState(() {
      _isLoading = true;
    });

    try {
      // Save preferences
      await NotificationService.saveNotificationPrefs(_prefs);

      // Sync notifications with new preferences
      await NotificationService.syncWithPrefs(
        _prefs,
        DateTime.now(),
        feed: widget.allQuotes,
        favoriteQuotes: widget.favoriteQuotes,
      );

      if (mounted) {
        Navigator.of(context).pop(_prefs);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Notification preferences saved!'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving preferences: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}


===== widgets/paywall.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/services/purchase_service.dart';
import 'package:quotes_app/services/revenuecat_keys.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';
import 'package:quotes_app/services/entitlements_service.dart';

class Paywall extends StatefulWidget {
  final String contextKey;
  final PurchasePlan initialPlan;

  const Paywall({
    super.key,
    required this.contextKey,
    this.initialPlan = PurchasePlan.annual,
  });

  @override
  State<Paywall> createState() => _PaywallState();
}

class _PaywallState extends State<Paywall> {
  late PurchasePlan _selectedPlan;
  // bool _showLifetime = false; // deprecated: lifetime removed
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _selectedPlan = widget.initialPlan;
    Analytics.instance.logEvent('paywall.view', {'context': widget.contextKey});
    Future.microtask(() async {
      await PurchaseService.instance.ensureOfferingsLoaded();
      if (mounted) setState(() {});
    });
  }

  Map<String, List<String>> get _contextualBullets {
    final proFeatures = EntitlementsService.proFeatureDisplayNames;
    return {
      'browse_tags': [
        'Unlock all tags and eras',
        'Open the full library (~5,000 quotes)',
        'Follow interests deeper with Tag/Period',
      ],
      'browse_author': [
        proFeatures[EntitlementsService.browseAuthor]!,
        'Deep author collections',
        'Full library access (~5,000 quotes)',
        'Discover new voices',
      ],
      'browse_period': [
        proFeatures[EntitlementsService.browsePeriod]!,
        'Unlock the premium library',
        'See era‑specific highlights',
        'Time‑based discovery made easy',
      ],
      'settings_theme': [
        proFeatures[EntitlementsService.premiumThemes]!,
        'Share without watermark',
        'Home/lock‑screen widgets',
        'Make it feel uniquely yours',
      ],
      'settings_font': [
        proFeatures[EntitlementsService.premiumFonts]!,
        'Beautiful, readable typography',
        'Share without watermark',
        'Make every quote look right',
      ],
      'profile_upgrade': proFeatures.values.toList(),
      'reward_upgrade': [
        'Keep your unlocked feature forever',
        ...proFeatures.values,
      ],
      'learn_trainer': [
        proFeatures[EntitlementsService.learnTrainer]!,
        'Adaptive difficulty',
        'Review mistakes faster',
        'Master quotes with spaced repetition',
      ],
      'srs_unlimited': [
        proFeatures[EntitlementsService.srsUnlimited]!,
        'Master quotes with spaced repetition',
        'Track your progress',
        'Build lasting memory',
      ],
      'notif_customization': [
        'Pick times that fit your day',
        'Filter by authors or tags',
        'Weekday schedules',
        'Personalized reminder flow',
      ],
    };
  }

  List<String> get _bullets =>
      _contextualBullets[widget.contextKey] ??
      _contextualBullets['profile_upgrade']!;

  String _contextualHeadline() {
    switch (widget.contextKey) {
      case 'browse_tags':
        return 'Explore by tag & era — without limits';
      case 'browse_author':
        return 'Browse authors A–Z, fully unlocked';
      case 'browse_period':
        return 'See every era, fully unlocked';
      case 'settings_theme':
        return 'Make it yours. Premium looks.';
      case 'settings_font':
        return 'Typography that feels right.';
      case 'reward_upgrade':
        return 'Keep today\'s reward forever';
      case 'learn_trainer':
        return 'Learn smarter with guided sessions';
      case 'srs_unlimited':
        return 'Master every quote with unlimited reviews';
      case 'notif_customization':
        return 'Reminders that fit your schedule';
      default:
        return 'Read smarter. Unlock more.';
    }
  }

  String _ctaLabel() {
    final trialDescription = PurchaseService.instance.getTrialDescription(
      _selectedPlan,
    );
    if (trialDescription != null) {
      return trialDescription;
    }
    return 'Continue';
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Handle bar
          Container(
            width: 40,
            height: 4,
            margin: const EdgeInsets.only(top: 12),
            decoration: BoxDecoration(
              color: Theme.of(context).disabledColor.withOpacity(0.3),
              borderRadius: BorderRadius.circular(2),
            ),
          ),

          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(24),
              children: [
                _buildHeader(),
                const SizedBox(height: 32),
                _buildHeadline(),
                const SizedBox(height: 24),
                _buildBullets(),
                _buildAllProFeaturesExpandable(),
                const SizedBox(height: 24),
                _buildPlanCards(),
                const SizedBox(height: 24),
                _buildCTASection(),
                const SizedBox(height: 16),
                _buildLegalFooter(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          'Literature Bites',
          style: TextStyle(
            fontSize: 32,
            fontWeight: FontWeight.bold,
            color: Theme.of(context).primaryColor,
            fontFamily: 'EBGaramond',
          ),
        ),
        const SizedBox(width: 8),
        // Lottie.asset('assets/lottie/badge_sparkle.json', width: 24, height: 24),
      ],
    );
  }

  Widget _buildHeadline() {
    return Text(
      _contextualHeadline(),
      textAlign: TextAlign.center,
      style: TextStyle(
        fontSize: 28,
        fontWeight: FontWeight.w600,
        color: Theme.of(context).primaryColor,
        height: 1.15,
      ),
    );
  }

  Widget _buildBullets() {
    return Column(
      children: _bullets.map((bullet) {
        return Padding(
          padding: const EdgeInsets.only(bottom: 12),
          child: Row(
            children: [
              Container(
                width: 6,
                height: 6,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [
                      Theme.of(context).colorScheme.secondary,
                      Theme.of(context).colorScheme.primary,
                    ],
                  ),
                  borderRadius: BorderRadius.circular(3),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  bullet,
                  style: TextStyle(
                    fontSize: 16,
                    color: Theme.of(context).primaryColor.withOpacity(0.8),
                    height: 1.4,
                  ),
                ),
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  Widget _buildAllProFeaturesExpandable() {
    final proFeatures = EntitlementsService.proFeatureDisplayNames;
    final Map<String, List<String>> groups = {
      'Explore': [
        'Full premium quotes library',
        proFeatures[EntitlementsService.browseAuthor]!,
        proFeatures[EntitlementsService.browsePeriod]!,
        'Curated Author Collections',
        'Intelligent recommendation algorithm',
      ],
      'Customize': [
        proFeatures[EntitlementsService.premiumThemes]!,
        proFeatures[EntitlementsService.premiumFonts]!,
        proFeatures[EntitlementsService.premiumShareStyles]!,
      ],
      'Learn': [
        proFeatures[EntitlementsService.srsUnlimited]!,
        proFeatures[EntitlementsService.learnTrainer]!,
      ],
      'Notifications': [
        'Custom count & times',
        'Smart Schedule',
        'Customise by author/tag',
      ],
    };

    return Theme(
      data: Theme.of(context).copyWith(dividerColor: Colors.transparent),
      child: ExpansionTile(
        tilePadding: EdgeInsets.zero,
        childrenPadding: const EdgeInsets.only(top: 8),
        initiallyExpanded: false,
        title: Row(
          children: [
            Icon(
              Icons.workspace_premium_outlined,
              color: Theme.of(context).primaryColor.withOpacity(0.8),
            ),
            const SizedBox(width: 8),
            Text(
              'Everything in Pro',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: Theme.of(context).primaryColor,
              ),
            ),
          ],
        ),
        children: groups.entries
            .map((e) => _featureGroup(e.key, e.value))
            .toList(),
      ),
    );
  }

  Widget _featureGroup(String title, List<String> items) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 6),
            child: Text(
              title,
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).primaryColor.withOpacity(0.9),
              ),
            ),
          ),
          ...items.map(
            (it) => Padding(
              padding: const EdgeInsets.only(bottom: 6),
              child: Row(
                children: [
                  const Icon(Icons.check_circle_outline, size: 16),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      it,
                      style: TextStyle(
                        fontSize: 14,
                        height: 1.35,
                        color: Theme.of(context).primaryColor.withOpacity(0.8),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPlanCards() {
    return Column(
      children: [
        _buildPlanCard(PurchasePlan.annual, isRecommended: true),
        const SizedBox(height: 12),
        _buildPlanCard(PurchasePlan.monthly),
      ],
    );
  }

  Widget _buildPlanCard(PurchasePlan plan, {bool isRecommended = false}) {
    final theme = Theme.of(context);
    final lbTheme = theme.extension<LBTheme>()!;
    final isSelected = _selectedPlan == plan;

    final rawName = PurchaseService.instance.getPlanDisplayName(plan);
    final planName = (rawName.trim().isNotEmpty)
        ? rawName
        : (plan == PurchasePlan.annual ? 'Pro Annual' : 'Pro Monthly');

    final price = PurchaseService.instance.getPlanPrice(plan);

    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedPlan = plan;
        });
        Analytics.instance.logEvent('paywall.select_plan', {'plan': plan.id});
      },
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected
                ? theme.colorScheme.primary
                : lbTheme.controlBorder.withOpacity(0.5),
            width: isSelected ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(12),
          color: isSelected
              ? theme.colorScheme.primary.withOpacity(0.05)
              : lbTheme.controlSurface,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  planName,
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    color: Theme.of(context).primaryColor,
                  ),
                ),
                if (isRecommended)
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [
                          theme.colorScheme.secondary,
                          theme.colorScheme.primary,
                        ],
                      ),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: const Text(
                      'Best Value',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              price ?? '—',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Theme.of(context).primaryColor,
              ),
            ),
            if (plan == PurchasePlan.annual)
              Text(
                '${PurchaseService.instance.getAnnualPerMonthPrice() ?? '... '}/month',
                style: TextStyle(
                  fontSize: 14,
                  color: Theme.of(context).primaryColor.withOpacity(0.6),
                ),
              ),
            if (plan == PurchasePlan.annual)
              Text(
                'Best value for regular readers',
                style: TextStyle(
                  fontSize: 12,
                  color: Theme.of(context).primaryColor.withOpacity(0.55),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildCTASection() {
    return Column(
      children: [
        SizedBox(
          width: double.infinity,
          height: 50,
          child: Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [
                  Theme.of(context).colorScheme.secondary,
                  Theme.of(context).colorScheme.primary,
                ],
                begin: Alignment.centerLeft,
                end: Alignment.centerRight,
              ),
              borderRadius: BorderRadius.circular(25),
            ),
            child: ElevatedButton(
              onPressed: _isLoading ? null : _handlePurchase,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.transparent,
                shadowColor: Colors.transparent,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(25),
                ),
              ),
              child: _isLoading
                  ? const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      ),
                    )
                  : Text(
                      _ctaLabel(),
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                      ),
                    ),
            ),
          ),
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            TextButton(
              onPressed: () {
                setState(() {
                  _selectedPlan = PurchasePlan.monthly;
                });
                Analytics.instance.logEvent('paywall.select_plan', {
                  'plan': 'monthly',
                });
              },
              child: Text(
                'See monthly',
                style: TextStyle(
                  color: Theme.of(context).primaryColor.withOpacity(0.7),
                ),
              ),
            ),
            TextButton(
              onPressed: _handleRestore,
              child: Text(
                'Restore purchases',
                style: TextStyle(
                  color: Theme.of(context).primaryColor.withOpacity(0.7),
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildLegalFooter() {
    final price = PurchaseService.instance.getPlanPrice(_selectedPlan);
    final trialDescription = PurchaseService.instance.getTrialDescription(
      _selectedPlan,
    );

    String text;
    if (trialDescription != null) {
      text =
          '$trialDescription, then $price per ${_selectedPlan == PurchasePlan.monthly ? 'month' : 'year'}. Cancel anytime.';
    } else {
      text =
          'Billed $price per ${_selectedPlan == PurchasePlan.monthly ? 'month' : 'year'}. Cancel anytime.';
    }

    return Column(
      children: [
        Text(
          text,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 12,
            color: Theme.of(context).primaryColor.withOpacity(0.6),
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Cancel anytime • Keep your favorites and notes',
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: 12,
            color: Theme.of(context).primaryColor.withOpacity(0.6),
          ),
        ),
        const SizedBox(height: 12),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextButton(
              onPressed: () => launchUrl(
                Uri.parse(
                  'https://singhalkrishiv.wixsite.com/literature-bites/privacy-policy',
                ),
              ),
              child: Text(
                'Privacy',
                style: TextStyle(
                  fontSize: 12,
                  color: Theme.of(context).primaryColor.withOpacity(0.6),
                ),
              ),
            ),
            Text(
              ' • ',
              style: TextStyle(
                color: Theme.of(context).primaryColor.withOpacity(0.6),
              ),
            ),
            TextButton(
              onPressed: () => launchUrl(
                Uri.parse(
                  'https://singhalkrishiv.wixsite.com/literature-bites/privacy-policy',
                ),
              ),
              child: Text(
                'Terms',
                style: TextStyle(
                  fontSize: 12,
                  color: Theme.of(context).primaryColor.withOpacity(0.6),
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Future<void> _handlePurchase() async {
    setState(() {
      _isLoading = true;
    });

    Analytics.instance.logEvent('paywall.cta_press', {
      'plan': _selectedPlan.id,
    });

    try {
      final success = await PurchaseService.instance.purchase(_selectedPlan.id);

      if (success && mounted) {
        Navigator.of(
          context,
        ).pop(true); // Return true to indicate successful purchase
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Welcome to Literature Bites Pro!'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Purchase failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _handleRestore() async {
    Analytics.instance.logEvent('paywall.restore');
    final isProBefore = await EntitlementsService.instance.isPro();

    try {
      final customerInfo = await PurchaseService.instance.restore();
      final isProAfter =
          customerInfo.entitlements.all[rcEntitlementKey]?.isActive ?? false;

      if (mounted) {
        if (isProAfter && !isProBefore) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Purchases restored successfully.'),
              backgroundColor: Colors.green,
            ),
          );
          Navigator.of(context).pop(true); // Pop paywall on success
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('No new purchases to restore.')),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Restore failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}


===== widgets/pro_badge.dart =====

import 'package:flutter/material.dart';

class ProBadge extends StatelessWidget {
  final double fontSize;
  final EdgeInsets padding;

  const ProBadge({
    super.key,
    this.fontSize = 10,
    this.padding = const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    return Container(
      padding: padding,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [cs.primary, cs.secondary],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: cs.primary.withOpacity(0.2),
            blurRadius: 4,
            offset: const Offset(0, 1),
          ),
        ],
      ),
      child: Text(
        'PRO',
        style: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: fontSize,
          letterSpacing: 0.3,
        ),
      ),
    );
  }
}


===== widgets/settings_sheet.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/profile_rewards_page.dart';
import 'package:quotes_app/services/analytics.dart';
import 'package:quotes_app/services/entitlements_service.dart';
import 'package:quotes_app/services/notification_service.dart';
import 'package:quotes_app/services/theme_controller.dart';
import 'package:quotes_app/theme/theme_registry.dart';
import 'package:quotes_app/utils/feature_gate.dart';
import 'package:quotes_app/models/notification_prefs.dart';
import 'package:quotes_app/widgets/notification_editor_sheet.dart';
import 'package:quotes_app/quote.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:quotes_app/services/purchase_service.dart';
import 'package:quotes_app/services/revenuecat_keys.dart';

class SettingsSheet extends StatefulWidget {
  final List<Quote>? allQuotes;
  final List<Quote>? favoriteQuotes;
  final Map<String, int>? viewCounts;

  const SettingsSheet({
    super.key,
    this.allQuotes,
    this.favoriteQuotes,
    this.viewCounts,
  });

  @override
  State<SettingsSheet> createState() => _SettingsSheetState();
}

class _SettingsSheetState extends State<SettingsSheet> {
  late String _previewThemeId;
  late String _previewFontId;
  bool _isPro = false;
  NotificationPrefs? _notificationPrefs;

  @override
  void initState() {
    super.initState();
    _previewThemeId = ThemeController.instance.themeId;
    _previewFontId = ThemeController.instance.fontId;
    _loadProStatus();
    _loadNotificationPrefs();
    Analytics.instance.logEvent('settings.opened');
  }

  Future<void> _loadProStatus() async {
    final proStatus = await EntitlementsService.instance.isPro();
    if (mounted) {
      setState(() {
        _isPro = proStatus;
      });
    }
  }

  Future<void> _loadNotificationPrefs() async {
    final prefs = await NotificationService.loadNotificationPrefs();
    if (mounted) {
      setState(() {
        _notificationPrefs = prefs;
      });
    }
  }

  void _openPaywall(String contextKey) {
    openPaywall(context: context, contextKey: contextKey).then((result) {
      // If purchase was successful, refresh the UI
      if (result == true) {
        setState(() {
          _loadProStatus();
        });
      }
    });
  }

  Future<void> _handleRestore() async {
    Analytics.instance.logEvent('settings.restore');
    final isProBefore = await EntitlementsService.instance.isPro();

    try {
      final customerInfo = await PurchaseService.instance.restore();
      final isProAfter =
          customerInfo.entitlements.all[rcEntitlementKey]?.isActive ?? false;

      if (mounted) {
        if (isProAfter && !isProBefore) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Purchases restored successfully.'),
              backgroundColor: Colors.green,
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('No new purchases to restore.')),
          );
        }
        _loadProStatus();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Restore failed: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12.0),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(24),
          topRight: Radius.circular(24),
        ),
      ),
      child: Column(
        children: [
          _buildHeader(),
          const SizedBox(height: 16),
          Expanded(
            child: ListView(
              shrinkWrap: true,
              children: [
                _buildPreview(),
                const SizedBox(height: 24),
                _buildSectionTitle('Theme'),
                const SizedBox(height: 12),
                _buildThemeSelector(),
                const SizedBox(height: 24),
                _buildSectionTitle('Font'),
                const SizedBox(height: 12),
                _buildFontSelector(),
                const SizedBox(height: 24),
                const Divider(height: 1, indent: 12, endIndent: 12),
                const SizedBox(height: 16),
                _buildSectionTitle('Reminders'),
                const SizedBox(height: 12),
                _buildRemindersSection(),
                const SizedBox(height: 24),
                const Divider(height: 1, indent: 12, endIndent: 12),
                const SizedBox(height: 16),
                _buildSectionTitle('Rewards & Account'),
                const SizedBox(height: 12),
                _buildAccountSection(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          children: [
            const Text(
              'Settings',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            if (_isPro)
              Container(
                margin: const EdgeInsets.only(left: 8),
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.amber,
                  borderRadius: BorderRadius.circular(4),
                ),
                child: const Text(
                  'PRO',
                  style: TextStyle(
                    fontSize: 10,
                    color: Colors.black,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
          ],
        ),
        IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => Navigator.of(context).pop(),
        ),
      ],
    );
  }

  Widget _buildPreview() {
    final previewTheme = ThemeRegistry.getTheme(
      _previewThemeId,
      _previewFontId,
    );
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: previewTheme.scaffoldBackgroundColor,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: previewTheme.dividerColor),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Live text sample with current font
          Text(
            '"The measure of intelligence is the ability to change."',
            style: previewTheme.textTheme.bodyLarge?.copyWith(fontSize: 16),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            '— Albert Einstein',
            style: previewTheme.textTheme.bodyMedium?.copyWith(
              fontStyle: FontStyle.italic,
              color: previewTheme.textTheme.bodyMedium?.color?.withOpacity(0.7),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12.0),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w600,
          color: Colors.grey,
        ),
      ),
    );
  }

  Widget _buildThemeSelector() {
    final themes = {
      'Light': lightThemeId,
      'Dark': darkThemeId,
      'Sand': sandThemeId,
      'Ink': inkThemeId,
      'Rose': roseThemeId,
      'Noir': noirThemeId,
    };
    final freeThemes = [lightThemeId, darkThemeId];

    return SizedBox(
      height: 70,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: themes.entries.map((entry) {
          final isPremium = !freeThemes.contains(entry.value);
          return _buildSelectorTile(
            label: entry.key,
            isSelected: _previewThemeId == entry.value,
            isPremium: isPremium,
            featureKey: 'premium_themes',
            onTap: () {
              if (isPremium && !_isPro) {
                _openPaywall('settings_theme');
                return;
              }
              setState(() {
                _previewThemeId = entry.value;
              });

              // For free themes, apply directly without feature gate
              if (!isPremium) {
                ThemeController.instance.setTheme(entry.value);
                Analytics.instance.logEvent('settings.theme_selected', {
                  'themeId': entry.value,
                });
                return;
              }

              // For premium themes, check feature access
              requireFeature(
                context,
                'premium_themes',
                onAllowed: () {
                  ThemeController.instance.setTheme(entry.value);
                  Analytics.instance.logEvent('settings.theme_selected', {
                    'themeId': entry.value,
                  });
                },
                onBlocked: () {
                  Analytics.instance.logEvent('settings.locked_theme_tapped');
                  _openPaywall('settings_theme');
                },
              );
            },
          );
        }).toList(),
      ),
    );
  }

  Widget _buildFontSelector() {
    final fonts = {
      'Garamond': garamondFontId,
      'PT Sans Narrow': ptSansNarrowFontId,
      'Tangerine': tangerineFontId,
    };
    final freeFonts = [garamondFontId];

    return SizedBox(
      height: 60,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: fonts.entries.map((entry) {
          final isPremium = !freeFonts.contains(entry.value);
          final fontTheme = ThemeRegistry.getTheme(
            _previewThemeId,
            entry.value,
          );

          return _buildFontSelectorTile(
            label: entry.key,
            fontTheme: fontTheme,
            isSelected: _previewFontId == entry.value,
            isPremium: isPremium,
            featureKey: 'premium_fonts',
            onTap: () {
              if (isPremium && !_isPro) {
                _openPaywall('settings_font');
                return;
              }
              setState(() {
                _previewFontId = entry.value;
              });

              // For free fonts, apply directly without feature gate
              if (!isPremium) {
                ThemeController.instance.setFont(entry.value);
                Analytics.instance.logEvent('settings.font_selected', {
                  'fontId': entry.value,
                });
                return;
              }

              // For premium fonts, check feature access
              requireFeature(
                context,
                'premium_fonts',
                onAllowed: () {
                  ThemeController.instance.setFont(entry.value);
                  Analytics.instance.logEvent('settings.font_selected', {
                    'fontId': entry.value,
                  });
                },
                onBlocked: () {
                  Analytics.instance.logEvent('settings.locked_font_tapped');
                  _openPaywall('settings_font');
                },
              );
            },
          );
        }).toList(),
      ),
    );
  }

  Widget _buildSelectorTile({
    required String label,
    required bool isSelected,
    required bool isPremium,
    required String featureKey,
    required VoidCallback onTap,
  }) {
    return FutureBuilder<bool>(
      future: EntitlementsService.instance.isFeatureActive(featureKey),
      builder: (context, snapshot) {
        final isAllowed = snapshot.data ?? false;
        final showLock = isPremium && !isAllowed && !_isPro;
        return InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(8),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 4),
            padding: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              color: isSelected
                  ? Theme.of(context).primaryColor.withOpacity(0.1)
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isSelected
                    ? Theme.of(context).primaryColor
                    : Colors.grey.shade300,
                width: isSelected ? 2 : 1,
              ),
            ),
            child: Row(
              children: [
                Text(
                  label,
                  style: TextStyle(
                    fontWeight: isSelected
                        ? FontWeight.bold
                        : FontWeight.normal,
                  ),
                ),
                if (showLock)
                  const Padding(
                    padding: EdgeInsets.only(left: 8.0),
                    child: Icon(Icons.lock, size: 14, color: Colors.grey),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildFontSelectorTile({
    required String label,
    required ThemeData fontTheme,
    required bool isSelected,
    required bool isPremium,
    required String featureKey,
    required VoidCallback onTap,
  }) {
    return FutureBuilder<bool>(
      future: EntitlementsService.instance.isFeatureActive(featureKey),
      builder: (context, snapshot) {
        final isAllowed = snapshot.data ?? false;
        final showLock = isPremium && !isAllowed && !_isPro;
        return InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(8),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 4),
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: isSelected
                  ? Theme.of(context).primaryColor.withOpacity(0.1)
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isSelected
                    ? Theme.of(context).primaryColor
                    : Colors.grey.shade300,
                width: isSelected ? 2 : 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  label,
                  style: fontTheme.textTheme.titleMedium?.copyWith(
                    fontSize: 14,
                    fontWeight: isSelected
                        ? FontWeight.bold
                        : FontWeight.normal,
                  ),
                ),
                if (showLock)
                  const Padding(
                    padding: EdgeInsets.only(left: 6.0),
                    child: Icon(Icons.lock, size: 12, color: Colors.grey),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildRemindersSection() {
    if (_notificationPrefs == null) {
      return const ListTile(
        leading: Icon(Icons.notifications_outlined),
        title: Text('Reminders: Loading...'),
        dense: true,
      );
    }

    final prefs = _notificationPrefs!;

    if (_isPro) {
      // Pro user - show current settings with edit button
      return Column(
        children: [
          ListTile(
            leading: const Icon(Icons.notifications_outlined),
            title: Text('Reminders: ${prefs.scheduleDescription}'),
            subtitle: Text(prefs.timesDisplay),
            trailing: TextButton(
              onPressed: _openNotificationEditor,
              child: const Text('Edit'),
            ),
            dense: true,
          ),
          if (prefs.authors.isNotEmpty ||
              prefs.tags.isNotEmpty ||
              prefs.startYear != null)
            Padding(
              padding: const EdgeInsets.only(left: 56, right: 16, bottom: 8),
              child: Text(
                _getSourceDescription(prefs),
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(
                    context,
                  ).textTheme.bodySmall?.color?.withOpacity(0.7),
                ),
              ),
            ),
        ],
      );
    } else {
      // Free user - show current with Pro nudge
      return ListTile(
        leading: const Icon(Icons.notifications_outlined),
        title: Text('Reminders: ${prefs.scheduleDescription}'),
        subtitle: const Text('Customize in Pro'),
        trailing: TextButton(
          onPressed: () {
            Analytics.instance.logEvent(Analytics.notifSettingsOpened);
            _openPaywall('notif_customization');
          },
          child: const Text('See options'),
        ),
        dense: true,
      );
    }
  }

  String _getSourceDescription(NotificationPrefs prefs) {
    final parts = <String>[];

    if (prefs.authors.isNotEmpty) {
      parts.add(
        '${prefs.authors.length} author${prefs.authors.length == 1 ? '' : 's'}',
      );
    }

    if (prefs.tags.isNotEmpty) {
      parts.add('${prefs.tags.length} tag${prefs.tags.length == 1 ? '' : 's'}');
    }

    if (prefs.startYear != null && prefs.endYear != null) {
      parts.add('${prefs.startYear}-${prefs.endYear}');
    }

    if (parts.isEmpty) {
      return 'From all quotes';
    }

    return 'From: ${parts.join(', ')}';
  }

  void _openNotificationEditor() async {
    Analytics.instance.logEvent(Analytics.notifEditOpened);

    if (widget.allQuotes == null || _notificationPrefs == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Data not available for editing')),
      );
      return;
    }

    final result = await showModalBottomSheet<NotificationPrefs>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => NotificationEditorSheet(
        initialPrefs: _notificationPrefs!,
        allQuotes: widget.allQuotes!,
        favoriteQuotes: widget.favoriteQuotes ?? [],
        viewCounts: widget.viewCounts ?? {},
      ),
    );

    if (result != null) {
      // Refresh the preferences
      _loadNotificationPrefs();
    }
  }

  Widget _buildAccountSection() {
    return Column(
      children: [
        ListTile(
          leading: const Icon(Icons.star_outline),
          title: const Text('Rewards & Passes'),
          onTap: () {
            Navigator.of(context).push(
              MaterialPageRoute(
                builder: (context) => const ProfileRewardsPage(),
              ),
            );
          },
        ),
        ListTile(
          leading: const Icon(Icons.restore),
          title: const Text('Restore Purchases'),
          onTap: _handleRestore,
        ),
        ListTile(
          leading: const Icon(Icons.info_outline),
          title: const Text('About'),
          onTap: () => launchUrl(
            Uri.parse('https://singhalkrishiv.wixsite.com/literature-bites'),
          ),
        ),
        ListTile(
          leading: const Icon(Icons.privacy_tip_outlined),
          title: const Text('Privacy & Terms'),
          onTap: () => launchUrl(
            Uri.parse(
              'https://singhalkrishiv.wixsite.com/literature-bites/privacy-policys',
            ),
          ),
        ),
      ],
    );
  }
}


===== widgets/details_popup.dart =====

import 'package:flutter/material.dart';
import '../quote.dart';
import '../services/entitlements_service.dart';
import '../utils/feature_gate.dart';

class DetailsPopupContent extends StatefulWidget {
  final Quote quote;
  final Widget Function(String, {void Function(String)? onTap}) buildTagChip;
  final Widget Function(String, {void Function(String)? onTap}) buildAuthorChip;
  final void Function(String) onTagToggled;
  final void Function(String) onAuthorToggled;
  final VoidCallback? onRequestClose;

  const DetailsPopupContent({
    super.key,
    required this.quote,
    required this.buildTagChip,
    required this.buildAuthorChip,
    required this.onTagToggled,
    required this.onAuthorToggled,
    this.onRequestClose,
  });

  @override
  State<DetailsPopupContent> createState() => _DetailsPopupContentState();
}

class _DetailsPopupContentState extends State<DetailsPopupContent> {
  bool _isPro = false;
  bool _isClosing = false;

  @override
  void initState() {
    super.initState();
    _checkProStatus();
  }

  void _close() {
    if (_isClosing) return;
    _isClosing = true;
    // Prefer callback if provided so the parent can handle the overlay dismissal
    if (widget.onRequestClose != null) {
      widget.onRequestClose!();
      return;
    }
    // Fallback: try closing any enclosing route if present
    if (Navigator.of(context).canPop()) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted && Navigator.of(context).canPop()) {
          Navigator.of(context).pop();
        }
      });
    }
  }

  void _checkProStatus() async {
    final isPro = await EntitlementsService.instance.isPro();
    if (mounted) {
      setState(() {
        _isPro = isPro;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Material(
      type: MaterialType.transparency,
      child: Container(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.85,
        ),
        padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 20.0),
        decoration: BoxDecoration(
          color: isDark
              ? const Color.fromARGB(220, 45, 45, 45)
              : const Color.fromARGB(240, 255, 255, 255),
          borderRadius: BorderRadius.circular(20.0),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.15),
              spreadRadius: 2,
              blurRadius: 15,
            ),
          ],
        ),
        child: IntrinsicHeight(
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              // Tags Column
              Flexible(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text(
                        'Tags',
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                          fontFamily: 'EBGaramond',
                        ),
                      ),
                    ),
                    if (widget.quote.tags.isEmpty)
                      const Text(
                        'No tags for this quote.',
                        style: TextStyle(
                          fontStyle: FontStyle.italic,
                          fontFamily: 'EBGaramond',
                        ),
                      )
                    else
                      Wrap(
                        spacing: 8.0,
                        runSpacing: 8.0,
                        children: widget.quote.tags.map((tag) {
                          return widget.buildTagChip(
                            tag,
                            onTap: (selectedTag) {
                              _close();
                              widget.onTagToggled(selectedTag);
                            },
                          );
                        }).toList(),
                      ),
                  ],
                ),
              ),

              const VerticalDivider(width: 24),

              // Author Column
              Flexible(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text(
                        'Author',
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                          fontFamily: 'EBGaramond',
                        ),
                      ),
                    ),
                    _buildGatedAuthorChip(),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGatedAuthorChip() {
    if (_isPro) {
      // Pro users get normal author chip functionality
      return widget.buildAuthorChip(
        widget.quote.authorName,
        onTap: (selectedAuthor) {
          _close();
          widget.onAuthorToggled(selectedAuthor);
        },
      );
    } else {
      // Free users get grayed out chip that opens paywall
      return GestureDetector(
        onTap: () {
          _close();
          openPaywall(context: context, contextKey: 'browse_author');
        },
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
          decoration: BoxDecoration(
            color: Theme.of(context).primaryColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(16.0),
            border: Border.all(
              color: Theme.of(context).primaryColor.withOpacity(0.2),
              width: 0.5,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                widget.quote.authorName,
                style: TextStyle(
                  color: Theme.of(context).primaryColor.withOpacity(0.4),
                  fontSize: 12.0,
                  fontWeight: FontWeight.w500,
                  fontFamily: 'EBGaramond',
                ),
              ),
              const SizedBox(width: 6.0),
              Icon(
                Icons.lock_outline,
                size: 14.0,
                color: Theme.of(context).primaryColor.withOpacity(0.4),
              ),
            ],
          ),
        ),
      );
    }
  }
}


===== widgets/tip_island.dart =====

import 'package:flutter/material.dart';

class TipIsland extends StatefulWidget {
  final String message;
  final IconData icon;
  final VoidCallback onDismiss;

  const TipIsland({
    super.key,
    required this.message,
    required this.icon,
    required this.onDismiss,
  });

  @override
  State<TipIsland> createState() => _TipIslandState();
}

class _TipIslandState extends State<TipIsland>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500),
    );
    _animation = CurvedAnimation(parent: _controller, curve: Curves.easeIn);
    _controller.forward();

    // Auto-hide after 6 seconds
    Future.delayed(const Duration(seconds: 6), () {
      if (mounted) {
        _controller.reverse();
      }
    });

    // Add listener to detect when dismiss animation completes
    _controller.addStatusListener((status) {
      if (status == AnimationStatus.dismissed) {
        widget.onDismiss();
      }
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: Card(
        margin: const EdgeInsets.all(8.0),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        elevation: 2,
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Theme.of(context).primaryColor.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  widget.icon,
                  color: Theme.of(context).primaryColor,
                  size: 20,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  widget.message,
                  style: Theme.of(
                    context,
                  ).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w500),
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close, size: 18),
                onPressed: () => _controller.reverse(),
                color: Colors.grey.shade600,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== widgets/quote_card.dart =====

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../quote.dart';
import '../utils/font_size_helpers.dart';
import '../theme/lb_theme_extension.dart';

class QuoteCard extends StatelessWidget {
  final Quote quote;
  final VoidCallback onDoubleTap;
  final VoidCallback onReadMore;
  final Animation<double> heartAnimation;

  const QuoteCard({
    super.key,
    required this.quote,
    required this.onDoubleTap,
    required this.onReadMore,
    required this.heartAnimation,
  });

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();

    return GestureDetector(
      onDoubleTap: () {
        HapticFeedback.lightImpact();
        onDoubleTap();
      },
      child: Stack(
        alignment: Alignment.center,
        children: [
          SizedBox(
            height: double.infinity,
            child: Center(
              child: SingleChildScrollView(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: <Widget>[
                    Padding(
                      padding: const EdgeInsets.only(
                        left: 32.0,
                        bottom: 10.0,
                        top: 32.0,
                        right: 32.0,
                      ),
                      child: Align(
                        alignment: Alignment.centerLeft,
                        child: Text(
                          quote.text,
                          style:
                              lbTheme?.quoteTextStyle(
                                context,
                                getFontSize(quote.text),
                              ) ??
                              Theme.of(
                                context,
                              ).textTheme.headlineSmall!.copyWith(
                                fontSize: getFontSize(quote.text),
                                fontWeight: FontWeight.w500,
                                color: Theme.of(context).primaryColor,
                                height: 1.4,
                              ),
                          textAlign: TextAlign.left,
                        ),
                      ),
                    ),
                    const SizedBox(height: 20.0),
                    Padding(
                      padding: const EdgeInsets.only(
                        left: 32.0,
                        right: 32.0,
                        top: 10.0,
                      ),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: Text(
                          '— ${quote.authorInfo}',
                          style:
                              lbTheme?.authorTextStyle(
                                context,
                                getSourceFontSize(quote.authorInfo),
                              ) ??
                              Theme.of(context).textTheme.titleSmall!.copyWith(
                                fontSize: getSourceFontSize(quote.authorInfo),
                                fontWeight: FontWeight.w300,
                                color: const Color.fromARGB(255, 166, 165, 165),
                              ),
                          textAlign: TextAlign.right,
                        ),
                      ),
                    ),
                    if (quote.displaySource.isNotEmpty) ...[
                      const SizedBox(height: 8.0),
                      Padding(
                        padding: const EdgeInsets.only(left: 32.0, right: 32.0),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: Text(
                            quote.displaySource,
                            style:
                                lbTheme?.sourceTextStyle(
                                  context,
                                  getSourceFontSize(quote.displaySource) - 2,
                                ) ??
                                Theme.of(
                                  context,
                                ).textTheme.labelLarge!.copyWith(
                                  fontSize:
                                      getSourceFontSize(quote.displaySource) -
                                      2,
                                  fontWeight: FontWeight.w300,
                                  color: const Color.fromARGB(
                                    255,
                                    140,
                                    140,
                                    140,
                                  ),
                                  fontStyle: FontStyle.italic,
                                ),
                            textAlign: TextAlign.right,
                          ),
                        ),
                      ),
                    ],
                    const SizedBox(height: 24),
                    OutlinedButton(
                      onPressed: () {
                        HapticFeedback.selectionClick();
                        onReadMore();
                      },
                      style: OutlinedButton.styleFrom(
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(30.0),
                        ),
                        side: BorderSide(
                          width: 0.5,
                          color: Theme.of(
                            context,
                          ).primaryColor.withOpacity(0.5),
                        ),
                        padding: const EdgeInsets.symmetric(
                          horizontal: 24.0,
                          vertical: 12.0,
                        ),
                      ),
                      child: Text(
                        'Read more »',
                        style:
                            lbTheme?.buttonTextStyle(context) ??
                            Theme.of(context).textTheme.labelLarge!.copyWith(
                              color: Theme.of(context).primaryColor,
                            ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          FadeTransition(
            opacity: heartAnimation,
            child: ScaleTransition(
              scale: heartAnimation,
              child: Icon(
                Icons.favorite,
                size: 120,
                color: Colors.red.withOpacity(0.8),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


===== widgets/reward_island.dart =====

import 'package:flutter/material.dart';

class RewardIsland extends StatefulWidget {
  final String featureKey;
  final VoidCallback onDismiss;

  const RewardIsland({
    super.key,
    required this.featureKey,
    required this.onDismiss,
  });

  @override
  State<RewardIsland> createState() => _RewardIslandState();
}

class _RewardIslandState extends State<RewardIsland>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500),
    );
    _animation = CurvedAnimation(parent: _controller, curve: Curves.easeIn);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: Card(
        margin: const EdgeInsets.all(8.0),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            children: [
              const Icon(Icons.star, color: Colors.amber),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  'You\'ve unlocked a Pro feature for 7 days: You can now ${widget.featureKey.replaceAll('_', ' ')}!',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: widget.onDismiss,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== widgets/tag_chip.dart =====

import 'package:flutter/material.dart';
import 'package:quotes_app/theme/lb_theme_extension.dart';

class TagChip extends StatelessWidget {
  final String tag;
  final bool isSelected;
  final void Function(String)? onTap;

  const TagChip({
    super.key,
    required this.tag,
    required this.isSelected,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();
    final colorScheme = Theme.of(context).colorScheme;

    return GestureDetector(
      onTap: () {
        if (onTap != null) {
          onTap!(tag);
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: isSelected
              ? colorScheme.primary.withOpacity(0.12)
              : lbTheme?.controlSurface ?? colorScheme.surface,
          borderRadius: BorderRadius.circular(16.0),
          border: Border.all(
            color: isSelected
                ? colorScheme.primary
                : lbTheme?.controlBorder ??
                      colorScheme.outline.withOpacity(0.3),
            width: isSelected ? 1.0 : 0.5,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              tag,
              style: Theme.of(context).textTheme.labelMedium?.copyWith(
                color: isSelected
                    ? colorScheme.primary
                    : colorScheme.onSurface.withOpacity(0.7),
                fontSize: 12.0,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.w500,
              ),
            ),
            if (isSelected) ...[
              const SizedBox(width: 6.0),
              Icon(Icons.close, size: 14.0, color: colorScheme.primary),
            ],
          ],
        ),
      ),
    );
  }
}


===== widgets/details_card.dart =====

import 'package:flutter/material.dart';
import '../quote.dart';
import '../theme/lb_theme_extension.dart';

class DetailsCard extends StatelessWidget {
  final Quote quote;
  final VoidCallback onHide;
  final Widget Function(String, {void Function(String)? onTap}) buildTagChip;
  final ScrollController? controller;

  const DetailsCard({
    super.key,
    required this.quote,
    required this.onHide,
    required this.buildTagChip,
    this.controller,
  });

  @override
  Widget build(BuildContext context) {
    final lbTheme = Theme.of(context).extension<LBTheme>();

    return SingleChildScrollView(
      controller: controller,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 48),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '"${quote.text}"',
              style:
                  lbTheme?.quoteTextStyle(context, 22) ??
                  Theme.of(context).textTheme.headlineSmall!.copyWith(
                    fontSize: 22,
                    fontStyle: FontStyle.italic,
                    color: Theme.of(context).primaryColor,
                    height: 1.5,
                  ),
            ),
            const SizedBox(height: 24),
            if (quote.interpretation != null &&
                quote.interpretation!.isNotEmpty) ...[
              Text(
                'Interpretation',
                style: Theme.of(context).textTheme.titleLarge!.copyWith(
                  fontWeight: FontWeight.bold,
                  fontSize: 20,
                  color: Theme.of(context).primaryColor,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                quote.interpretation!,
                style: Theme.of(context).textTheme.bodyLarge!.copyWith(
                  fontSize: 16,
                  height: 1.6,
                  color: Theme.of(context).primaryColor.withOpacity(0.85),
                ),
              ),
              const SizedBox(height: 32),
            ],
            const Divider(),
            const SizedBox(height: 24),
            _buildDetailSection('Author', quote.authorInfo, context),
            if (quote.displaySource.isNotEmpty)
              _buildDetailSection('Source', quote.displaySource, context),
            if (quote.sourceBlurb != null && quote.sourceBlurb!.isNotEmpty)
              _buildDetailSection('Source Note', quote.sourceBlurb!, context),
            const SizedBox(height: 24),
            if (quote.tags.isNotEmpty)
              _buildTagsDetailSection('Tags', quote.tags, context),
            const SizedBox(height: 48),
            Center(
              child: OutlinedButton(
                onPressed: onHide,
                style: OutlinedButton.styleFrom(
                  shape: const StadiumBorder(),
                  side: BorderSide(
                    width: 0.2,
                    color: Theme.of(context).primaryColor,
                  ),
                ),
                child: Text(
                  '« Back to Quote',
                  style: Theme.of(context).textTheme.labelLarge!.copyWith(
                    color: Theme.of(context).primaryColor,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDetailSection(
    String title,
    String content,
    BuildContext context,
  ) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleMedium!.copyWith(
              color: Theme.of(context).primaryColor.withOpacity(0.7),
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            content,
            style: Theme.of(context).textTheme.bodyMedium!.copyWith(
              color: Theme.of(context).primaryColor,
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTagsDetailSection(
    String title,
    List<String> tags,
    BuildContext context,
  ) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleMedium!.copyWith(
              color: Theme.of(context).primaryColor.withOpacity(0.7),
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8.0,
            runSpacing: 8.0,
            children: tags.map((tag) => buildTagChip(tag)).toList(),
          ),
        ],
      ),
    );
  }
}
